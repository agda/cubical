<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Cubical.Talks.EPA2020</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">{-

Cubical Agda - A Dependently Typed PL with Univalence and HITs
==============================================================
                    Anders Mörtberg
       Every Proof Assistant - September 17, 2020


Link to slides: https://staff.math.su.se/anders.mortberg/slides/EPA2020.pdf

Link to video: https://vimeo.com/459020971

-}</a>

<a id="344" class="Comment">-- To make Agda cubical add the --cubical option.</a>
<a id="394" class="Comment">-- This is implicitly added for files in the cubical library via the cubical.agda-lib file.</a>
<a id="486" class="Symbol">{-#</a> <a id="490" class="Keyword">OPTIONS</a> <a id="498" class="Pragma">--safe</a> <a id="505" class="Symbol">#-}</a>
<a id="509" class="Keyword">module</a> <a id="516" href="Cubical.Talks.EPA2020.html" class="Module">Cubical.Talks.EPA2020</a> <a id="538" class="Keyword">where</a>

<a id="545" class="Comment">-- The &quot;Foundations&quot; package contain a lot of important results (in</a>
<a id="613" class="Comment">-- particular the univalence theorem)</a>
<a id="651" class="Keyword">open</a> <a id="656" class="Keyword">import</a> <a id="663" href="Cubical.Foundations.Prelude.html" class="Module">Cubical.Foundations.Prelude</a>
<a id="691" class="Keyword">open</a> <a id="696" class="Keyword">import</a> <a id="703" href="Cubical.Foundations.Equiv.html" class="Module">Cubical.Foundations.Equiv</a>
<a id="729" class="Keyword">open</a> <a id="734" class="Keyword">import</a> <a id="741" href="Cubical.Foundations.Isomorphism.html" class="Module">Cubical.Foundations.Isomorphism</a>
<a id="773" class="Keyword">open</a> <a id="778" class="Keyword">import</a> <a id="785" href="Cubical.Foundations.Univalence.html" class="Module">Cubical.Foundations.Univalence</a>

<a id="817" class="Keyword">open</a> <a id="822" class="Keyword">import</a> <a id="829" href="Cubical.Data.Int.html" class="Module">Cubical.Data.Int</a>
<a id="846" class="Keyword">open</a> <a id="851" class="Keyword">import</a> <a id="858" href="Cubical.Data.Prod.Base.html" class="Module">Cubical.Data.Prod.Base</a>


<a id="883" class="Comment">-- The interval in Cubical Agda is written I and the endpoints i0 and i1.</a>

<a id="apply0"></a><a id="958" href="Cubical.Talks.EPA2020.html#958" class="Function">apply0</a> <a id="965" class="Symbol">:</a> <a id="967" class="Symbol">(</a><a id="968" href="Cubical.Talks.EPA2020.html#968" class="Bound">A</a> <a id="970" class="Symbol">:</a> <a id="972" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="976" class="Symbol">)</a> <a id="978" class="Symbol">(</a><a id="979" href="Cubical.Talks.EPA2020.html#979" class="Bound">p</a> <a id="981" class="Symbol">:</a> <a id="983" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a> <a id="985" class="Symbol">→</a> <a id="987" href="Cubical.Talks.EPA2020.html#968" class="Bound">A</a><a id="988" class="Symbol">)</a> <a id="990" class="Symbol">→</a> <a id="992" href="Cubical.Talks.EPA2020.html#968" class="Bound">A</a>
<a id="994" href="Cubical.Talks.EPA2020.html#958" class="Function">apply0</a> <a id="1001" href="Cubical.Talks.EPA2020.html#1001" class="Bound">A</a> <a id="1003" href="Cubical.Talks.EPA2020.html#1003" class="Bound">p</a> <a id="1005" class="Symbol">=</a> <a id="1007" href="Cubical.Talks.EPA2020.html#1003" class="Bound">p</a> <a id="1009" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a>

<a id="1013" class="Comment">-- We omit the universe level ℓ for simplicity in this talk. In the</a>
<a id="1081" class="Comment">-- library everything is maximally universe polymorphic.</a>


<a id="1140" class="Comment">-- We can write functions out of the interval using λ-abstraction:</a>
<a id="refl&#39;"></a><a id="1207" href="Cubical.Talks.EPA2020.html#1207" class="Function">refl&#39;</a> <a id="1213" class="Symbol">:</a> <a id="1215" class="Symbol">{</a><a id="1216" href="Cubical.Talks.EPA2020.html#1216" class="Bound">A</a> <a id="1218" class="Symbol">:</a> <a id="1220" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="1224" class="Symbol">}</a> <a id="1226" class="Symbol">(</a><a id="1227" href="Cubical.Talks.EPA2020.html#1227" class="Bound">x</a> <a id="1229" class="Symbol">:</a> <a id="1231" href="Cubical.Talks.EPA2020.html#1216" class="Bound">A</a><a id="1232" class="Symbol">)</a> <a id="1234" class="Symbol">→</a> <a id="1236" href="Cubical.Talks.EPA2020.html#1227" class="Bound">x</a> <a id="1238" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="1240" href="Cubical.Talks.EPA2020.html#1227" class="Bound">x</a>
<a id="1242" href="Cubical.Talks.EPA2020.html#1207" class="Function">refl&#39;</a> <a id="1248" href="Cubical.Talks.EPA2020.html#1248" class="Bound">x</a> <a id="1250" class="Symbol">=</a> <a id="1252" class="Symbol">λ</a> <a id="1254" href="Cubical.Talks.EPA2020.html#1254" class="Bound">i</a> <a id="1256" class="Symbol">→</a> <a id="1258" href="Cubical.Talks.EPA2020.html#1248" class="Bound">x</a>
<a id="1260" class="Comment">-- In fact, x ≡ y is short for PathP (λ _ → A) x y</a>

<a id="refl&#39;&#39;"></a><a id="1312" href="Cubical.Talks.EPA2020.html#1312" class="Function">refl&#39;&#39;</a> <a id="1319" class="Symbol">:</a> <a id="1321" class="Symbol">{</a><a id="1322" href="Cubical.Talks.EPA2020.html#1322" class="Bound">A</a> <a id="1324" class="Symbol">:</a> <a id="1326" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="1330" class="Symbol">}</a> <a id="1332" class="Symbol">(</a><a id="1333" href="Cubical.Talks.EPA2020.html#1333" class="Bound">x</a> <a id="1335" class="Symbol">:</a> <a id="1337" href="Cubical.Talks.EPA2020.html#1322" class="Bound">A</a><a id="1338" class="Symbol">)</a> <a id="1340" class="Symbol">→</a> <a id="1342" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="1348" class="Symbol">(λ</a> <a id="1351" href="Cubical.Talks.EPA2020.html#1351" class="Bound">_</a> <a id="1353" class="Symbol">→</a> <a id="1355" href="Cubical.Talks.EPA2020.html#1322" class="Bound">A</a><a id="1356" class="Symbol">)</a> <a id="1358" href="Cubical.Talks.EPA2020.html#1333" class="Bound">x</a> <a id="1360" href="Cubical.Talks.EPA2020.html#1333" class="Bound">x</a>
<a id="1362" href="Cubical.Talks.EPA2020.html#1312" class="Function">refl&#39;&#39;</a> <a id="1369" href="Cubical.Talks.EPA2020.html#1369" class="Bound">x</a> <a id="1371" class="Symbol">=</a> <a id="1373" class="Symbol">λ</a> <a id="1375" href="Cubical.Talks.EPA2020.html#1375" class="Bound">_</a> <a id="1377" class="Symbol">→</a> <a id="1379" href="Cubical.Talks.EPA2020.html#1369" class="Bound">x</a>

<a id="1382" class="Comment">-- In general PathP A x y has A : I → Type, x : A i0 and y : A i1</a>
<a id="1448" class="Comment">-- PathP = Dependent paths (Path over a Path)</a>

<a id="1495" class="Comment">-- We cannot pattern-match on interval variables as I is not inductively defined</a>
<a id="1576" class="Comment">-- foo : {A : Type} → I → A</a>
<a id="1604" class="Comment">-- foo r = {!r!}   -- Try typing C-c C-c</a>

<a id="1646" class="Comment">-- cong has a direct proof</a>
<a id="cong&#39;"></a><a id="1673" href="Cubical.Talks.EPA2020.html#1673" class="Function">cong&#39;</a> <a id="1679" class="Symbol">:</a> <a id="1681" class="Symbol">{</a><a id="1682" href="Cubical.Talks.EPA2020.html#1682" class="Bound">A</a> <a id="1684" href="Cubical.Talks.EPA2020.html#1684" class="Bound">B</a> <a id="1686" class="Symbol">:</a> <a id="1688" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="1692" class="Symbol">}</a> <a id="1694" class="Symbol">(</a><a id="1695" href="Cubical.Talks.EPA2020.html#1695" class="Bound">f</a> <a id="1697" class="Symbol">:</a> <a id="1699" href="Cubical.Talks.EPA2020.html#1682" class="Bound">A</a> <a id="1701" class="Symbol">→</a> <a id="1703" href="Cubical.Talks.EPA2020.html#1684" class="Bound">B</a><a id="1704" class="Symbol">)</a> <a id="1706" class="Symbol">{</a><a id="1707" href="Cubical.Talks.EPA2020.html#1707" class="Bound">x</a> <a id="1709" href="Cubical.Talks.EPA2020.html#1709" class="Bound">y</a> <a id="1711" class="Symbol">:</a> <a id="1713" href="Cubical.Talks.EPA2020.html#1682" class="Bound">A</a><a id="1714" class="Symbol">}</a> <a id="1716" class="Symbol">→</a> <a id="1718" href="Cubical.Talks.EPA2020.html#1707" class="Bound">x</a> <a id="1720" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="1722" href="Cubical.Talks.EPA2020.html#1709" class="Bound">y</a> <a id="1724" class="Symbol">→</a> <a id="1726" href="Cubical.Talks.EPA2020.html#1695" class="Bound">f</a> <a id="1728" href="Cubical.Talks.EPA2020.html#1707" class="Bound">x</a> <a id="1730" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="1732" href="Cubical.Talks.EPA2020.html#1695" class="Bound">f</a> <a id="1734" href="Cubical.Talks.EPA2020.html#1709" class="Bound">y</a>
<a id="1736" href="Cubical.Talks.EPA2020.html#1673" class="Function">cong&#39;</a> <a id="1742" href="Cubical.Talks.EPA2020.html#1742" class="Bound">f</a> <a id="1744" href="Cubical.Talks.EPA2020.html#1744" class="Bound">p</a> <a id="1746" href="Cubical.Talks.EPA2020.html#1746" class="Bound">i</a> <a id="1748" class="Symbol">=</a> <a id="1750" href="Cubical.Talks.EPA2020.html#1742" class="Bound">f</a> <a id="1752" class="Symbol">(</a><a id="1753" href="Cubical.Talks.EPA2020.html#1744" class="Bound">p</a> <a id="1755" href="Cubical.Talks.EPA2020.html#1746" class="Bound">i</a><a id="1756" class="Symbol">)</a>

<a id="1759" class="Comment">-- function extensionality also has a direct proof.</a>
<a id="1811" class="Comment">-- It also has computational content: swap the arguments.</a>
<a id="funExt&#39;"></a><a id="1869" href="Cubical.Talks.EPA2020.html#1869" class="Function">funExt&#39;</a> <a id="1877" class="Symbol">:</a> <a id="1879" class="Symbol">{</a><a id="1880" href="Cubical.Talks.EPA2020.html#1880" class="Bound">A</a> <a id="1882" href="Cubical.Talks.EPA2020.html#1882" class="Bound">B</a> <a id="1884" class="Symbol">:</a> <a id="1886" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="1890" class="Symbol">}</a> <a id="1892" class="Symbol">{</a><a id="1893" href="Cubical.Talks.EPA2020.html#1893" class="Bound">f</a> <a id="1895" href="Cubical.Talks.EPA2020.html#1895" class="Bound">g</a> <a id="1897" class="Symbol">:</a> <a id="1899" href="Cubical.Talks.EPA2020.html#1880" class="Bound">A</a> <a id="1901" class="Symbol">→</a> <a id="1903" href="Cubical.Talks.EPA2020.html#1882" class="Bound">B</a><a id="1904" class="Symbol">}</a> <a id="1906" class="Symbol">(</a><a id="1907" href="Cubical.Talks.EPA2020.html#1907" class="Bound">p</a> <a id="1909" class="Symbol">:</a> <a id="1911" class="Symbol">(</a><a id="1912" href="Cubical.Talks.EPA2020.html#1912" class="Bound">x</a> <a id="1914" class="Symbol">:</a> <a id="1916" href="Cubical.Talks.EPA2020.html#1880" class="Bound">A</a><a id="1917" class="Symbol">)</a> <a id="1919" class="Symbol">→</a> <a id="1921" href="Cubical.Talks.EPA2020.html#1893" class="Bound">f</a> <a id="1923" href="Cubical.Talks.EPA2020.html#1912" class="Bound">x</a> <a id="1925" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="1927" href="Cubical.Talks.EPA2020.html#1895" class="Bound">g</a> <a id="1929" href="Cubical.Talks.EPA2020.html#1912" class="Bound">x</a><a id="1930" class="Symbol">)</a> <a id="1932" class="Symbol">→</a> <a id="1934" href="Cubical.Talks.EPA2020.html#1893" class="Bound">f</a> <a id="1936" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="1938" href="Cubical.Talks.EPA2020.html#1895" class="Bound">g</a>
<a id="1940" href="Cubical.Talks.EPA2020.html#1869" class="Function">funExt&#39;</a> <a id="1948" href="Cubical.Talks.EPA2020.html#1948" class="Bound">p</a> <a id="1950" href="Cubical.Talks.EPA2020.html#1950" class="Bound">i</a> <a id="1952" href="Cubical.Talks.EPA2020.html#1952" class="Bound">x</a> <a id="1954" class="Symbol">=</a> <a id="1956" href="Cubical.Talks.EPA2020.html#1948" class="Bound">p</a> <a id="1958" href="Cubical.Talks.EPA2020.html#1952" class="Bound">x</a> <a id="1960" href="Cubical.Talks.EPA2020.html#1950" class="Bound">i</a>

<a id="1963" class="Comment">-- Transport is more complex as ≡ isn&#39;t inductively defined (so we</a>
<a id="2030" class="Comment">-- can&#39;t define it by pattern-matching on p)</a>
<a id="transport&#39;"></a><a id="2075" href="Cubical.Talks.EPA2020.html#2075" class="Function">transport&#39;</a> <a id="2086" class="Symbol">:</a> <a id="2088" class="Symbol">{</a><a id="2089" href="Cubical.Talks.EPA2020.html#2089" class="Bound">A</a> <a id="2091" href="Cubical.Talks.EPA2020.html#2091" class="Bound">B</a> <a id="2093" class="Symbol">:</a> <a id="2095" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="2099" class="Symbol">}</a> <a id="2101" class="Symbol">→</a> <a id="2103" href="Cubical.Talks.EPA2020.html#2089" class="Bound">A</a> <a id="2105" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="2107" href="Cubical.Talks.EPA2020.html#2091" class="Bound">B</a> <a id="2109" class="Symbol">→</a> <a id="2111" href="Cubical.Talks.EPA2020.html#2089" class="Bound">A</a> <a id="2113" class="Symbol">→</a> <a id="2115" href="Cubical.Talks.EPA2020.html#2091" class="Bound">B</a>
<a id="2117" href="Cubical.Talks.EPA2020.html#2075" class="Function">transport&#39;</a> <a id="2128" href="Cubical.Talks.EPA2020.html#2128" class="Bound">p</a> <a id="2130" href="Cubical.Talks.EPA2020.html#2130" class="Bound">a</a> <a id="2132" class="Symbol">=</a> <a id="2134" href="Cubical.Core.Primitives.html#656" class="Primitive">transp</a> <a id="2141" class="Symbol">(λ</a> <a id="2144" href="Cubical.Talks.EPA2020.html#2144" class="Bound">i</a> <a id="2146" class="Symbol">→</a> <a id="2148" href="Cubical.Talks.EPA2020.html#2128" class="Bound">p</a> <a id="2150" href="Cubical.Talks.EPA2020.html#2144" class="Bound">i</a><a id="2151" class="Symbol">)</a> <a id="2153" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a> <a id="2156" href="Cubical.Talks.EPA2020.html#2130" class="Bound">a</a>

<a id="2159" class="Comment">-- This lets us define subst (which is called &quot;transport&quot; in the HoTT book)</a>
<a id="subst&#39;"></a><a id="2235" href="Cubical.Talks.EPA2020.html#2235" class="Function">subst&#39;</a> <a id="2242" class="Symbol">:</a> <a id="2244" class="Symbol">{</a><a id="2245" href="Cubical.Talks.EPA2020.html#2245" class="Bound">A</a> <a id="2247" class="Symbol">:</a> <a id="2249" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="2253" class="Symbol">}</a> <a id="2255" class="Symbol">(</a><a id="2256" href="Cubical.Talks.EPA2020.html#2256" class="Bound">P</a> <a id="2258" class="Symbol">:</a> <a id="2260" href="Cubical.Talks.EPA2020.html#2245" class="Bound">A</a> <a id="2262" class="Symbol">→</a> <a id="2264" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="2268" class="Symbol">)</a> <a id="2270" class="Symbol">{</a><a id="2271" href="Cubical.Talks.EPA2020.html#2271" class="Bound">x</a> <a id="2273" href="Cubical.Talks.EPA2020.html#2273" class="Bound">y</a> <a id="2275" class="Symbol">:</a> <a id="2277" href="Cubical.Talks.EPA2020.html#2245" class="Bound">A</a><a id="2278" class="Symbol">}</a> <a id="2280" class="Symbol">(</a><a id="2281" href="Cubical.Talks.EPA2020.html#2281" class="Bound">p</a> <a id="2283" class="Symbol">:</a> <a id="2285" href="Cubical.Talks.EPA2020.html#2271" class="Bound">x</a> <a id="2287" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="2289" href="Cubical.Talks.EPA2020.html#2273" class="Bound">y</a><a id="2290" class="Symbol">)</a> <a id="2292" class="Symbol">→</a> <a id="2294" href="Cubical.Talks.EPA2020.html#2256" class="Bound">P</a> <a id="2296" href="Cubical.Talks.EPA2020.html#2271" class="Bound">x</a> <a id="2298" class="Symbol">→</a> <a id="2300" href="Cubical.Talks.EPA2020.html#2256" class="Bound">P</a> <a id="2302" href="Cubical.Talks.EPA2020.html#2273" class="Bound">y</a>
<a id="2304" href="Cubical.Talks.EPA2020.html#2235" class="Function">subst&#39;</a> <a id="2311" href="Cubical.Talks.EPA2020.html#2311" class="Bound">P</a> <a id="2313" href="Cubical.Talks.EPA2020.html#2313" class="Bound">p</a> <a id="2315" href="Cubical.Talks.EPA2020.html#2315" class="Bound">pa</a> <a id="2318" class="Symbol">=</a> <a id="2320" href="Cubical.Foundations.Prelude.html#8626" class="Function">transport</a> <a id="2330" class="Symbol">(λ</a> <a id="2333" href="Cubical.Talks.EPA2020.html#2333" class="Bound">i</a> <a id="2335" class="Symbol">→</a> <a id="2337" href="Cubical.Talks.EPA2020.html#2311" class="Bound">P</a> <a id="2339" class="Symbol">(</a><a id="2340" href="Cubical.Talks.EPA2020.html#2313" class="Bound">p</a> <a id="2342" href="Cubical.Talks.EPA2020.html#2333" class="Bound">i</a><a id="2343" class="Symbol">))</a> <a id="2346" href="Cubical.Talks.EPA2020.html#2315" class="Bound">pa</a>

<a id="2350" class="Comment">-- The transp operation reduces differently for different types</a>
<a id="2414" class="Comment">-- formers. For paths it reduces to another primitive operation called</a>
<a id="2485" class="Comment">-- hcomp.</a>

<a id="2496" class="Comment">-- We can also define the J eliminator (aka path induction)</a>
<a id="J&#39;"></a><a id="2556" href="Cubical.Talks.EPA2020.html#2556" class="Function">J&#39;</a> <a id="2559" class="Symbol">:</a> <a id="2561" class="Symbol">{</a><a id="2562" href="Cubical.Talks.EPA2020.html#2562" class="Bound">A</a> <a id="2564" class="Symbol">:</a> <a id="2566" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="2570" class="Symbol">}</a> <a id="2572" class="Symbol">{</a><a id="2573" href="Cubical.Talks.EPA2020.html#2573" class="Bound">B</a> <a id="2575" class="Symbol">:</a> <a id="2577" href="Cubical.Talks.EPA2020.html#2562" class="Bound">A</a> <a id="2579" class="Symbol">→</a> <a id="2581" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="2585" class="Symbol">}</a> <a id="2587" class="Symbol">{</a><a id="2588" href="Cubical.Talks.EPA2020.html#2588" class="Bound">x</a> <a id="2590" class="Symbol">:</a> <a id="2592" href="Cubical.Talks.EPA2020.html#2562" class="Bound">A</a><a id="2593" class="Symbol">}</a>
     <a id="2600" class="Symbol">(</a><a id="2601" href="Cubical.Talks.EPA2020.html#2601" class="Bound">P</a> <a id="2603" class="Symbol">:</a> <a id="2605" class="Symbol">(</a><a id="2606" href="Cubical.Talks.EPA2020.html#2606" class="Bound">z</a> <a id="2608" class="Symbol">:</a> <a id="2610" href="Cubical.Talks.EPA2020.html#2562" class="Bound">A</a><a id="2611" class="Symbol">)</a> <a id="2613" class="Symbol">→</a> <a id="2615" href="Cubical.Talks.EPA2020.html#2588" class="Bound">x</a> <a id="2617" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="2619" href="Cubical.Talks.EPA2020.html#2606" class="Bound">z</a> <a id="2621" class="Symbol">→</a> <a id="2623" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="2627" class="Symbol">)</a>
     <a id="2634" class="Symbol">(</a><a id="2635" href="Cubical.Talks.EPA2020.html#2635" class="Bound">d</a> <a id="2637" class="Symbol">:</a> <a id="2639" href="Cubical.Talks.EPA2020.html#2601" class="Bound">P</a> <a id="2641" href="Cubical.Talks.EPA2020.html#2588" class="Bound">x</a> <a id="2643" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a><a id="2647" class="Symbol">)</a> <a id="2649" class="Symbol">{</a><a id="2650" href="Cubical.Talks.EPA2020.html#2650" class="Bound">y</a> <a id="2652" class="Symbol">:</a> <a id="2654" href="Cubical.Talks.EPA2020.html#2562" class="Bound">A</a><a id="2655" class="Symbol">}</a> <a id="2657" class="Symbol">(</a><a id="2658" href="Cubical.Talks.EPA2020.html#2658" class="Bound">p</a> <a id="2660" class="Symbol">:</a> <a id="2662" href="Cubical.Talks.EPA2020.html#2588" class="Bound">x</a> <a id="2664" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="2666" href="Cubical.Talks.EPA2020.html#2650" class="Bound">y</a><a id="2667" class="Symbol">)</a> <a id="2669" class="Symbol">→</a> <a id="2671" href="Cubical.Talks.EPA2020.html#2601" class="Bound">P</a> <a id="2673" href="Cubical.Talks.EPA2020.html#2650" class="Bound">y</a> <a id="2675" href="Cubical.Talks.EPA2020.html#2658" class="Bound">p</a>
<a id="2677" href="Cubical.Talks.EPA2020.html#2556" class="Function">J&#39;</a> <a id="2680" href="Cubical.Talks.EPA2020.html#2680" class="Bound">P</a> <a id="2682" href="Cubical.Talks.EPA2020.html#2682" class="Bound">d</a> <a id="2684" href="Cubical.Talks.EPA2020.html#2684" class="Bound">p</a> <a id="2686" class="Symbol">=</a> <a id="2688" href="Cubical.Foundations.Prelude.html#8626" class="Function">transport</a> <a id="2698" class="Symbol">(λ</a> <a id="2701" href="Cubical.Talks.EPA2020.html#2701" class="Bound">i</a> <a id="2703" class="Symbol">→</a> <a id="2705" href="Cubical.Talks.EPA2020.html#2680" class="Bound">P</a> <a id="2707" class="Symbol">(</a><a id="2708" href="Cubical.Talks.EPA2020.html#2684" class="Bound">p</a> <a id="2710" href="Cubical.Talks.EPA2020.html#2701" class="Bound">i</a><a id="2711" class="Symbol">)</a> <a id="2713" class="Symbol">(λ</a> <a id="2716" href="Cubical.Talks.EPA2020.html#2716" class="Bound">j</a> <a id="2718" class="Symbol">→</a> <a id="2720" href="Cubical.Talks.EPA2020.html#2684" class="Bound">p</a> <a id="2722" class="Symbol">(</a><a id="2723" href="Cubical.Talks.EPA2020.html#2701" class="Bound">i</a> <a id="2725" href="Cubical.Core.Primitives.html#403" class="Primitive Operator">∧</a> <a id="2727" href="Cubical.Talks.EPA2020.html#2716" class="Bound">j</a><a id="2728" class="Symbol">)))</a> <a id="2732" href="Cubical.Talks.EPA2020.html#2682" class="Bound">d</a>

<a id="2735" class="Comment">-- So J is provable, but it doesn&#39;t satisfy computation rule</a>
<a id="2796" class="Comment">-- definitionally. This is almost never a problem in practice as the</a>
<a id="2865" class="Comment">-- cubical primitives satisfy many new definitional equalities.</a>



<a id="2932" class="Comment">-- Another key concept in HoTT/UF is the Univalence Axiom. In Cubical</a>
<a id="3002" class="Comment">-- Agda this is provable, we hence refer to it as the Univalence</a>
<a id="3067" class="Comment">-- Theorem.</a>

<a id="3080" class="Comment">-- The univalence theorem: equivalences of types give paths of types</a>
<a id="ua&#39;"></a><a id="3149" href="Cubical.Talks.EPA2020.html#3149" class="Function">ua&#39;</a> <a id="3153" class="Symbol">:</a> <a id="3155" class="Symbol">{</a><a id="3156" href="Cubical.Talks.EPA2020.html#3156" class="Bound">A</a> <a id="3158" href="Cubical.Talks.EPA2020.html#3158" class="Bound">B</a> <a id="3160" class="Symbol">:</a> <a id="3162" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="3166" class="Symbol">}</a> <a id="3168" class="Symbol">→</a> <a id="3170" href="Cubical.Talks.EPA2020.html#3156" class="Bound">A</a> <a id="3172" href="Agda.Builtin.Cubical.Glue.html#1005" class="Function Operator">≃</a> <a id="3174" href="Cubical.Talks.EPA2020.html#3158" class="Bound">B</a> <a id="3176" class="Symbol">→</a> <a id="3178" href="Cubical.Talks.EPA2020.html#3156" class="Bound">A</a> <a id="3180" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="3182" href="Cubical.Talks.EPA2020.html#3158" class="Bound">B</a>
<a id="3184" href="Cubical.Talks.EPA2020.html#3149" class="Function">ua&#39;</a> <a id="3188" class="Symbol">=</a> <a id="3190" href="Cubical.Foundations.Univalence.html#928" class="Function">ua</a>

<a id="3194" class="Comment">-- Any isomorphism of types gives rise to an equivalence</a>
<a id="isoToEquiv&#39;"></a><a id="3251" href="Cubical.Talks.EPA2020.html#3251" class="Function">isoToEquiv&#39;</a> <a id="3263" class="Symbol">:</a> <a id="3265" class="Symbol">{</a><a id="3266" href="Cubical.Talks.EPA2020.html#3266" class="Bound">A</a> <a id="3268" href="Cubical.Talks.EPA2020.html#3268" class="Bound">B</a> <a id="3270" class="Symbol">:</a> <a id="3272" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="3276" class="Symbol">}</a> <a id="3278" class="Symbol">→</a> <a id="3280" href="Cubical.Foundations.Isomorphism.html#773" class="Record">Iso</a> <a id="3284" href="Cubical.Talks.EPA2020.html#3266" class="Bound">A</a> <a id="3286" href="Cubical.Talks.EPA2020.html#3268" class="Bound">B</a> <a id="3288" class="Symbol">→</a> <a id="3290" href="Cubical.Talks.EPA2020.html#3266" class="Bound">A</a> <a id="3292" href="Agda.Builtin.Cubical.Glue.html#1005" class="Function Operator">≃</a> <a id="3294" href="Cubical.Talks.EPA2020.html#3268" class="Bound">B</a>
<a id="3296" href="Cubical.Talks.EPA2020.html#3251" class="Function">isoToEquiv&#39;</a> <a id="3308" class="Symbol">=</a> <a id="3310" href="Cubical.Foundations.Isomorphism.html#3127" class="Function">isoToEquiv</a>

<a id="3322" class="Comment">-- And hence to a path</a>
<a id="isoToPath&#39;"></a><a id="3345" href="Cubical.Talks.EPA2020.html#3345" class="Function">isoToPath&#39;</a> <a id="3356" class="Symbol">:</a> <a id="3358" class="Symbol">{</a><a id="3359" href="Cubical.Talks.EPA2020.html#3359" class="Bound">A</a> <a id="3361" href="Cubical.Talks.EPA2020.html#3361" class="Bound">B</a> <a id="3363" class="Symbol">:</a> <a id="3365" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="3369" class="Symbol">}</a> <a id="3371" class="Symbol">→</a> <a id="3373" href="Cubical.Foundations.Isomorphism.html#773" class="Record">Iso</a> <a id="3377" href="Cubical.Talks.EPA2020.html#3359" class="Bound">A</a> <a id="3379" href="Cubical.Talks.EPA2020.html#3361" class="Bound">B</a> <a id="3381" class="Symbol">→</a> <a id="3383" href="Cubical.Talks.EPA2020.html#3359" class="Bound">A</a> <a id="3385" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="3387" href="Cubical.Talks.EPA2020.html#3361" class="Bound">B</a>
<a id="3389" href="Cubical.Talks.EPA2020.html#3345" class="Function">isoToPath&#39;</a> <a id="3400" href="Cubical.Talks.EPA2020.html#3400" class="Bound">e</a> <a id="3402" class="Symbol">=</a> <a id="3404" href="Cubical.Talks.EPA2020.html#3149" class="Function">ua&#39;</a> <a id="3408" class="Symbol">(</a><a id="3409" href="Cubical.Talks.EPA2020.html#3251" class="Function">isoToEquiv&#39;</a> <a id="3421" href="Cubical.Talks.EPA2020.html#3400" class="Bound">e</a><a id="3422" class="Symbol">)</a>

<a id="3425" class="Comment">-- ua satisfies the following computation rule</a>
<a id="3472" class="Comment">-- This suffices to be able to prove the standard formulation of univalence.</a>
<a id="uaβ&#39;"></a><a id="3549" href="Cubical.Talks.EPA2020.html#3549" class="Function">uaβ&#39;</a> <a id="3554" class="Symbol">:</a> <a id="3556" class="Symbol">{</a><a id="3557" href="Cubical.Talks.EPA2020.html#3557" class="Bound">A</a> <a id="3559" href="Cubical.Talks.EPA2020.html#3559" class="Bound">B</a> <a id="3561" class="Symbol">:</a> <a id="3563" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="3567" class="Symbol">}</a> <a id="3569" class="Symbol">(</a><a id="3570" href="Cubical.Talks.EPA2020.html#3570" class="Bound">e</a> <a id="3572" class="Symbol">:</a> <a id="3574" href="Cubical.Talks.EPA2020.html#3557" class="Bound">A</a> <a id="3576" href="Agda.Builtin.Cubical.Glue.html#1005" class="Function Operator">≃</a> <a id="3578" href="Cubical.Talks.EPA2020.html#3559" class="Bound">B</a><a id="3579" class="Symbol">)</a> <a id="3581" class="Symbol">(</a><a id="3582" href="Cubical.Talks.EPA2020.html#3582" class="Bound">x</a> <a id="3584" class="Symbol">:</a> <a id="3586" href="Cubical.Talks.EPA2020.html#3557" class="Bound">A</a><a id="3587" class="Symbol">)</a>
     <a id="3594" class="Symbol">→</a> <a id="3596" href="Cubical.Foundations.Prelude.html#8626" class="Function">transport</a> <a id="3606" class="Symbol">(</a><a id="3607" href="Cubical.Talks.EPA2020.html#3149" class="Function">ua&#39;</a> <a id="3611" href="Cubical.Talks.EPA2020.html#3570" class="Bound">e</a><a id="3612" class="Symbol">)</a> <a id="3614" href="Cubical.Talks.EPA2020.html#3582" class="Bound">x</a> <a id="3616" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="3618" href="Agda.Builtin.Sigma.html#234" class="Field">fst</a> <a id="3622" href="Cubical.Talks.EPA2020.html#3570" class="Bound">e</a> <a id="3624" href="Cubical.Talks.EPA2020.html#3582" class="Bound">x</a>
<a id="3626" href="Cubical.Talks.EPA2020.html#3549" class="Function">uaβ&#39;</a> <a id="3631" href="Cubical.Talks.EPA2020.html#3631" class="Bound">e</a> <a id="3633" href="Cubical.Talks.EPA2020.html#3633" class="Bound">x</a> <a id="3635" class="Symbol">=</a> <a id="3637" href="Cubical.Foundations.Prelude.html#8847" class="Function">transportRefl</a> <a id="3651" class="Symbol">(</a><a id="3652" href="Agda.Builtin.Cubical.Glue.html#1097" class="Function">equivFun</a> <a id="3661" href="Cubical.Talks.EPA2020.html#3631" class="Bound">e</a> <a id="3663" href="Cubical.Talks.EPA2020.html#3633" class="Bound">x</a><a id="3664" class="Symbol">)</a>



<a id="3669" class="Comment">-- Time for an example!</a>

<a id="3694" class="Comment">-- Booleans</a>
<a id="3706" class="Keyword">data</a> <a id="Bool"></a><a id="3711" href="Cubical.Talks.EPA2020.html#3711" class="Datatype">Bool</a> <a id="3716" class="Symbol">:</a> <a id="3718" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="3723" class="Keyword">where</a>
  <a id="Bool.false"></a><a id="3731" href="Cubical.Talks.EPA2020.html#3731" class="InductiveConstructor">false</a> <a id="Bool.true"></a><a id="3737" href="Cubical.Talks.EPA2020.html#3737" class="InductiveConstructor">true</a> <a id="3742" class="Symbol">:</a> <a id="3744" href="Cubical.Talks.EPA2020.html#3711" class="Datatype">Bool</a>

<a id="not"></a><a id="3750" href="Cubical.Talks.EPA2020.html#3750" class="Function">not</a> <a id="3754" class="Symbol">:</a> <a id="3756" href="Cubical.Talks.EPA2020.html#3711" class="Datatype">Bool</a> <a id="3761" class="Symbol">→</a> <a id="3763" href="Cubical.Talks.EPA2020.html#3711" class="Datatype">Bool</a>
<a id="3768" href="Cubical.Talks.EPA2020.html#3750" class="Function">not</a> <a id="3772" href="Cubical.Talks.EPA2020.html#3731" class="InductiveConstructor">false</a> <a id="3778" class="Symbol">=</a> <a id="3780" href="Cubical.Talks.EPA2020.html#3737" class="InductiveConstructor">true</a>
<a id="3785" href="Cubical.Talks.EPA2020.html#3750" class="Function">not</a> <a id="3789" href="Cubical.Talks.EPA2020.html#3737" class="InductiveConstructor">true</a>  <a id="3795" class="Symbol">=</a> <a id="3797" href="Cubical.Talks.EPA2020.html#3731" class="InductiveConstructor">false</a>

<a id="notPath"></a><a id="3804" href="Cubical.Talks.EPA2020.html#3804" class="Function">notPath</a> <a id="3812" class="Symbol">:</a> <a id="3814" href="Cubical.Talks.EPA2020.html#3711" class="Datatype">Bool</a> <a id="3819" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="3821" href="Cubical.Talks.EPA2020.html#3711" class="Datatype">Bool</a>
<a id="3826" href="Cubical.Talks.EPA2020.html#3804" class="Function">notPath</a> <a id="3834" class="Symbol">=</a> <a id="3836" href="Cubical.Talks.EPA2020.html#3345" class="Function">isoToPath&#39;</a> <a id="3847" class="Symbol">(</a><a id="3848" href="Cubical.Foundations.Isomorphism.html#869" class="InductiveConstructor">iso</a> <a id="3852" href="Cubical.Talks.EPA2020.html#3750" class="Function">not</a> <a id="3856" href="Cubical.Talks.EPA2020.html#3750" class="Function">not</a> <a id="3860" href="Cubical.Talks.EPA2020.html#3879" class="Function">rem</a> <a id="3864" href="Cubical.Talks.EPA2020.html#3879" class="Function">rem</a><a id="3867" class="Symbol">)</a>
  <a id="3871" class="Keyword">where</a>
  <a id="3879" href="Cubical.Talks.EPA2020.html#3879" class="Function">rem</a> <a id="3883" class="Symbol">:</a> <a id="3885" class="Symbol">(</a><a id="3886" href="Cubical.Talks.EPA2020.html#3886" class="Bound">b</a> <a id="3888" class="Symbol">:</a> <a id="3890" href="Cubical.Talks.EPA2020.html#3711" class="Datatype">Bool</a><a id="3894" class="Symbol">)</a> <a id="3896" class="Symbol">→</a> <a id="3898" href="Cubical.Talks.EPA2020.html#3750" class="Function">not</a> <a id="3902" class="Symbol">(</a><a id="3903" href="Cubical.Talks.EPA2020.html#3750" class="Function">not</a> <a id="3907" href="Cubical.Talks.EPA2020.html#3886" class="Bound">b</a><a id="3908" class="Symbol">)</a> <a id="3910" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="3912" href="Cubical.Talks.EPA2020.html#3886" class="Bound">b</a>
  <a id="3916" href="Cubical.Talks.EPA2020.html#3879" class="Function">rem</a> <a id="3920" href="Cubical.Talks.EPA2020.html#3731" class="InductiveConstructor">false</a> <a id="3926" class="Symbol">=</a> <a id="3928" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a>
  <a id="3935" href="Cubical.Talks.EPA2020.html#3879" class="Function">rem</a> <a id="3939" href="Cubical.Talks.EPA2020.html#3737" class="InductiveConstructor">true</a>  <a id="3945" class="Symbol">=</a> <a id="3947" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a>

<a id="3953" href="Cubical.Talks.EPA2020.html#3953" class="Function">_</a> <a id="3955" class="Symbol">:</a> <a id="3957" href="Cubical.Foundations.Prelude.html#8626" class="Function">transport</a> <a id="3967" href="Cubical.Talks.EPA2020.html#3804" class="Function">notPath</a> <a id="3975" href="Cubical.Talks.EPA2020.html#3737" class="InductiveConstructor">true</a> <a id="3980" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="3982" href="Cubical.Talks.EPA2020.html#3731" class="InductiveConstructor">false</a>
<a id="3988" class="Symbol">_</a> <a id="3990" class="Symbol">=</a> <a id="3992" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a>


<a id="3999" class="Comment">-- Another example, integers:</a>

<a id="sucPath"></a><a id="4030" href="Cubical.Talks.EPA2020.html#4030" class="Function">sucPath</a> <a id="4038" class="Symbol">:</a> <a id="4040" href="Cubical.Data.Int.Base.html#393" class="Datatype">ℤ</a> <a id="4042" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="4044" href="Cubical.Data.Int.Base.html#393" class="Datatype">ℤ</a>
<a id="4046" href="Cubical.Talks.EPA2020.html#4030" class="Function">sucPath</a> <a id="4054" class="Symbol">=</a> <a id="4056" href="Cubical.Talks.EPA2020.html#3345" class="Function">isoToPath&#39;</a> <a id="4067" class="Symbol">(</a><a id="4068" href="Cubical.Foundations.Isomorphism.html#869" class="InductiveConstructor">iso</a> <a id="4072" href="Cubical.Data.Int.Base.html#521" class="Function">sucℤ</a> <a id="4077" href="Cubical.Data.Int.Base.html#637" class="Function">predℤ</a> <a id="4083" href="Cubical.Data.Int.Properties.html#618" class="Function">sucPred</a> <a id="4091" href="Cubical.Data.Int.Properties.html#741" class="Function">predSuc</a><a id="4098" class="Symbol">)</a>

<a id="4101" href="Cubical.Talks.EPA2020.html#4101" class="Function">_</a> <a id="4103" class="Symbol">:</a> <a id="4105" href="Cubical.Foundations.Prelude.html#8626" class="Function">transport</a> <a id="4115" href="Cubical.Talks.EPA2020.html#4030" class="Function">sucPath</a> <a id="4123" class="Symbol">(</a><a id="4124" href="Cubical.Data.Int.Base.html#411" class="InductiveConstructor">pos</a> <a id="4128" class="Number">0</a><a id="4129" class="Symbol">)</a> <a id="4131" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="4133" href="Cubical.Data.Int.Base.html#411" class="InductiveConstructor">pos</a> <a id="4137" class="Number">1</a>
<a id="4139" class="Symbol">_</a> <a id="4141" class="Symbol">=</a> <a id="4143" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a>

<a id="4149" href="Cubical.Talks.EPA2020.html#4149" class="Function">_</a> <a id="4151" class="Symbol">:</a> <a id="4153" href="Cubical.Foundations.Prelude.html#8626" class="Function">transport</a> <a id="4163" class="Symbol">(</a><a id="4164" href="Cubical.Talks.EPA2020.html#4030" class="Function">sucPath</a> <a id="4172" href="Cubical.Foundations.Prelude.html#4447" class="Function Operator">∙</a> <a id="4174" href="Cubical.Talks.EPA2020.html#4030" class="Function">sucPath</a><a id="4181" class="Symbol">)</a> <a id="4183" class="Symbol">(</a><a id="4184" href="Cubical.Data.Int.Base.html#411" class="InductiveConstructor">pos</a> <a id="4188" class="Number">0</a><a id="4189" class="Symbol">)</a> <a id="4191" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="4193" href="Cubical.Data.Int.Base.html#411" class="InductiveConstructor">pos</a> <a id="4197" class="Number">2</a>
<a id="4199" class="Symbol">_</a> <a id="4201" class="Symbol">=</a> <a id="4203" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a>

<a id="4209" href="Cubical.Talks.EPA2020.html#4209" class="Function">_</a> <a id="4211" class="Symbol">:</a> <a id="4213" href="Cubical.Foundations.Prelude.html#8626" class="Function">transport</a> <a id="4223" class="Symbol">(</a><a id="4224" href="Cubical.Foundations.Prelude.html#968" class="Function">sym</a> <a id="4228" href="Cubical.Talks.EPA2020.html#4030" class="Function">sucPath</a><a id="4235" class="Symbol">)</a> <a id="4237" class="Symbol">(</a><a id="4238" href="Cubical.Data.Int.Base.html#411" class="InductiveConstructor">pos</a> <a id="4242" class="Number">0</a><a id="4243" class="Symbol">)</a> <a id="4245" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="4247" href="Cubical.Data.Int.Base.html#434" class="InductiveConstructor">negsuc</a> <a id="4254" class="Number">0</a>
<a id="4256" class="Symbol">_</a> <a id="4258" class="Symbol">=</a> <a id="4260" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a>



<a id="4268" class="Comment">-----------------------------------------------------------------------------</a>
<a id="4346" class="Comment">-- Higher inductive types</a>

<a id="4373" class="Comment">-- The following definition of finite multisets is due to Vikraman</a>
<a id="4440" class="Comment">-- Choudhury and Marcelo Fiore.</a>

<a id="4473" class="Keyword">infixr</a> <a id="4480" class="Number">5</a> <a id="4482" href="Cubical.Talks.EPA2020.html#4539" class="InductiveConstructor Operator">_∷_</a>

<a id="4487" class="Keyword">data</a> <a id="FMSet"></a><a id="4492" href="Cubical.Talks.EPA2020.html#4492" class="Datatype">FMSet</a> <a id="4498" class="Symbol">(</a><a id="4499" href="Cubical.Talks.EPA2020.html#4499" class="Bound">A</a> <a id="4501" class="Symbol">:</a> <a id="4503" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="4507" class="Symbol">)</a> <a id="4509" class="Symbol">:</a> <a id="4511" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="4516" class="Keyword">where</a>
  <a id="FMSet.[]"></a><a id="4524" href="Cubical.Talks.EPA2020.html#4524" class="InductiveConstructor">[]</a> <a id="4527" class="Symbol">:</a> <a id="4529" href="Cubical.Talks.EPA2020.html#4492" class="Datatype">FMSet</a> <a id="4535" href="Cubical.Talks.EPA2020.html#4499" class="Bound">A</a>
  <a id="FMSet._∷_"></a><a id="4539" href="Cubical.Talks.EPA2020.html#4539" class="InductiveConstructor Operator">_∷_</a> <a id="4543" class="Symbol">:</a> <a id="4545" class="Symbol">(</a><a id="4546" href="Cubical.Talks.EPA2020.html#4546" class="Bound">x</a> <a id="4548" class="Symbol">:</a> <a id="4550" href="Cubical.Talks.EPA2020.html#4499" class="Bound">A</a><a id="4551" class="Symbol">)</a> <a id="4553" class="Symbol">→</a> <a id="4555" class="Symbol">(</a><a id="4556" href="Cubical.Talks.EPA2020.html#4556" class="Bound">xs</a> <a id="4559" class="Symbol">:</a> <a id="4561" href="Cubical.Talks.EPA2020.html#4492" class="Datatype">FMSet</a> <a id="4567" href="Cubical.Talks.EPA2020.html#4499" class="Bound">A</a><a id="4568" class="Symbol">)</a> <a id="4570" class="Symbol">→</a> <a id="4572" href="Cubical.Talks.EPA2020.html#4492" class="Datatype">FMSet</a> <a id="4578" href="Cubical.Talks.EPA2020.html#4499" class="Bound">A</a>
  <a id="FMSet.comm"></a><a id="4582" href="Cubical.Talks.EPA2020.html#4582" class="InductiveConstructor">comm</a> <a id="4587" class="Symbol">:</a> <a id="4589" class="Symbol">(</a><a id="4590" href="Cubical.Talks.EPA2020.html#4590" class="Bound">x</a> <a id="4592" href="Cubical.Talks.EPA2020.html#4592" class="Bound">y</a> <a id="4594" class="Symbol">:</a> <a id="4596" href="Cubical.Talks.EPA2020.html#4499" class="Bound">A</a><a id="4597" class="Symbol">)</a> <a id="4599" class="Symbol">(</a><a id="4600" href="Cubical.Talks.EPA2020.html#4600" class="Bound">xs</a> <a id="4603" class="Symbol">:</a> <a id="4605" href="Cubical.Talks.EPA2020.html#4492" class="Datatype">FMSet</a> <a id="4611" href="Cubical.Talks.EPA2020.html#4499" class="Bound">A</a><a id="4612" class="Symbol">)</a> <a id="4614" class="Symbol">→</a> <a id="4616" href="Cubical.Talks.EPA2020.html#4590" class="Bound">x</a> <a id="4618" href="Cubical.Talks.EPA2020.html#4539" class="InductiveConstructor Operator">∷</a> <a id="4620" href="Cubical.Talks.EPA2020.html#4592" class="Bound">y</a> <a id="4622" href="Cubical.Talks.EPA2020.html#4539" class="InductiveConstructor Operator">∷</a> <a id="4624" href="Cubical.Talks.EPA2020.html#4600" class="Bound">xs</a> <a id="4627" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="4629" href="Cubical.Talks.EPA2020.html#4592" class="Bound">y</a> <a id="4631" href="Cubical.Talks.EPA2020.html#4539" class="InductiveConstructor Operator">∷</a> <a id="4633" href="Cubical.Talks.EPA2020.html#4590" class="Bound">x</a> <a id="4635" href="Cubical.Talks.EPA2020.html#4539" class="InductiveConstructor Operator">∷</a> <a id="4637" href="Cubical.Talks.EPA2020.html#4600" class="Bound">xs</a>
<a id="4640" class="Comment">--  trunc : (xs ys : FMSet A) (p q : xs ≡ ys) → p ≡ q</a>

<a id="4695" class="Comment">-- We need to add the trunc constructor for FMSets to be sets, omitted</a>
<a id="4766" class="Comment">-- here for simplicity.</a>

<a id="_++_"></a><a id="4791" href="Cubical.Talks.EPA2020.html#4791" class="Function Operator">_++_</a> <a id="4796" class="Symbol">:</a> <a id="4798" class="Symbol">∀</a> <a id="4800" class="Symbol">{</a><a id="4801" href="Cubical.Talks.EPA2020.html#4801" class="Bound">A</a> <a id="4803" class="Symbol">:</a> <a id="4805" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="4809" class="Symbol">}</a> <a id="4811" class="Symbol">(</a><a id="4812" href="Cubical.Talks.EPA2020.html#4812" class="Bound">xs</a> <a id="4815" href="Cubical.Talks.EPA2020.html#4815" class="Bound">ys</a> <a id="4818" class="Symbol">:</a> <a id="4820" href="Cubical.Talks.EPA2020.html#4492" class="Datatype">FMSet</a> <a id="4826" href="Cubical.Talks.EPA2020.html#4801" class="Bound">A</a><a id="4827" class="Symbol">)</a> <a id="4829" class="Symbol">→</a> <a id="4831" href="Cubical.Talks.EPA2020.html#4492" class="Datatype">FMSet</a> <a id="4837" href="Cubical.Talks.EPA2020.html#4801" class="Bound">A</a>
<a id="4839" href="Cubical.Talks.EPA2020.html#4524" class="InductiveConstructor">[]</a> <a id="4842" href="Cubical.Talks.EPA2020.html#4791" class="Function Operator">++</a> <a id="4845" href="Cubical.Talks.EPA2020.html#4845" class="Bound">ys</a> <a id="4848" class="Symbol">=</a> <a id="4850" href="Cubical.Talks.EPA2020.html#4845" class="Bound">ys</a>
<a id="4853" class="Symbol">(</a><a id="4854" href="Cubical.Talks.EPA2020.html#4854" class="Bound">x</a> <a id="4856" href="Cubical.Talks.EPA2020.html#4539" class="InductiveConstructor Operator">∷</a> <a id="4858" href="Cubical.Talks.EPA2020.html#4858" class="Bound">xs</a><a id="4860" class="Symbol">)</a> <a id="4862" href="Cubical.Talks.EPA2020.html#4791" class="Function Operator">++</a> <a id="4865" href="Cubical.Talks.EPA2020.html#4865" class="Bound">ys</a> <a id="4868" class="Symbol">=</a> <a id="4870" href="Cubical.Talks.EPA2020.html#4854" class="Bound">x</a> <a id="4872" href="Cubical.Talks.EPA2020.html#4539" class="InductiveConstructor Operator">∷</a> <a id="4874" href="Cubical.Talks.EPA2020.html#4858" class="Bound">xs</a> <a id="4877" href="Cubical.Talks.EPA2020.html#4791" class="Function Operator">++</a> <a id="4880" href="Cubical.Talks.EPA2020.html#4865" class="Bound">ys</a>
<a id="4883" href="Cubical.Talks.EPA2020.html#4582" class="InductiveConstructor">comm</a> <a id="4888" href="Cubical.Talks.EPA2020.html#4888" class="Bound">x</a> <a id="4890" href="Cubical.Talks.EPA2020.html#4890" class="Bound">y</a> <a id="4892" href="Cubical.Talks.EPA2020.html#4892" class="Bound">xs</a> <a id="4895" href="Cubical.Talks.EPA2020.html#4895" class="Bound">i</a> <a id="4897" href="Cubical.Talks.EPA2020.html#4791" class="Function Operator">++</a> <a id="4900" href="Cubical.Talks.EPA2020.html#4900" class="Bound">ys</a> <a id="4903" class="Symbol">=</a> <a id="4905" href="Cubical.Talks.EPA2020.html#4582" class="InductiveConstructor">comm</a> <a id="4910" href="Cubical.Talks.EPA2020.html#4888" class="Bound">x</a> <a id="4912" href="Cubical.Talks.EPA2020.html#4890" class="Bound">y</a> <a id="4914" class="Symbol">(</a><a id="4915" href="Cubical.Talks.EPA2020.html#4892" class="Bound">xs</a> <a id="4918" href="Cubical.Talks.EPA2020.html#4791" class="Function Operator">++</a> <a id="4921" href="Cubical.Talks.EPA2020.html#4900" class="Bound">ys</a><a id="4923" class="Symbol">)</a> <a id="4925" href="Cubical.Talks.EPA2020.html#4895" class="Bound">i</a>
<a id="4927" class="Comment">-- trunc xs zs p q i j ++ ys =</a>
<a id="4958" class="Comment">--   trunc (xs ++ ys) (zs ++ ys) (cong (_++ ys) p) (cong (_++ ys) q) i j</a>

<a id="unitr-++"></a><a id="5032" href="Cubical.Talks.EPA2020.html#5032" class="Function">unitr-++</a> <a id="5041" class="Symbol">:</a> <a id="5043" class="Symbol">{</a><a id="5044" href="Cubical.Talks.EPA2020.html#5044" class="Bound">A</a> <a id="5046" class="Symbol">:</a> <a id="5048" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="5052" class="Symbol">}</a> <a id="5054" class="Symbol">(</a><a id="5055" href="Cubical.Talks.EPA2020.html#5055" class="Bound">xs</a> <a id="5058" class="Symbol">:</a> <a id="5060" href="Cubical.Talks.EPA2020.html#4492" class="Datatype">FMSet</a> <a id="5066" href="Cubical.Talks.EPA2020.html#5044" class="Bound">A</a><a id="5067" class="Symbol">)</a> <a id="5069" class="Symbol">→</a> <a id="5071" href="Cubical.Talks.EPA2020.html#5055" class="Bound">xs</a> <a id="5074" href="Cubical.Talks.EPA2020.html#4791" class="Function Operator">++</a> <a id="5077" href="Cubical.Talks.EPA2020.html#4524" class="InductiveConstructor">[]</a> <a id="5080" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="5082" href="Cubical.Talks.EPA2020.html#5055" class="Bound">xs</a>
<a id="5085" href="Cubical.Talks.EPA2020.html#5032" class="Function">unitr-++</a> <a id="5094" href="Cubical.Talks.EPA2020.html#4524" class="InductiveConstructor">[]</a> <a id="5097" class="Symbol">=</a> <a id="5099" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a>
<a id="5104" href="Cubical.Talks.EPA2020.html#5032" class="Function">unitr-++</a> <a id="5113" class="Symbol">(</a><a id="5114" href="Cubical.Talks.EPA2020.html#5114" class="Bound">x</a> <a id="5116" href="Cubical.Talks.EPA2020.html#4539" class="InductiveConstructor Operator">∷</a> <a id="5118" href="Cubical.Talks.EPA2020.html#5118" class="Bound">xs</a><a id="5120" class="Symbol">)</a> <a id="5122" class="Symbol">=</a> <a id="5124" href="Cubical.Foundations.Prelude.html#1430" class="Function">cong</a> <a id="5129" class="Symbol">(</a><a id="5130" href="Cubical.Talks.EPA2020.html#5114" class="Bound">x</a> <a id="5132" href="Cubical.Talks.EPA2020.html#4539" class="InductiveConstructor Operator">∷_</a><a id="5134" class="Symbol">)</a> <a id="5136" class="Symbol">(</a><a id="5137" href="Cubical.Talks.EPA2020.html#5032" class="Function">unitr-++</a> <a id="5146" href="Cubical.Talks.EPA2020.html#5118" class="Bound">xs</a><a id="5148" class="Symbol">)</a>
<a id="5150" href="Cubical.Talks.EPA2020.html#5032" class="Function">unitr-++</a> <a id="5159" class="Symbol">(</a><a id="5160" href="Cubical.Talks.EPA2020.html#4582" class="InductiveConstructor">comm</a> <a id="5165" href="Cubical.Talks.EPA2020.html#5165" class="Bound">x</a> <a id="5167" href="Cubical.Talks.EPA2020.html#5167" class="Bound">y</a> <a id="5169" href="Cubical.Talks.EPA2020.html#5169" class="Bound">xs</a> <a id="5172" href="Cubical.Talks.EPA2020.html#5172" class="Bound">i</a><a id="5173" class="Symbol">)</a> <a id="5175" href="Cubical.Talks.EPA2020.html#5175" class="Bound">j</a> <a id="5177" class="Symbol">=</a> <a id="5179" href="Cubical.Talks.EPA2020.html#4582" class="InductiveConstructor">comm</a> <a id="5184" href="Cubical.Talks.EPA2020.html#5165" class="Bound">x</a> <a id="5186" href="Cubical.Talks.EPA2020.html#5167" class="Bound">y</a> <a id="5188" class="Symbol">(</a><a id="5189" href="Cubical.Talks.EPA2020.html#5032" class="Function">unitr-++</a> <a id="5198" href="Cubical.Talks.EPA2020.html#5169" class="Bound">xs</a> <a id="5201" href="Cubical.Talks.EPA2020.html#5175" class="Bound">j</a><a id="5202" class="Symbol">)</a> <a id="5204" href="Cubical.Talks.EPA2020.html#5172" class="Bound">i</a>
<a id="5206" class="Comment">-- unitr-++ (trunc xs ys x y i j) = {!!}</a>


<a id="5249" class="Comment">-- This is a special case of set quotients! Very useful for</a>
<a id="5309" class="Comment">-- programming and set level mathematics</a>

<a id="5351" class="Keyword">data</a> <a id="_/_"></a><a id="5356" href="Cubical.Talks.EPA2020.html#5356" class="Datatype Operator">_/_</a> <a id="5360" class="Symbol">(</a><a id="5361" href="Cubical.Talks.EPA2020.html#5361" class="Bound">A</a> <a id="5363" class="Symbol">:</a> <a id="5365" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="5369" class="Symbol">)</a> <a id="5371" class="Symbol">(</a><a id="5372" href="Cubical.Talks.EPA2020.html#5372" class="Bound">R</a> <a id="5374" class="Symbol">:</a> <a id="5376" href="Cubical.Talks.EPA2020.html#5361" class="Bound">A</a> <a id="5378" class="Symbol">→</a> <a id="5380" href="Cubical.Talks.EPA2020.html#5361" class="Bound">A</a> <a id="5382" class="Symbol">→</a> <a id="5384" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="5388" class="Symbol">)</a> <a id="5390" class="Symbol">:</a> <a id="5392" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="5397" class="Keyword">where</a>
  <a id="_/_.[_]"></a><a id="5405" href="Cubical.Talks.EPA2020.html#5405" class="InductiveConstructor Operator">[_]</a> <a id="5409" class="Symbol">:</a> <a id="5411" href="Cubical.Talks.EPA2020.html#5361" class="Bound">A</a> <a id="5413" class="Symbol">→</a> <a id="5415" href="Cubical.Talks.EPA2020.html#5361" class="Bound">A</a> <a id="5417" href="Cubical.Talks.EPA2020.html#5356" class="Datatype Operator">/</a> <a id="5419" href="Cubical.Talks.EPA2020.html#5372" class="Bound">R</a>
  <a id="_/_.eq/"></a><a id="5423" href="Cubical.Talks.EPA2020.html#5423" class="InductiveConstructor">eq/</a> <a id="5427" class="Symbol">:</a> <a id="5429" class="Symbol">(</a><a id="5430" href="Cubical.Talks.EPA2020.html#5430" class="Bound">a</a> <a id="5432" href="Cubical.Talks.EPA2020.html#5432" class="Bound">b</a> <a id="5434" class="Symbol">:</a> <a id="5436" href="Cubical.Talks.EPA2020.html#5361" class="Bound">A</a><a id="5437" class="Symbol">)</a> <a id="5439" class="Symbol">→</a> <a id="5441" href="Cubical.Talks.EPA2020.html#5372" class="Bound">R</a> <a id="5443" href="Cubical.Talks.EPA2020.html#5430" class="Bound">a</a> <a id="5445" href="Cubical.Talks.EPA2020.html#5432" class="Bound">b</a> <a id="5447" class="Symbol">→</a> <a id="5449" href="Cubical.Talks.EPA2020.html#5405" class="InductiveConstructor Operator">[</a> <a id="5451" href="Cubical.Talks.EPA2020.html#5430" class="Bound">a</a> <a id="5453" href="Cubical.Talks.EPA2020.html#5405" class="InductiveConstructor Operator">]</a> <a id="5455" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="5457" href="Cubical.Talks.EPA2020.html#5405" class="InductiveConstructor Operator">[</a> <a id="5459" href="Cubical.Talks.EPA2020.html#5432" class="Bound">b</a> <a id="5461" href="Cubical.Talks.EPA2020.html#5405" class="InductiveConstructor Operator">]</a>
  <a id="_/_.trunc"></a><a id="5465" href="Cubical.Talks.EPA2020.html#5465" class="InductiveConstructor">trunc</a> <a id="5471" class="Symbol">:</a> <a id="5473" class="Symbol">(</a><a id="5474" href="Cubical.Talks.EPA2020.html#5474" class="Bound">a</a> <a id="5476" href="Cubical.Talks.EPA2020.html#5476" class="Bound">b</a> <a id="5478" class="Symbol">:</a> <a id="5480" href="Cubical.Talks.EPA2020.html#5361" class="Bound">A</a> <a id="5482" href="Cubical.Talks.EPA2020.html#5356" class="Datatype Operator">/</a> <a id="5484" href="Cubical.Talks.EPA2020.html#5372" class="Bound">R</a><a id="5485" class="Symbol">)</a> <a id="5487" class="Symbol">(</a><a id="5488" href="Cubical.Talks.EPA2020.html#5488" class="Bound">p</a> <a id="5490" href="Cubical.Talks.EPA2020.html#5490" class="Bound">q</a> <a id="5492" class="Symbol">:</a> <a id="5494" href="Cubical.Talks.EPA2020.html#5474" class="Bound">a</a> <a id="5496" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="5498" href="Cubical.Talks.EPA2020.html#5476" class="Bound">b</a><a id="5499" class="Symbol">)</a> <a id="5501" class="Symbol">→</a> <a id="5503" href="Cubical.Talks.EPA2020.html#5488" class="Bound">p</a> <a id="5505" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="5507" href="Cubical.Talks.EPA2020.html#5490" class="Bound">q</a>

<a id="5510" class="Comment">-- Proving that they are effective ((a b : A) → [ a ] ≡ [ b ] → R a b)</a>
<a id="5581" class="Comment">-- requires univalence for propositions.</a>


<a id="5624" class="Comment">-------------------------------------------------------------------------</a>
<a id="5698" class="Comment">-- Topological examples of things that are not sets</a>

<a id="5751" class="Comment">-- We can define the circle as the following simple data declaration:</a>
<a id="5821" class="Keyword">data</a> <a id="S¹"></a><a id="5826" href="Cubical.Talks.EPA2020.html#5826" class="Datatype">S¹</a> <a id="5829" class="Symbol">:</a> <a id="5831" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="5836" class="Keyword">where</a>
  <a id="S¹.base"></a><a id="5844" href="Cubical.Talks.EPA2020.html#5844" class="InductiveConstructor">base</a> <a id="5849" class="Symbol">:</a> <a id="5851" href="Cubical.Talks.EPA2020.html#5826" class="Datatype">S¹</a>
  <a id="S¹.loop"></a><a id="5856" href="Cubical.Talks.EPA2020.html#5856" class="InductiveConstructor">loop</a> <a id="5861" class="Symbol">:</a> <a id="5863" href="Cubical.Talks.EPA2020.html#5844" class="InductiveConstructor">base</a> <a id="5868" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="5870" href="Cubical.Talks.EPA2020.html#5844" class="InductiveConstructor">base</a>

<a id="5876" class="Comment">-- We can write functions on S¹ using pattern-matching equations:</a>
<a id="double"></a><a id="5942" href="Cubical.Talks.EPA2020.html#5942" class="Function">double</a> <a id="5949" class="Symbol">:</a> <a id="5951" href="Cubical.Talks.EPA2020.html#5826" class="Datatype">S¹</a> <a id="5954" class="Symbol">→</a> <a id="5956" href="Cubical.Talks.EPA2020.html#5826" class="Datatype">S¹</a>
<a id="5959" href="Cubical.Talks.EPA2020.html#5942" class="Function">double</a> <a id="5966" href="Cubical.Talks.EPA2020.html#5844" class="InductiveConstructor">base</a> <a id="5971" class="Symbol">=</a> <a id="5973" href="Cubical.Talks.EPA2020.html#5844" class="InductiveConstructor">base</a>
<a id="5978" href="Cubical.Talks.EPA2020.html#5942" class="Function">double</a> <a id="5985" class="Symbol">(</a><a id="5986" href="Cubical.Talks.EPA2020.html#5856" class="InductiveConstructor">loop</a> <a id="5991" href="Cubical.Talks.EPA2020.html#5991" class="Bound">i</a><a id="5992" class="Symbol">)</a> <a id="5994" class="Symbol">=</a> <a id="5996" class="Symbol">(</a><a id="5997" href="Cubical.Talks.EPA2020.html#5856" class="InductiveConstructor">loop</a> <a id="6002" href="Cubical.Foundations.Prelude.html#4447" class="Function Operator">∙</a> <a id="6004" href="Cubical.Talks.EPA2020.html#5856" class="InductiveConstructor">loop</a><a id="6008" class="Symbol">)</a> <a id="6010" href="Cubical.Talks.EPA2020.html#5991" class="Bound">i</a>

<a id="helix"></a><a id="6013" href="Cubical.Talks.EPA2020.html#6013" class="Function">helix</a> <a id="6019" class="Symbol">:</a> <a id="6021" href="Cubical.Talks.EPA2020.html#5826" class="Datatype">S¹</a> <a id="6024" class="Symbol">→</a> <a id="6026" href="Agda.Primitive.html#320" class="Primitive">Type</a>
<a id="6031" href="Cubical.Talks.EPA2020.html#6013" class="Function">helix</a> <a id="6037" href="Cubical.Talks.EPA2020.html#5844" class="InductiveConstructor">base</a>     <a id="6046" class="Symbol">=</a> <a id="6048" href="Cubical.Data.Int.Base.html#393" class="Datatype">ℤ</a>
<a id="6050" href="Cubical.Talks.EPA2020.html#6013" class="Function">helix</a> <a id="6056" class="Symbol">(</a><a id="6057" href="Cubical.Talks.EPA2020.html#5856" class="InductiveConstructor">loop</a> <a id="6062" href="Cubical.Talks.EPA2020.html#6062" class="Bound">i</a><a id="6063" class="Symbol">)</a> <a id="6065" class="Symbol">=</a> <a id="6067" href="Cubical.Data.Int.Properties.html#6236" class="Function">sucPathℤ</a> <a id="6076" href="Cubical.Talks.EPA2020.html#6062" class="Bound">i</a>

<a id="ΩS¹"></a><a id="6079" href="Cubical.Talks.EPA2020.html#6079" class="Function">ΩS¹</a> <a id="6083" class="Symbol">:</a> <a id="6085" href="Agda.Primitive.html#320" class="Primitive">Type</a>
<a id="6090" href="Cubical.Talks.EPA2020.html#6079" class="Function">ΩS¹</a> <a id="6094" class="Symbol">=</a> <a id="6096" href="Cubical.Talks.EPA2020.html#5844" class="InductiveConstructor">base</a> <a id="6101" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="6103" href="Cubical.Talks.EPA2020.html#5844" class="InductiveConstructor">base</a>

<a id="winding"></a><a id="6109" href="Cubical.Talks.EPA2020.html#6109" class="Function">winding</a> <a id="6117" class="Symbol">:</a> <a id="6119" href="Cubical.Talks.EPA2020.html#6079" class="Function">ΩS¹</a> <a id="6123" class="Symbol">→</a> <a id="6125" href="Cubical.Data.Int.Base.html#393" class="Datatype">ℤ</a>
<a id="6127" href="Cubical.Talks.EPA2020.html#6109" class="Function">winding</a> <a id="6135" href="Cubical.Talks.EPA2020.html#6135" class="Bound">p</a> <a id="6137" class="Symbol">=</a> <a id="6139" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="6145" href="Cubical.Talks.EPA2020.html#6013" class="Function">helix</a> <a id="6151" href="Cubical.Talks.EPA2020.html#6135" class="Bound">p</a> <a id="6153" class="Symbol">(</a><a id="6154" href="Cubical.Data.Int.Base.html#411" class="InductiveConstructor">pos</a> <a id="6158" class="Number">0</a><a id="6159" class="Symbol">)</a>

<a id="6162" href="Cubical.Talks.EPA2020.html#6162" class="Function">_</a> <a id="6164" class="Symbol">:</a> <a id="6166" href="Cubical.Talks.EPA2020.html#6109" class="Function">winding</a> <a id="6174" class="Symbol">(λ</a> <a id="6177" href="Cubical.Talks.EPA2020.html#6177" class="Bound">i</a> <a id="6179" class="Symbol">→</a> <a id="6181" href="Cubical.Talks.EPA2020.html#5942" class="Function">double</a> <a id="6188" class="Symbol">((</a><a id="6190" href="Cubical.Talks.EPA2020.html#5856" class="InductiveConstructor">loop</a> <a id="6195" href="Cubical.Foundations.Prelude.html#4447" class="Function Operator">∙</a> <a id="6197" href="Cubical.Talks.EPA2020.html#5856" class="InductiveConstructor">loop</a><a id="6201" class="Symbol">)</a> <a id="6203" href="Cubical.Talks.EPA2020.html#6177" class="Bound">i</a><a id="6204" class="Symbol">))</a> <a id="6207" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="6209" href="Cubical.Data.Int.Base.html#411" class="InductiveConstructor">pos</a> <a id="6213" class="Number">4</a>
<a id="6215" class="Symbol">_</a> <a id="6217" class="Symbol">=</a> <a id="6219" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a>


<a id="6226" class="Comment">-- We can define the Torus as:</a>
<a id="6257" class="Keyword">data</a> <a id="Torus"></a><a id="6262" href="Cubical.Talks.EPA2020.html#6262" class="Datatype">Torus</a> <a id="6268" class="Symbol">:</a> <a id="6270" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="6275" class="Keyword">where</a>
  <a id="Torus.point"></a><a id="6283" href="Cubical.Talks.EPA2020.html#6283" class="InductiveConstructor">point</a> <a id="6289" class="Symbol">:</a> <a id="6291" href="Cubical.Talks.EPA2020.html#6262" class="Datatype">Torus</a>
  <a id="Torus.line1"></a><a id="6299" href="Cubical.Talks.EPA2020.html#6299" class="InductiveConstructor">line1</a> <a id="6305" class="Symbol">:</a> <a id="6307" href="Cubical.Talks.EPA2020.html#6283" class="InductiveConstructor">point</a> <a id="6313" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="6315" href="Cubical.Talks.EPA2020.html#6283" class="InductiveConstructor">point</a>
  <a id="Torus.line2"></a><a id="6323" href="Cubical.Talks.EPA2020.html#6323" class="InductiveConstructor">line2</a> <a id="6329" class="Symbol">:</a> <a id="6331" href="Cubical.Talks.EPA2020.html#6283" class="InductiveConstructor">point</a> <a id="6337" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="6339" href="Cubical.Talks.EPA2020.html#6283" class="InductiveConstructor">point</a>
  <a id="Torus.square"></a><a id="6347" href="Cubical.Talks.EPA2020.html#6347" class="InductiveConstructor">square</a> <a id="6354" class="Symbol">:</a> <a id="6356" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="6362" class="Symbol">(λ</a> <a id="6365" href="Cubical.Talks.EPA2020.html#6365" class="Bound">i</a> <a id="6367" class="Symbol">→</a> <a id="6369" href="Cubical.Talks.EPA2020.html#6299" class="InductiveConstructor">line1</a> <a id="6375" href="Cubical.Talks.EPA2020.html#6365" class="Bound">i</a> <a id="6377" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="6379" href="Cubical.Talks.EPA2020.html#6299" class="InductiveConstructor">line1</a> <a id="6385" href="Cubical.Talks.EPA2020.html#6365" class="Bound">i</a><a id="6386" class="Symbol">)</a> <a id="6388" href="Cubical.Talks.EPA2020.html#6323" class="InductiveConstructor">line2</a> <a id="6394" href="Cubical.Talks.EPA2020.html#6323" class="InductiveConstructor">line2</a>

<a id="6401" class="Comment">-- And prove that it is equivalent to two circle:</a>
<a id="t2c"></a><a id="6451" href="Cubical.Talks.EPA2020.html#6451" class="Function">t2c</a> <a id="6455" class="Symbol">:</a> <a id="6457" href="Cubical.Talks.EPA2020.html#6262" class="Datatype">Torus</a> <a id="6463" class="Symbol">→</a> <a id="6465" href="Cubical.Talks.EPA2020.html#5826" class="Datatype">S¹</a> <a id="6468" href="Cubical.Data.Prod.Base.html#705" class="Datatype Operator">×</a> <a id="6470" href="Cubical.Talks.EPA2020.html#5826" class="Datatype">S¹</a>
<a id="6473" href="Cubical.Talks.EPA2020.html#6451" class="Function">t2c</a> <a id="6477" href="Cubical.Talks.EPA2020.html#6283" class="InductiveConstructor">point</a>        <a id="6490" class="Symbol">=</a> <a id="6492" class="Symbol">(</a><a id="6493" href="Cubical.Talks.EPA2020.html#5844" class="InductiveConstructor">base</a> <a id="6498" href="Cubical.Data.Prod.Base.html#764" class="InductiveConstructor Operator">,</a> <a id="6500" href="Cubical.Talks.EPA2020.html#5844" class="InductiveConstructor">base</a><a id="6504" class="Symbol">)</a>
<a id="6506" href="Cubical.Talks.EPA2020.html#6451" class="Function">t2c</a> <a id="6510" class="Symbol">(</a><a id="6511" href="Cubical.Talks.EPA2020.html#6299" class="InductiveConstructor">line1</a> <a id="6517" href="Cubical.Talks.EPA2020.html#6517" class="Bound">i</a><a id="6518" class="Symbol">)</a>    <a id="6523" class="Symbol">=</a> <a id="6525" class="Symbol">(</a><a id="6526" href="Cubical.Talks.EPA2020.html#5856" class="InductiveConstructor">loop</a> <a id="6531" href="Cubical.Talks.EPA2020.html#6517" class="Bound">i</a> <a id="6533" href="Cubical.Data.Prod.Base.html#764" class="InductiveConstructor Operator">,</a> <a id="6535" href="Cubical.Talks.EPA2020.html#5844" class="InductiveConstructor">base</a><a id="6539" class="Symbol">)</a>
<a id="6541" href="Cubical.Talks.EPA2020.html#6451" class="Function">t2c</a> <a id="6545" class="Symbol">(</a><a id="6546" href="Cubical.Talks.EPA2020.html#6323" class="InductiveConstructor">line2</a> <a id="6552" href="Cubical.Talks.EPA2020.html#6552" class="Bound">j</a><a id="6553" class="Symbol">)</a>    <a id="6558" class="Symbol">=</a> <a id="6560" class="Symbol">(</a><a id="6561" href="Cubical.Talks.EPA2020.html#5844" class="InductiveConstructor">base</a> <a id="6566" href="Cubical.Data.Prod.Base.html#764" class="InductiveConstructor Operator">,</a> <a id="6568" href="Cubical.Talks.EPA2020.html#5856" class="InductiveConstructor">loop</a> <a id="6573" href="Cubical.Talks.EPA2020.html#6552" class="Bound">j</a><a id="6574" class="Symbol">)</a>
<a id="6576" href="Cubical.Talks.EPA2020.html#6451" class="Function">t2c</a> <a id="6580" class="Symbol">(</a><a id="6581" href="Cubical.Talks.EPA2020.html#6347" class="InductiveConstructor">square</a> <a id="6588" href="Cubical.Talks.EPA2020.html#6588" class="Bound">i</a> <a id="6590" href="Cubical.Talks.EPA2020.html#6590" class="Bound">j</a><a id="6591" class="Symbol">)</a> <a id="6593" class="Symbol">=</a> <a id="6595" class="Symbol">(</a><a id="6596" href="Cubical.Talks.EPA2020.html#5856" class="InductiveConstructor">loop</a> <a id="6601" href="Cubical.Talks.EPA2020.html#6588" class="Bound">i</a> <a id="6603" href="Cubical.Data.Prod.Base.html#764" class="InductiveConstructor Operator">,</a> <a id="6605" href="Cubical.Talks.EPA2020.html#5856" class="InductiveConstructor">loop</a> <a id="6610" href="Cubical.Talks.EPA2020.html#6590" class="Bound">j</a><a id="6611" class="Symbol">)</a>

<a id="c2t"></a><a id="6614" href="Cubical.Talks.EPA2020.html#6614" class="Function">c2t</a> <a id="6618" class="Symbol">:</a> <a id="6620" href="Cubical.Talks.EPA2020.html#5826" class="Datatype">S¹</a> <a id="6623" href="Cubical.Data.Prod.Base.html#705" class="Datatype Operator">×</a> <a id="6625" href="Cubical.Talks.EPA2020.html#5826" class="Datatype">S¹</a> <a id="6628" class="Symbol">→</a> <a id="6630" href="Cubical.Talks.EPA2020.html#6262" class="Datatype">Torus</a>
<a id="6636" href="Cubical.Talks.EPA2020.html#6614" class="Function">c2t</a> <a id="6640" class="Symbol">(</a><a id="6641" href="Cubical.Talks.EPA2020.html#5844" class="InductiveConstructor">base</a>   <a id="6648" href="Cubical.Data.Prod.Base.html#764" class="InductiveConstructor Operator">,</a> <a id="6650" href="Cubical.Talks.EPA2020.html#5844" class="InductiveConstructor">base</a><a id="6654" class="Symbol">)</a>   <a id="6658" class="Symbol">=</a> <a id="6660" href="Cubical.Talks.EPA2020.html#6283" class="InductiveConstructor">point</a>
<a id="6666" href="Cubical.Talks.EPA2020.html#6614" class="Function">c2t</a> <a id="6670" class="Symbol">(</a><a id="6671" href="Cubical.Talks.EPA2020.html#5856" class="InductiveConstructor">loop</a> <a id="6676" href="Cubical.Talks.EPA2020.html#6676" class="Bound">i</a> <a id="6678" href="Cubical.Data.Prod.Base.html#764" class="InductiveConstructor Operator">,</a> <a id="6680" href="Cubical.Talks.EPA2020.html#5844" class="InductiveConstructor">base</a><a id="6684" class="Symbol">)</a>   <a id="6688" class="Symbol">=</a> <a id="6690" href="Cubical.Talks.EPA2020.html#6299" class="InductiveConstructor">line1</a> <a id="6696" href="Cubical.Talks.EPA2020.html#6676" class="Bound">i</a>
<a id="6698" href="Cubical.Talks.EPA2020.html#6614" class="Function">c2t</a> <a id="6702" class="Symbol">(</a><a id="6703" href="Cubical.Talks.EPA2020.html#5844" class="InductiveConstructor">base</a>   <a id="6710" href="Cubical.Data.Prod.Base.html#764" class="InductiveConstructor Operator">,</a> <a id="6712" href="Cubical.Talks.EPA2020.html#5856" class="InductiveConstructor">loop</a> <a id="6717" href="Cubical.Talks.EPA2020.html#6717" class="Bound">j</a><a id="6718" class="Symbol">)</a> <a id="6720" class="Symbol">=</a> <a id="6722" href="Cubical.Talks.EPA2020.html#6323" class="InductiveConstructor">line2</a> <a id="6728" href="Cubical.Talks.EPA2020.html#6717" class="Bound">j</a>
<a id="6730" href="Cubical.Talks.EPA2020.html#6614" class="Function">c2t</a> <a id="6734" class="Symbol">(</a><a id="6735" href="Cubical.Talks.EPA2020.html#5856" class="InductiveConstructor">loop</a> <a id="6740" href="Cubical.Talks.EPA2020.html#6740" class="Bound">i</a> <a id="6742" href="Cubical.Data.Prod.Base.html#764" class="InductiveConstructor Operator">,</a> <a id="6744" href="Cubical.Talks.EPA2020.html#5856" class="InductiveConstructor">loop</a> <a id="6749" href="Cubical.Talks.EPA2020.html#6749" class="Bound">j</a><a id="6750" class="Symbol">)</a> <a id="6752" class="Symbol">=</a> <a id="6754" href="Cubical.Talks.EPA2020.html#6347" class="InductiveConstructor">square</a> <a id="6761" href="Cubical.Talks.EPA2020.html#6740" class="Bound">i</a> <a id="6763" href="Cubical.Talks.EPA2020.html#6749" class="Bound">j</a>

<a id="c2t-t2c"></a><a id="6766" href="Cubical.Talks.EPA2020.html#6766" class="Function">c2t-t2c</a> <a id="6774" class="Symbol">:</a> <a id="6776" class="Symbol">(</a><a id="6777" href="Cubical.Talks.EPA2020.html#6777" class="Bound">t</a> <a id="6779" class="Symbol">:</a> <a id="6781" href="Cubical.Talks.EPA2020.html#6262" class="Datatype">Torus</a><a id="6786" class="Symbol">)</a> <a id="6788" class="Symbol">→</a> <a id="6790" href="Cubical.Talks.EPA2020.html#6614" class="Function">c2t</a> <a id="6794" class="Symbol">(</a><a id="6795" href="Cubical.Talks.EPA2020.html#6451" class="Function">t2c</a> <a id="6799" href="Cubical.Talks.EPA2020.html#6777" class="Bound">t</a><a id="6800" class="Symbol">)</a> <a id="6802" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="6804" href="Cubical.Talks.EPA2020.html#6777" class="Bound">t</a>
<a id="6806" href="Cubical.Talks.EPA2020.html#6766" class="Function">c2t-t2c</a> <a id="6814" href="Cubical.Talks.EPA2020.html#6283" class="InductiveConstructor">point</a>        <a id="6827" class="Symbol">=</a> <a id="6829" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a>
<a id="6834" href="Cubical.Talks.EPA2020.html#6766" class="Function">c2t-t2c</a> <a id="6842" class="Symbol">(</a><a id="6843" href="Cubical.Talks.EPA2020.html#6299" class="InductiveConstructor">line1</a> <a id="6849" class="Symbol">_)</a>    <a id="6855" class="Symbol">=</a> <a id="6857" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a>
<a id="6862" href="Cubical.Talks.EPA2020.html#6766" class="Function">c2t-t2c</a> <a id="6870" class="Symbol">(</a><a id="6871" href="Cubical.Talks.EPA2020.html#6323" class="InductiveConstructor">line2</a> <a id="6877" class="Symbol">_)</a>    <a id="6883" class="Symbol">=</a> <a id="6885" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a>
<a id="6890" href="Cubical.Talks.EPA2020.html#6766" class="Function">c2t-t2c</a> <a id="6898" class="Symbol">(</a><a id="6899" href="Cubical.Talks.EPA2020.html#6347" class="InductiveConstructor">square</a> <a id="6906" class="Symbol">_</a> <a id="6908" class="Symbol">_)</a> <a id="6911" class="Symbol">=</a> <a id="6913" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a>

<a id="t2c-c2t"></a><a id="6919" href="Cubical.Talks.EPA2020.html#6919" class="Function">t2c-c2t</a> <a id="6927" class="Symbol">:</a> <a id="6929" class="Symbol">(</a><a id="6930" href="Cubical.Talks.EPA2020.html#6930" class="Bound">p</a> <a id="6932" class="Symbol">:</a> <a id="6934" href="Cubical.Talks.EPA2020.html#5826" class="Datatype">S¹</a> <a id="6937" href="Cubical.Data.Prod.Base.html#705" class="Datatype Operator">×</a> <a id="6939" href="Cubical.Talks.EPA2020.html#5826" class="Datatype">S¹</a><a id="6941" class="Symbol">)</a> <a id="6943" class="Symbol">→</a> <a id="6945" href="Cubical.Talks.EPA2020.html#6451" class="Function">t2c</a> <a id="6949" class="Symbol">(</a><a id="6950" href="Cubical.Talks.EPA2020.html#6614" class="Function">c2t</a> <a id="6954" href="Cubical.Talks.EPA2020.html#6930" class="Bound">p</a><a id="6955" class="Symbol">)</a> <a id="6957" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="6959" href="Cubical.Talks.EPA2020.html#6930" class="Bound">p</a>
<a id="6961" href="Cubical.Talks.EPA2020.html#6919" class="Function">t2c-c2t</a> <a id="6969" class="Symbol">(</a><a id="6970" href="Cubical.Talks.EPA2020.html#5844" class="InductiveConstructor">base</a>   <a id="6977" href="Cubical.Data.Prod.Base.html#764" class="InductiveConstructor Operator">,</a> <a id="6979" href="Cubical.Talks.EPA2020.html#5844" class="InductiveConstructor">base</a><a id="6983" class="Symbol">)</a>   <a id="6987" class="Symbol">=</a> <a id="6989" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a>
<a id="6994" href="Cubical.Talks.EPA2020.html#6919" class="Function">t2c-c2t</a> <a id="7002" class="Symbol">(</a><a id="7003" href="Cubical.Talks.EPA2020.html#5844" class="InductiveConstructor">base</a>   <a id="7010" href="Cubical.Data.Prod.Base.html#764" class="InductiveConstructor Operator">,</a> <a id="7012" href="Cubical.Talks.EPA2020.html#5856" class="InductiveConstructor">loop</a> <a id="7017" class="Symbol">_)</a> <a id="7020" class="Symbol">=</a> <a id="7022" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a>
<a id="7027" href="Cubical.Talks.EPA2020.html#6919" class="Function">t2c-c2t</a> <a id="7035" class="Symbol">(</a><a id="7036" href="Cubical.Talks.EPA2020.html#5856" class="InductiveConstructor">loop</a> <a id="7041" class="Symbol">_</a> <a id="7043" href="Cubical.Data.Prod.Base.html#764" class="InductiveConstructor Operator">,</a> <a id="7045" href="Cubical.Talks.EPA2020.html#5844" class="InductiveConstructor">base</a><a id="7049" class="Symbol">)</a>   <a id="7053" class="Symbol">=</a> <a id="7055" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a>
<a id="7060" href="Cubical.Talks.EPA2020.html#6919" class="Function">t2c-c2t</a> <a id="7068" class="Symbol">(</a><a id="7069" href="Cubical.Talks.EPA2020.html#5856" class="InductiveConstructor">loop</a> <a id="7074" class="Symbol">_</a> <a id="7076" href="Cubical.Data.Prod.Base.html#764" class="InductiveConstructor Operator">,</a> <a id="7078" href="Cubical.Talks.EPA2020.html#5856" class="InductiveConstructor">loop</a> <a id="7083" class="Symbol">_)</a> <a id="7086" class="Symbol">=</a> <a id="7088" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a>

<a id="7094" class="Comment">-- Using univalence we get the following equality:</a>
<a id="Torus≡S¹×S¹"></a><a id="7145" href="Cubical.Talks.EPA2020.html#7145" class="Function">Torus≡S¹×S¹</a> <a id="7157" class="Symbol">:</a> <a id="7159" href="Cubical.Talks.EPA2020.html#6262" class="Datatype">Torus</a> <a id="7165" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="7167" href="Cubical.Talks.EPA2020.html#5826" class="Datatype">S¹</a> <a id="7170" href="Cubical.Data.Prod.Base.html#705" class="Datatype Operator">×</a> <a id="7172" href="Cubical.Talks.EPA2020.html#5826" class="Datatype">S¹</a>
<a id="7175" href="Cubical.Talks.EPA2020.html#7145" class="Function">Torus≡S¹×S¹</a> <a id="7187" class="Symbol">=</a> <a id="7189" href="Cubical.Talks.EPA2020.html#3345" class="Function">isoToPath&#39;</a> <a id="7200" class="Symbol">(</a><a id="7201" href="Cubical.Foundations.Isomorphism.html#869" class="InductiveConstructor">iso</a> <a id="7205" href="Cubical.Talks.EPA2020.html#6451" class="Function">t2c</a> <a id="7209" href="Cubical.Talks.EPA2020.html#6614" class="Function">c2t</a> <a id="7213" href="Cubical.Talks.EPA2020.html#6919" class="Function">t2c-c2t</a> <a id="7221" href="Cubical.Talks.EPA2020.html#6766" class="Function">c2t-t2c</a><a id="7228" class="Symbol">)</a>


<a id="windingTorus"></a><a id="7232" href="Cubical.Talks.EPA2020.html#7232" class="Function">windingTorus</a> <a id="7245" class="Symbol">:</a> <a id="7247" href="Cubical.Talks.EPA2020.html#6283" class="InductiveConstructor">point</a> <a id="7253" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="7255" href="Cubical.Talks.EPA2020.html#6283" class="InductiveConstructor">point</a> <a id="7261" class="Symbol">→</a> <a id="7263" href="Cubical.Data.Int.Base.html#393" class="Datatype">ℤ</a> <a id="7265" href="Cubical.Data.Prod.Base.html#705" class="Datatype Operator">×</a> <a id="7267" href="Cubical.Data.Int.Base.html#393" class="Datatype">ℤ</a>
<a id="7269" href="Cubical.Talks.EPA2020.html#7232" class="Function">windingTorus</a> <a id="7282" href="Cubical.Talks.EPA2020.html#7282" class="Bound">l</a> <a id="7284" class="Symbol">=</a> <a id="7286" class="Symbol">(</a> <a id="7288" href="Cubical.Talks.EPA2020.html#6109" class="Function">winding</a> <a id="7296" class="Symbol">(λ</a> <a id="7299" href="Cubical.Talks.EPA2020.html#7299" class="Bound">i</a> <a id="7301" class="Symbol">→</a> <a id="7303" href="Cubical.Data.Prod.Base.html#799" class="Function">proj₁</a> <a id="7309" class="Symbol">(</a><a id="7310" href="Cubical.Talks.EPA2020.html#6451" class="Function">t2c</a> <a id="7314" class="Symbol">(</a><a id="7315" href="Cubical.Talks.EPA2020.html#7282" class="Bound">l</a> <a id="7317" href="Cubical.Talks.EPA2020.html#7299" class="Bound">i</a><a id="7318" class="Symbol">)))</a>
                 <a id="7339" href="Cubical.Data.Prod.Base.html#764" class="InductiveConstructor Operator">,</a> <a id="7341" href="Cubical.Talks.EPA2020.html#6109" class="Function">winding</a> <a id="7349" class="Symbol">(λ</a> <a id="7352" href="Cubical.Talks.EPA2020.html#7352" class="Bound">i</a> <a id="7354" class="Symbol">→</a> <a id="7356" href="Cubical.Data.Prod.Base.html#865" class="Function">proj₂</a> <a id="7362" class="Symbol">(</a><a id="7363" href="Cubical.Talks.EPA2020.html#6451" class="Function">t2c</a> <a id="7367" class="Symbol">(</a><a id="7368" href="Cubical.Talks.EPA2020.html#7282" class="Bound">l</a> <a id="7370" href="Cubical.Talks.EPA2020.html#7352" class="Bound">i</a><a id="7371" class="Symbol">))))</a>

<a id="7377" href="Cubical.Talks.EPA2020.html#7377" class="Function">_</a> <a id="7379" class="Symbol">:</a> <a id="7381" href="Cubical.Talks.EPA2020.html#7232" class="Function">windingTorus</a> <a id="7394" class="Symbol">(</a><a id="7395" href="Cubical.Talks.EPA2020.html#6299" class="InductiveConstructor">line1</a> <a id="7401" href="Cubical.Foundations.Prelude.html#4447" class="Function Operator">∙</a> <a id="7403" href="Cubical.Foundations.Prelude.html#968" class="Function">sym</a> <a id="7407" href="Cubical.Talks.EPA2020.html#6323" class="InductiveConstructor">line2</a><a id="7412" class="Symbol">)</a> <a id="7414" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="7416" class="Symbol">(</a><a id="7417" href="Cubical.Data.Int.Base.html#411" class="InductiveConstructor">pos</a> <a id="7421" class="Number">1</a> <a id="7423" class="InductiveConstructor Operator">,</a> <a id="7425" href="Cubical.Data.Int.Base.html#434" class="InductiveConstructor">negsuc</a> <a id="7432" class="Number">0</a><a id="7433" class="Symbol">)</a>
<a id="7435" class="Symbol">_</a> <a id="7437" class="Symbol">=</a> <a id="7439" href="Cubical.Foundations.Prelude.html#915" class="Function">refl</a>

<a id="7445" class="Comment">-- We have many more topological examples, including Klein bottle, RP^n,</a>
<a id="7518" class="Comment">-- higher spheres, suspensions, join, wedges, smash product:</a>
<a id="7579" class="Keyword">open</a> <a id="7584" class="Keyword">import</a> <a id="7591" href="Cubical.HITs.KleinBottle.html" class="Module">Cubical.HITs.KleinBottle</a>
<a id="7616" class="Keyword">open</a> <a id="7621" class="Keyword">import</a> <a id="7628" href="Cubical.HITs.RPn.html" class="Module">Cubical.HITs.RPn</a>
<a id="7645" class="Keyword">open</a> <a id="7650" class="Keyword">import</a> <a id="7657" href="Cubical.HITs.S2.html" class="Module">Cubical.HITs.S2</a>
<a id="7673" class="Keyword">open</a> <a id="7678" class="Keyword">import</a> <a id="7685" href="Cubical.HITs.S3.html" class="Module">Cubical.HITs.S3</a>
<a id="7701" class="Keyword">open</a> <a id="7706" class="Keyword">import</a> <a id="7713" href="Cubical.HITs.Susp.html" class="Module">Cubical.HITs.Susp</a>
<a id="7731" class="Keyword">open</a> <a id="7736" class="Keyword">import</a> <a id="7743" href="Cubical.HITs.Join.html" class="Module">Cubical.HITs.Join</a>
<a id="7761" class="Keyword">open</a> <a id="7766" class="Keyword">import</a> <a id="7773" href="Cubical.HITs.Wedge.html" class="Module">Cubical.HITs.Wedge</a>
<a id="7792" class="Keyword">open</a> <a id="7797" class="Keyword">import</a> <a id="7804" href="Cubical.HITs.SmashProduct.html" class="Module">Cubical.HITs.SmashProduct</a>

<a id="7831" class="Comment">-- There&#39;s also a proof of the &quot;3x3 lemma&quot; for pushouts in less than</a>
<a id="7900" class="Comment">-- 200LOC. In HoTT-Agda this took about 3000LOC. For details see:</a>
<a id="7966" class="Comment">-- https://github.com/HoTT/HoTT-Agda/tree/master/theorems/homotopy/3x3</a>
<a id="8037" class="Keyword">open</a> <a id="8042" class="Keyword">import</a> <a id="8049" href="Cubical.HITs.Pushout.html" class="Module">Cubical.HITs.Pushout</a>

<a id="8071" class="Comment">-- We also defined the Hopf fibration and proved that its total space</a>
<a id="8141" class="Comment">-- is S³ in about 300LOC:</a>
<a id="8167" class="Keyword">open</a> <a id="8172" class="Keyword">import</a> <a id="8179" href="Cubical.Homotopy.Hopf.html" class="Module">Cubical.Homotopy.Hopf</a>
<a id="8201" class="Keyword">open</a> <a id="8206" href="Cubical.Homotopy.Hopf.html#14739" class="Module">S¹Hopf</a>

<a id="8214" class="Comment">-- There is also some integer cohomology:</a>
<a id="8256" class="Keyword">open</a> <a id="8261" class="Keyword">import</a> <a id="8268" href="Cubical.ZCohomology.Everything.html" class="Module">Cubical.ZCohomology.Everything</a>
<a id="8299" class="Comment">-- To compute cohomology groups of various spaces we need a bunch of</a>
<a id="8368" class="Comment">-- interesting theorems: Freudenthal suspension theorem,</a>
<a id="8425" class="Comment">-- Mayer-Vietoris sequence...</a>
<a id="8455" class="Keyword">open</a> <a id="8460" class="Keyword">import</a> <a id="8467" href="Cubical.Homotopy.Freudenthal.html" class="Module">Cubical.Homotopy.Freudenthal</a>
<a id="8496" class="Keyword">open</a> <a id="8501" class="Keyword">import</a> <a id="8508" href="Cubical.ZCohomology.MayerVietorisUnreduced.html" class="Module">Cubical.ZCohomology.MayerVietorisUnreduced</a>


<a id="8553" class="Comment">-------------------------------------------------------------------------</a>
<a id="8627" class="Comment">-- The structure identity principle</a>

<a id="8664" class="Comment">-- A more efficient version of finite multisets based on association lists</a>
<a id="8739" class="Keyword">open</a> <a id="8744" class="Keyword">import</a> <a id="8751" href="Cubical.HITs.AssocList.Base.html" class="Module">Cubical.HITs.AssocList.Base</a>

<a id="8780" class="Comment">-- data AssocList (A : Type) : Type where</a>
<a id="8822" class="Comment">--  ⟨⟩ : AssocList A</a>
<a id="8843" class="Comment">--  ⟨_,_⟩∷_ : (a : A) (n : ℕ) (xs : AssocList A) → AssocList A</a>
<a id="8906" class="Comment">--  per : (a b : A) (m n : ℕ) (xs : AssocList A)</a>
<a id="8955" class="Comment">--      → ⟨ a , m ⟩∷ ⟨ b , n ⟩∷ xs ≡ ⟨ b , n ⟩∷ ⟨ a , m ⟩∷ xs</a>
<a id="9017" class="Comment">--  agg : (a : A) (m n : ℕ) (xs : AssocList A)</a>
<a id="9064" class="Comment">--      → ⟨ a , m ⟩∷ ⟨ a , n ⟩∷ xs ≡ ⟨ a , m + n ⟩∷ xs</a>
<a id="9119" class="Comment">--  del : (a : A) (xs : AssocList A) → ⟨ a , 0 ⟩∷ xs ≡ xs</a>
<a id="9177" class="Comment">--  trunc : (xs ys : AssocList A) (p q : xs ≡ ys) → p ≡ q</a>


<a id="9237" class="Comment">-- Programming and proving is more complicated with AssocList compared</a>
<a id="9308" class="Comment">-- to FMSet. This kind of example occurs everywhere in programming and</a>
<a id="9379" class="Comment">-- mathematics: one representation is easier to work with, but not</a>
<a id="9446" class="Comment">-- efficient, while another is efficient but difficult to work with.</a>

<a id="9516" class="Comment">-- Solution: substitute using univalence</a>
<a id="substIso"></a><a id="9557" href="Cubical.Talks.EPA2020.html#9557" class="Function">substIso</a> <a id="9566" class="Symbol">:</a> <a id="9568" class="Symbol">{</a><a id="9569" href="Cubical.Talks.EPA2020.html#9569" class="Bound">A</a> <a id="9571" href="Cubical.Talks.EPA2020.html#9571" class="Bound">B</a> <a id="9573" class="Symbol">:</a> <a id="9575" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="9579" class="Symbol">}</a> <a id="9581" class="Symbol">(</a><a id="9582" href="Cubical.Talks.EPA2020.html#9582" class="Bound">P</a> <a id="9584" class="Symbol">:</a> <a id="9586" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="9591" class="Symbol">→</a> <a id="9593" href="Agda.Primitive.html#320" class="Primitive">Type</a><a id="9597" class="Symbol">)</a> <a id="9599" class="Symbol">(</a><a id="9600" href="Cubical.Talks.EPA2020.html#9600" class="Bound">e</a> <a id="9602" class="Symbol">:</a> <a id="9604" href="Cubical.Foundations.Isomorphism.html#773" class="Record">Iso</a> <a id="9608" href="Cubical.Talks.EPA2020.html#9569" class="Bound">A</a> <a id="9610" href="Cubical.Talks.EPA2020.html#9571" class="Bound">B</a><a id="9611" class="Symbol">)</a> <a id="9613" class="Symbol">→</a> <a id="9615" href="Cubical.Talks.EPA2020.html#9582" class="Bound">P</a> <a id="9617" href="Cubical.Talks.EPA2020.html#9569" class="Bound">A</a> <a id="9619" class="Symbol">→</a> <a id="9621" href="Cubical.Talks.EPA2020.html#9582" class="Bound">P</a> <a id="9623" href="Cubical.Talks.EPA2020.html#9571" class="Bound">B</a>
<a id="9625" href="Cubical.Talks.EPA2020.html#9557" class="Function">substIso</a> <a id="9634" href="Cubical.Talks.EPA2020.html#9634" class="Bound">P</a> <a id="9636" href="Cubical.Talks.EPA2020.html#9636" class="Bound">e</a> <a id="9638" class="Symbol">=</a> <a id="9640" href="Cubical.Foundations.Prelude.html#9157" class="Function">subst</a> <a id="9646" href="Cubical.Talks.EPA2020.html#9634" class="Bound">P</a> <a id="9648" class="Symbol">(</a><a id="9649" href="Cubical.Foundations.Isomorphism.html#3223" class="Function">isoToPath</a> <a id="9659" href="Cubical.Talks.EPA2020.html#9636" class="Bound">e</a><a id="9660" class="Symbol">)</a>

<a id="9663" class="Comment">-- Can transport for example Monoid structure from FMSet to AssocList</a>
<a id="9733" class="Comment">-- this way, but the achieved Monoid structure is not very efficient</a>
<a id="9802" class="Comment">-- to work with. A better solution is to prove that FMSet and</a>
<a id="9864" class="Comment">-- AssocList are equal *as monoids*, but how to do this?</a>

<a id="9922" class="Comment">-- Solution: structure identity principle (SIP)</a>
<a id="9970" class="Comment">-- This is a very useful consequence of univalence</a>
<a id="10021" class="Keyword">open</a> <a id="10026" class="Keyword">import</a> <a id="10033" href="Cubical.Foundations.SIP.html" class="Module">Cubical.Foundations.SIP</a>

<a id="sip&#39;"></a><a id="10058" href="Cubical.Talks.EPA2020.html#10058" class="Function">sip&#39;</a> <a id="10063" class="Symbol">:</a> <a id="10065" class="Symbol">{</a><a id="10066" href="Cubical.Talks.EPA2020.html#10066" class="Bound">ℓ</a> <a id="10068" class="Symbol">:</a> <a id="10070" href="Agda.Primitive.html#591" class="Postulate">Level</a><a id="10075" class="Symbol">}</a> <a id="10077" class="Symbol">{</a><a id="10078" href="Cubical.Talks.EPA2020.html#10078" class="Bound">S</a> <a id="10080" class="Symbol">:</a> <a id="10082" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="10087" href="Cubical.Talks.EPA2020.html#10066" class="Bound">ℓ</a> <a id="10089" class="Symbol">→</a> <a id="10091" href="Agda.Primitive.html#320" class="Primitive">Type</a> <a id="10096" href="Cubical.Talks.EPA2020.html#10066" class="Bound">ℓ</a><a id="10097" class="Symbol">}</a> <a id="10099" class="Symbol">{</a><a id="10100" href="Cubical.Talks.EPA2020.html#10100" class="Bound">ι</a> <a id="10102" class="Symbol">:</a> <a id="10104" href="Cubical.Foundations.Structure.html#1070" class="Function">StrEquiv</a> <a id="10113" href="Cubical.Talks.EPA2020.html#10078" class="Bound">S</a> <a id="10115" href="Cubical.Talks.EPA2020.html#10066" class="Bound">ℓ</a><a id="10116" class="Symbol">}</a>
       <a id="10125" class="Symbol">(</a><a id="10126" href="Cubical.Talks.EPA2020.html#10126" class="Bound">θ</a> <a id="10128" class="Symbol">:</a> <a id="10130" href="Cubical.Foundations.SIP.html#1663" class="Function">UnivalentStr</a> <a id="10143" href="Cubical.Talks.EPA2020.html#10078" class="Bound">S</a> <a id="10145" href="Cubical.Talks.EPA2020.html#10100" class="Bound">ι</a><a id="10146" class="Symbol">)</a> <a id="10148" class="Symbol">(</a><a id="10149" href="Cubical.Talks.EPA2020.html#10149" class="Bound">A</a> <a id="10151" href="Cubical.Talks.EPA2020.html#10151" class="Bound">B</a> <a id="10153" class="Symbol">:</a> <a id="10155" href="Cubical.Foundations.Structure.html#398" class="Function">TypeWithStr</a> <a id="10167" href="Cubical.Talks.EPA2020.html#10066" class="Bound">ℓ</a> <a id="10169" href="Cubical.Talks.EPA2020.html#10078" class="Bound">S</a><a id="10170" class="Symbol">)</a> <a id="10172" class="Symbol">→</a> <a id="10174" href="Cubical.Talks.EPA2020.html#10149" class="Bound">A</a> <a id="10176" href="Cubical.Foundations.SIP.html#1423" class="Function Operator">≃[</a> <a id="10179" href="Cubical.Talks.EPA2020.html#10100" class="Bound">ι</a> <a id="10181" href="Cubical.Foundations.SIP.html#1423" class="Function Operator">]</a> <a id="10183" href="Cubical.Talks.EPA2020.html#10151" class="Bound">B</a> <a id="10185" class="Symbol">→</a> <a id="10187" href="Cubical.Talks.EPA2020.html#10149" class="Bound">A</a> <a id="10189" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="10191" href="Cubical.Talks.EPA2020.html#10151" class="Bound">B</a>
<a id="10193" href="Cubical.Talks.EPA2020.html#10058" class="Function">sip&#39;</a> <a id="10198" class="Symbol">=</a> <a id="10200" href="Cubical.Foundations.SIP.html#4314" class="Function">sip</a>

<a id="10205" class="Comment">-- The tricky thing is to prove that (S,ι) is a univalent structure.</a>
<a id="10274" class="Comment">-- Luckily we provide automation for this in the library, see for example:</a>
<a id="10349" class="Keyword">open</a> <a id="10354" class="Keyword">import</a> <a id="10361" href="Cubical.Algebra.Monoid.Base.html" class="Module">Cubical.Algebra.Monoid.Base</a>

<a id="10390" class="Comment">-- Another cool application of the SIP: matrices represented as</a>
<a id="10454" class="Comment">-- functions out of pairs of Fin&#39;s and vectors are equal as abelian</a>
<a id="10522" class="Comment">-- groups:</a>
<a id="10533" class="Keyword">open</a> <a id="10538" class="Keyword">import</a> <a id="10545" href="Cubical.Algebra.Matrix.html" class="Module">Cubical.Algebra.Matrix</a>


<a id="10570" class="Comment">-- The end, back to slides!</a>
</pre></body></html>