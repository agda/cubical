<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Cubical.Talks.EPA2020</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">{-

Cubical Agda - A Dependently Typed PL with Univalence and HITs
==============================================================
                    Anders Mörtberg
       Every Proof Assistant - September 17, 2020


Link to slides: https://staff.math.su.se/anders.mortberg/slides/EPA2020.pdf

Link to video: https://vimeo.com/459020971

-}</a>

<a id="344" class="Comment">-- To make Agda cubical add the --cubical option.</a>
<a id="394" class="Comment">-- This is implicitly added for files in the cubical library via the cubical.agda-lib file.</a>
<a id="486" class="Keyword">module</a> <a id="493" href="Cubical.Talks.EPA2020.html" class="Module">Cubical.Talks.EPA2020</a> <a id="515" class="Keyword">where</a>

<a id="522" class="Comment">-- The &quot;Foundations&quot; package contain a lot of important results (in</a>
<a id="590" class="Comment">-- particular the univalence theorem)</a>
<a id="628" class="Keyword">open</a> <a id="633" class="Keyword">import</a> <a id="640" href="Cubical.Foundations.Prelude.html" class="Module">Cubical.Foundations.Prelude</a>
<a id="668" class="Keyword">open</a> <a id="673" class="Keyword">import</a> <a id="680" href="Cubical.Foundations.Equiv.html" class="Module">Cubical.Foundations.Equiv</a>
<a id="706" class="Keyword">open</a> <a id="711" class="Keyword">import</a> <a id="718" href="Cubical.Foundations.Isomorphism.html" class="Module">Cubical.Foundations.Isomorphism</a>
<a id="750" class="Keyword">open</a> <a id="755" class="Keyword">import</a> <a id="762" href="Cubical.Foundations.Univalence.html" class="Module">Cubical.Foundations.Univalence</a>

<a id="794" class="Keyword">open</a> <a id="799" class="Keyword">import</a> <a id="806" href="Cubical.Data.Int.html" class="Module">Cubical.Data.Int</a>
<a id="823" class="Keyword">open</a> <a id="828" class="Keyword">import</a> <a id="835" href="Cubical.Data.Prod.Base.html" class="Module">Cubical.Data.Prod.Base</a>


<a id="860" class="Comment">-- The interval in Cubical Agda is written I and the endpoints i0 and i1.</a>

<a id="apply0"></a><a id="935" href="Cubical.Talks.EPA2020.html#935" class="Function">apply0</a> <a id="942" class="Symbol">:</a> <a id="944" class="Symbol">(</a><a id="945" href="Cubical.Talks.EPA2020.html#945" class="Bound">A</a> <a id="947" class="Symbol">:</a> <a id="949" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="953" class="Symbol">)</a> <a id="955" class="Symbol">(</a><a id="956" href="Cubical.Talks.EPA2020.html#956" class="Bound">p</a> <a id="958" class="Symbol">:</a> <a id="960" href="Agda.Primitive.Cubical.html#150" class="Datatype">I</a> <a id="962" class="Symbol">→</a> <a id="964" href="Cubical.Talks.EPA2020.html#945" class="Bound">A</a><a id="965" class="Symbol">)</a> <a id="967" class="Symbol">→</a> <a id="969" href="Cubical.Talks.EPA2020.html#945" class="Bound">A</a>
<a id="971" href="Cubical.Talks.EPA2020.html#935" class="Function">apply0</a> <a id="978" href="Cubical.Talks.EPA2020.html#978" class="Bound">A</a> <a id="980" href="Cubical.Talks.EPA2020.html#980" class="Bound">p</a> <a id="982" class="Symbol">=</a> <a id="984" href="Cubical.Talks.EPA2020.html#980" class="Bound">p</a> <a id="986" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a>

<a id="990" class="Comment">-- We omit the universe level ℓ for simplicity in this talk. In the</a>
<a id="1058" class="Comment">-- library everything is maximally universe polymorphic.</a>


<a id="1117" class="Comment">-- We can write functions out of the interval using λ-abstraction:</a>
<a id="refl&#39;"></a><a id="1184" href="Cubical.Talks.EPA2020.html#1184" class="Function">refl&#39;</a> <a id="1190" class="Symbol">:</a> <a id="1192" class="Symbol">{</a><a id="1193" href="Cubical.Talks.EPA2020.html#1193" class="Bound">A</a> <a id="1195" class="Symbol">:</a> <a id="1197" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="1201" class="Symbol">}</a> <a id="1203" class="Symbol">(</a><a id="1204" href="Cubical.Talks.EPA2020.html#1204" class="Bound">x</a> <a id="1206" class="Symbol">:</a> <a id="1208" href="Cubical.Talks.EPA2020.html#1193" class="Bound">A</a><a id="1209" class="Symbol">)</a> <a id="1211" class="Symbol">→</a> <a id="1213" href="Cubical.Talks.EPA2020.html#1204" class="Bound">x</a> <a id="1215" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="1217" href="Cubical.Talks.EPA2020.html#1204" class="Bound">x</a>
<a id="1219" href="Cubical.Talks.EPA2020.html#1184" class="Function">refl&#39;</a> <a id="1225" href="Cubical.Talks.EPA2020.html#1225" class="Bound">x</a> <a id="1227" class="Symbol">=</a> <a id="1229" class="Symbol">λ</a> <a id="1231" href="Cubical.Talks.EPA2020.html#1231" class="Bound">i</a> <a id="1233" class="Symbol">→</a> <a id="1235" href="Cubical.Talks.EPA2020.html#1225" class="Bound">x</a>
<a id="1237" class="Comment">-- In fact, x ≡ y is short for PathP (λ _ → A) x y</a>

<a id="refl&#39;&#39;"></a><a id="1289" href="Cubical.Talks.EPA2020.html#1289" class="Function">refl&#39;&#39;</a> <a id="1296" class="Symbol">:</a> <a id="1298" class="Symbol">{</a><a id="1299" href="Cubical.Talks.EPA2020.html#1299" class="Bound">A</a> <a id="1301" class="Symbol">:</a> <a id="1303" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="1307" class="Symbol">}</a> <a id="1309" class="Symbol">(</a><a id="1310" href="Cubical.Talks.EPA2020.html#1310" class="Bound">x</a> <a id="1312" class="Symbol">:</a> <a id="1314" href="Cubical.Talks.EPA2020.html#1299" class="Bound">A</a><a id="1315" class="Symbol">)</a> <a id="1317" class="Symbol">→</a> <a id="1319" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="1325" class="Symbol">(λ</a> <a id="1328" href="Cubical.Talks.EPA2020.html#1328" class="Bound">_</a> <a id="1330" class="Symbol">→</a> <a id="1332" href="Cubical.Talks.EPA2020.html#1299" class="Bound">A</a><a id="1333" class="Symbol">)</a> <a id="1335" href="Cubical.Talks.EPA2020.html#1310" class="Bound">x</a> <a id="1337" href="Cubical.Talks.EPA2020.html#1310" class="Bound">x</a>
<a id="1339" href="Cubical.Talks.EPA2020.html#1289" class="Function">refl&#39;&#39;</a> <a id="1346" href="Cubical.Talks.EPA2020.html#1346" class="Bound">x</a> <a id="1348" class="Symbol">=</a> <a id="1350" class="Symbol">λ</a> <a id="1352" href="Cubical.Talks.EPA2020.html#1352" class="Bound">_</a> <a id="1354" class="Symbol">→</a> <a id="1356" href="Cubical.Talks.EPA2020.html#1346" class="Bound">x</a>

<a id="1359" class="Comment">-- In general PathP A x y has A : I → Type, x : A i0 and y : A i1</a>
<a id="1425" class="Comment">-- PathP = Dependent paths (Path over a Path)</a>

<a id="1472" class="Comment">-- We cannot pattern-match on interval variables as I is not inductively defined</a>
<a id="1553" class="Comment">-- foo : {A : Type} → I → A</a>
<a id="1581" class="Comment">-- foo r = {!r!}   -- Try typing C-c C-c</a>

<a id="1623" class="Comment">-- cong has a direct proof</a>
<a id="cong&#39;"></a><a id="1650" href="Cubical.Talks.EPA2020.html#1650" class="Function">cong&#39;</a> <a id="1656" class="Symbol">:</a> <a id="1658" class="Symbol">{</a><a id="1659" href="Cubical.Talks.EPA2020.html#1659" class="Bound">A</a> <a id="1661" href="Cubical.Talks.EPA2020.html#1661" class="Bound">B</a> <a id="1663" class="Symbol">:</a> <a id="1665" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="1669" class="Symbol">}</a> <a id="1671" class="Symbol">(</a><a id="1672" href="Cubical.Talks.EPA2020.html#1672" class="Bound">f</a> <a id="1674" class="Symbol">:</a> <a id="1676" href="Cubical.Talks.EPA2020.html#1659" class="Bound">A</a> <a id="1678" class="Symbol">→</a> <a id="1680" href="Cubical.Talks.EPA2020.html#1661" class="Bound">B</a><a id="1681" class="Symbol">)</a> <a id="1683" class="Symbol">{</a><a id="1684" href="Cubical.Talks.EPA2020.html#1684" class="Bound">x</a> <a id="1686" href="Cubical.Talks.EPA2020.html#1686" class="Bound">y</a> <a id="1688" class="Symbol">:</a> <a id="1690" href="Cubical.Talks.EPA2020.html#1659" class="Bound">A</a><a id="1691" class="Symbol">}</a> <a id="1693" class="Symbol">→</a> <a id="1695" href="Cubical.Talks.EPA2020.html#1684" class="Bound">x</a> <a id="1697" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="1699" href="Cubical.Talks.EPA2020.html#1686" class="Bound">y</a> <a id="1701" class="Symbol">→</a> <a id="1703" href="Cubical.Talks.EPA2020.html#1672" class="Bound">f</a> <a id="1705" href="Cubical.Talks.EPA2020.html#1684" class="Bound">x</a> <a id="1707" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="1709" href="Cubical.Talks.EPA2020.html#1672" class="Bound">f</a> <a id="1711" href="Cubical.Talks.EPA2020.html#1686" class="Bound">y</a>
<a id="1713" href="Cubical.Talks.EPA2020.html#1650" class="Function">cong&#39;</a> <a id="1719" href="Cubical.Talks.EPA2020.html#1719" class="Bound">f</a> <a id="1721" href="Cubical.Talks.EPA2020.html#1721" class="Bound">p</a> <a id="1723" href="Cubical.Talks.EPA2020.html#1723" class="Bound">i</a> <a id="1725" class="Symbol">=</a> <a id="1727" href="Cubical.Talks.EPA2020.html#1719" class="Bound">f</a> <a id="1729" class="Symbol">(</a><a id="1730" href="Cubical.Talks.EPA2020.html#1721" class="Bound">p</a> <a id="1732" href="Cubical.Talks.EPA2020.html#1723" class="Bound">i</a><a id="1733" class="Symbol">)</a>

<a id="1736" class="Comment">-- function extensionality also has a direct proof.</a>
<a id="1788" class="Comment">-- It also has computational content: swap the arguments.</a>
<a id="funExt&#39;"></a><a id="1846" href="Cubical.Talks.EPA2020.html#1846" class="Function">funExt&#39;</a> <a id="1854" class="Symbol">:</a> <a id="1856" class="Symbol">{</a><a id="1857" href="Cubical.Talks.EPA2020.html#1857" class="Bound">A</a> <a id="1859" href="Cubical.Talks.EPA2020.html#1859" class="Bound">B</a> <a id="1861" class="Symbol">:</a> <a id="1863" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="1867" class="Symbol">}</a> <a id="1869" class="Symbol">{</a><a id="1870" href="Cubical.Talks.EPA2020.html#1870" class="Bound">f</a> <a id="1872" href="Cubical.Talks.EPA2020.html#1872" class="Bound">g</a> <a id="1874" class="Symbol">:</a> <a id="1876" href="Cubical.Talks.EPA2020.html#1857" class="Bound">A</a> <a id="1878" class="Symbol">→</a> <a id="1880" href="Cubical.Talks.EPA2020.html#1859" class="Bound">B</a><a id="1881" class="Symbol">}</a> <a id="1883" class="Symbol">(</a><a id="1884" href="Cubical.Talks.EPA2020.html#1884" class="Bound">p</a> <a id="1886" class="Symbol">:</a> <a id="1888" class="Symbol">(</a><a id="1889" href="Cubical.Talks.EPA2020.html#1889" class="Bound">x</a> <a id="1891" class="Symbol">:</a> <a id="1893" href="Cubical.Talks.EPA2020.html#1857" class="Bound">A</a><a id="1894" class="Symbol">)</a> <a id="1896" class="Symbol">→</a> <a id="1898" href="Cubical.Talks.EPA2020.html#1870" class="Bound">f</a> <a id="1900" href="Cubical.Talks.EPA2020.html#1889" class="Bound">x</a> <a id="1902" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="1904" href="Cubical.Talks.EPA2020.html#1872" class="Bound">g</a> <a id="1906" href="Cubical.Talks.EPA2020.html#1889" class="Bound">x</a><a id="1907" class="Symbol">)</a> <a id="1909" class="Symbol">→</a> <a id="1911" href="Cubical.Talks.EPA2020.html#1870" class="Bound">f</a> <a id="1913" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="1915" href="Cubical.Talks.EPA2020.html#1872" class="Bound">g</a>
<a id="1917" href="Cubical.Talks.EPA2020.html#1846" class="Function">funExt&#39;</a> <a id="1925" href="Cubical.Talks.EPA2020.html#1925" class="Bound">p</a> <a id="1927" href="Cubical.Talks.EPA2020.html#1927" class="Bound">i</a> <a id="1929" href="Cubical.Talks.EPA2020.html#1929" class="Bound">x</a> <a id="1931" class="Symbol">=</a> <a id="1933" href="Cubical.Talks.EPA2020.html#1925" class="Bound">p</a> <a id="1935" href="Cubical.Talks.EPA2020.html#1929" class="Bound">x</a> <a id="1937" href="Cubical.Talks.EPA2020.html#1927" class="Bound">i</a>

<a id="1940" class="Comment">-- Transport is more complex as ≡ isn&#39;t inductively defined (so we</a>
<a id="2007" class="Comment">-- can&#39;t define it by pattern-matching on p)</a>
<a id="transport&#39;"></a><a id="2052" href="Cubical.Talks.EPA2020.html#2052" class="Function">transport&#39;</a> <a id="2063" class="Symbol">:</a> <a id="2065" class="Symbol">{</a><a id="2066" href="Cubical.Talks.EPA2020.html#2066" class="Bound">A</a> <a id="2068" href="Cubical.Talks.EPA2020.html#2068" class="Bound">B</a> <a id="2070" class="Symbol">:</a> <a id="2072" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="2076" class="Symbol">}</a> <a id="2078" class="Symbol">→</a> <a id="2080" href="Cubical.Talks.EPA2020.html#2066" class="Bound">A</a> <a id="2082" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="2084" href="Cubical.Talks.EPA2020.html#2068" class="Bound">B</a> <a id="2086" class="Symbol">→</a> <a id="2088" href="Cubical.Talks.EPA2020.html#2066" class="Bound">A</a> <a id="2090" class="Symbol">→</a> <a id="2092" href="Cubical.Talks.EPA2020.html#2068" class="Bound">B</a>
<a id="2094" href="Cubical.Talks.EPA2020.html#2052" class="Function">transport&#39;</a> <a id="2105" href="Cubical.Talks.EPA2020.html#2105" class="Bound">p</a> <a id="2107" href="Cubical.Talks.EPA2020.html#2107" class="Bound">a</a> <a id="2109" class="Symbol">=</a> <a id="2111" href="Cubical.Core.Primitives.html#633" class="Primitive">transp</a> <a id="2118" class="Symbol">(λ</a> <a id="2121" href="Cubical.Talks.EPA2020.html#2121" class="Bound">i</a> <a id="2123" class="Symbol">→</a> <a id="2125" href="Cubical.Talks.EPA2020.html#2105" class="Bound">p</a> <a id="2127" href="Cubical.Talks.EPA2020.html#2121" class="Bound">i</a><a id="2128" class="Symbol">)</a> <a id="2130" href="Agda.Primitive.Cubical.html#193" class="InductiveConstructor">i0</a> <a id="2133" href="Cubical.Talks.EPA2020.html#2107" class="Bound">a</a>

<a id="2136" class="Comment">-- This lets us define subst (which is called &quot;transport&quot; in the HoTT book)</a>
<a id="subst&#39;"></a><a id="2212" href="Cubical.Talks.EPA2020.html#2212" class="Function">subst&#39;</a> <a id="2219" class="Symbol">:</a> <a id="2221" class="Symbol">{</a><a id="2222" href="Cubical.Talks.EPA2020.html#2222" class="Bound">A</a> <a id="2224" class="Symbol">:</a> <a id="2226" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="2230" class="Symbol">}</a> <a id="2232" class="Symbol">(</a><a id="2233" href="Cubical.Talks.EPA2020.html#2233" class="Bound">P</a> <a id="2235" class="Symbol">:</a> <a id="2237" href="Cubical.Talks.EPA2020.html#2222" class="Bound">A</a> <a id="2239" class="Symbol">→</a> <a id="2241" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="2245" class="Symbol">)</a> <a id="2247" class="Symbol">{</a><a id="2248" href="Cubical.Talks.EPA2020.html#2248" class="Bound">x</a> <a id="2250" href="Cubical.Talks.EPA2020.html#2250" class="Bound">y</a> <a id="2252" class="Symbol">:</a> <a id="2254" href="Cubical.Talks.EPA2020.html#2222" class="Bound">A</a><a id="2255" class="Symbol">}</a> <a id="2257" class="Symbol">(</a><a id="2258" href="Cubical.Talks.EPA2020.html#2258" class="Bound">p</a> <a id="2260" class="Symbol">:</a> <a id="2262" href="Cubical.Talks.EPA2020.html#2248" class="Bound">x</a> <a id="2264" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="2266" href="Cubical.Talks.EPA2020.html#2250" class="Bound">y</a><a id="2267" class="Symbol">)</a> <a id="2269" class="Symbol">→</a> <a id="2271" href="Cubical.Talks.EPA2020.html#2233" class="Bound">P</a> <a id="2273" href="Cubical.Talks.EPA2020.html#2248" class="Bound">x</a> <a id="2275" class="Symbol">→</a> <a id="2277" href="Cubical.Talks.EPA2020.html#2233" class="Bound">P</a> <a id="2279" href="Cubical.Talks.EPA2020.html#2250" class="Bound">y</a>
<a id="2281" href="Cubical.Talks.EPA2020.html#2212" class="Function">subst&#39;</a> <a id="2288" href="Cubical.Talks.EPA2020.html#2288" class="Bound">P</a> <a id="2290" href="Cubical.Talks.EPA2020.html#2290" class="Bound">p</a> <a id="2292" href="Cubical.Talks.EPA2020.html#2292" class="Bound">pa</a> <a id="2295" class="Symbol">=</a> <a id="2297" href="Cubical.Foundations.Prelude.html#9674" class="Function">transport</a> <a id="2307" class="Symbol">(λ</a> <a id="2310" href="Cubical.Talks.EPA2020.html#2310" class="Bound">i</a> <a id="2312" class="Symbol">→</a> <a id="2314" href="Cubical.Talks.EPA2020.html#2288" class="Bound">P</a> <a id="2316" class="Symbol">(</a><a id="2317" href="Cubical.Talks.EPA2020.html#2290" class="Bound">p</a> <a id="2319" href="Cubical.Talks.EPA2020.html#2310" class="Bound">i</a><a id="2320" class="Symbol">))</a> <a id="2323" href="Cubical.Talks.EPA2020.html#2292" class="Bound">pa</a>

<a id="2327" class="Comment">-- The transp operation reduces differently for different types</a>
<a id="2391" class="Comment">-- formers. For paths it reduces to another primitive operation called</a>
<a id="2462" class="Comment">-- hcomp.</a>

<a id="2473" class="Comment">-- We can also define the J eliminator (aka path induction)</a>
<a id="J&#39;"></a><a id="2533" href="Cubical.Talks.EPA2020.html#2533" class="Function">J&#39;</a> <a id="2536" class="Symbol">:</a> <a id="2538" class="Symbol">{</a><a id="2539" href="Cubical.Talks.EPA2020.html#2539" class="Bound">A</a> <a id="2541" class="Symbol">:</a> <a id="2543" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="2547" class="Symbol">}</a> <a id="2549" class="Symbol">{</a><a id="2550" href="Cubical.Talks.EPA2020.html#2550" class="Bound">B</a> <a id="2552" class="Symbol">:</a> <a id="2554" href="Cubical.Talks.EPA2020.html#2539" class="Bound">A</a> <a id="2556" class="Symbol">→</a> <a id="2558" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="2562" class="Symbol">}</a> <a id="2564" class="Symbol">{</a><a id="2565" href="Cubical.Talks.EPA2020.html#2565" class="Bound">x</a> <a id="2567" class="Symbol">:</a> <a id="2569" href="Cubical.Talks.EPA2020.html#2539" class="Bound">A</a><a id="2570" class="Symbol">}</a>
     <a id="2577" class="Symbol">(</a><a id="2578" href="Cubical.Talks.EPA2020.html#2578" class="Bound">P</a> <a id="2580" class="Symbol">:</a> <a id="2582" class="Symbol">(</a><a id="2583" href="Cubical.Talks.EPA2020.html#2583" class="Bound">z</a> <a id="2585" class="Symbol">:</a> <a id="2587" href="Cubical.Talks.EPA2020.html#2539" class="Bound">A</a><a id="2588" class="Symbol">)</a> <a id="2590" class="Symbol">→</a> <a id="2592" href="Cubical.Talks.EPA2020.html#2565" class="Bound">x</a> <a id="2594" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="2596" href="Cubical.Talks.EPA2020.html#2583" class="Bound">z</a> <a id="2598" class="Symbol">→</a> <a id="2600" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="2604" class="Symbol">)</a>
     <a id="2611" class="Symbol">(</a><a id="2612" href="Cubical.Talks.EPA2020.html#2612" class="Bound">d</a> <a id="2614" class="Symbol">:</a> <a id="2616" href="Cubical.Talks.EPA2020.html#2578" class="Bound">P</a> <a id="2618" href="Cubical.Talks.EPA2020.html#2565" class="Bound">x</a> <a id="2620" href="Cubical.Foundations.Prelude.html#892" class="Function">refl</a><a id="2624" class="Symbol">)</a> <a id="2626" class="Symbol">{</a><a id="2627" href="Cubical.Talks.EPA2020.html#2627" class="Bound">y</a> <a id="2629" class="Symbol">:</a> <a id="2631" href="Cubical.Talks.EPA2020.html#2539" class="Bound">A</a><a id="2632" class="Symbol">}</a> <a id="2634" class="Symbol">(</a><a id="2635" href="Cubical.Talks.EPA2020.html#2635" class="Bound">p</a> <a id="2637" class="Symbol">:</a> <a id="2639" href="Cubical.Talks.EPA2020.html#2565" class="Bound">x</a> <a id="2641" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="2643" href="Cubical.Talks.EPA2020.html#2627" class="Bound">y</a><a id="2644" class="Symbol">)</a> <a id="2646" class="Symbol">→</a> <a id="2648" href="Cubical.Talks.EPA2020.html#2578" class="Bound">P</a> <a id="2650" href="Cubical.Talks.EPA2020.html#2627" class="Bound">y</a> <a id="2652" href="Cubical.Talks.EPA2020.html#2635" class="Bound">p</a>
<a id="2654" href="Cubical.Talks.EPA2020.html#2533" class="Function">J&#39;</a> <a id="2657" href="Cubical.Talks.EPA2020.html#2657" class="Bound">P</a> <a id="2659" href="Cubical.Talks.EPA2020.html#2659" class="Bound">d</a> <a id="2661" href="Cubical.Talks.EPA2020.html#2661" class="Bound">p</a> <a id="2663" class="Symbol">=</a> <a id="2665" href="Cubical.Foundations.Prelude.html#9674" class="Function">transport</a> <a id="2675" class="Symbol">(λ</a> <a id="2678" href="Cubical.Talks.EPA2020.html#2678" class="Bound">i</a> <a id="2680" class="Symbol">→</a> <a id="2682" href="Cubical.Talks.EPA2020.html#2657" class="Bound">P</a> <a id="2684" class="Symbol">(</a><a id="2685" href="Cubical.Talks.EPA2020.html#2661" class="Bound">p</a> <a id="2687" href="Cubical.Talks.EPA2020.html#2678" class="Bound">i</a><a id="2688" class="Symbol">)</a> <a id="2690" class="Symbol">(λ</a> <a id="2693" href="Cubical.Talks.EPA2020.html#2693" class="Bound">j</a> <a id="2695" class="Symbol">→</a> <a id="2697" href="Cubical.Talks.EPA2020.html#2661" class="Bound">p</a> <a id="2699" class="Symbol">(</a><a id="2700" href="Cubical.Talks.EPA2020.html#2678" class="Bound">i</a> <a id="2702" href="Cubical.Core.Primitives.html#380" class="Primitive Operator">∧</a> <a id="2704" href="Cubical.Talks.EPA2020.html#2693" class="Bound">j</a><a id="2705" class="Symbol">)))</a> <a id="2709" href="Cubical.Talks.EPA2020.html#2659" class="Bound">d</a>

<a id="2712" class="Comment">-- So J is provable, but it doesn&#39;t satisfy computation rule</a>
<a id="2773" class="Comment">-- definitionally. This is almost never a problem in practice as the</a>
<a id="2842" class="Comment">-- cubical primitives satisfy many new definitional equalities.</a>



<a id="2909" class="Comment">-- Another key concept in HoTT/UF is the Univalence Axiom. In Cubical</a>
<a id="2979" class="Comment">-- Agda this is provable, we hence refer to it as the Univalence</a>
<a id="3044" class="Comment">-- Theorem.</a>

<a id="3057" class="Comment">-- The univalence theorem: equivalences of types give paths of types</a>
<a id="ua&#39;"></a><a id="3126" href="Cubical.Talks.EPA2020.html#3126" class="Function">ua&#39;</a> <a id="3130" class="Symbol">:</a> <a id="3132" class="Symbol">{</a><a id="3133" href="Cubical.Talks.EPA2020.html#3133" class="Bound">A</a> <a id="3135" href="Cubical.Talks.EPA2020.html#3135" class="Bound">B</a> <a id="3137" class="Symbol">:</a> <a id="3139" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="3143" class="Symbol">}</a> <a id="3145" class="Symbol">→</a> <a id="3147" href="Cubical.Talks.EPA2020.html#3133" class="Bound">A</a> <a id="3149" href="Agda.Builtin.Cubical.Equiv.html#1012" class="Function Operator">≃</a> <a id="3151" href="Cubical.Talks.EPA2020.html#3135" class="Bound">B</a> <a id="3153" class="Symbol">→</a> <a id="3155" href="Cubical.Talks.EPA2020.html#3133" class="Bound">A</a> <a id="3157" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="3159" href="Cubical.Talks.EPA2020.html#3135" class="Bound">B</a>
<a id="3161" href="Cubical.Talks.EPA2020.html#3126" class="Function">ua&#39;</a> <a id="3165" class="Symbol">=</a> <a id="3167" href="Cubical.Foundations.Univalence.html#905" class="Function">ua</a>

<a id="3171" class="Comment">-- Any isomorphism of types gives rise to an equivalence</a>
<a id="isoToEquiv&#39;"></a><a id="3228" href="Cubical.Talks.EPA2020.html#3228" class="Function">isoToEquiv&#39;</a> <a id="3240" class="Symbol">:</a> <a id="3242" class="Symbol">{</a><a id="3243" href="Cubical.Talks.EPA2020.html#3243" class="Bound">A</a> <a id="3245" href="Cubical.Talks.EPA2020.html#3245" class="Bound">B</a> <a id="3247" class="Symbol">:</a> <a id="3249" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="3253" class="Symbol">}</a> <a id="3255" class="Symbol">→</a> <a id="3257" href="Cubical.Foundations.Isomorphism.html#744" class="Record">Iso</a> <a id="3261" href="Cubical.Talks.EPA2020.html#3243" class="Bound">A</a> <a id="3263" href="Cubical.Talks.EPA2020.html#3245" class="Bound">B</a> <a id="3265" class="Symbol">→</a> <a id="3267" href="Cubical.Talks.EPA2020.html#3243" class="Bound">A</a> <a id="3269" href="Agda.Builtin.Cubical.Equiv.html#1012" class="Function Operator">≃</a> <a id="3271" href="Cubical.Talks.EPA2020.html#3245" class="Bound">B</a>
<a id="3273" href="Cubical.Talks.EPA2020.html#3228" class="Function">isoToEquiv&#39;</a> <a id="3285" class="Symbol">=</a> <a id="3287" href="Cubical.Foundations.Isomorphism.html#3098" class="Function">isoToEquiv</a>

<a id="3299" class="Comment">-- And hence to a path</a>
<a id="isoToPath&#39;"></a><a id="3322" href="Cubical.Talks.EPA2020.html#3322" class="Function">isoToPath&#39;</a> <a id="3333" class="Symbol">:</a> <a id="3335" class="Symbol">{</a><a id="3336" href="Cubical.Talks.EPA2020.html#3336" class="Bound">A</a> <a id="3338" href="Cubical.Talks.EPA2020.html#3338" class="Bound">B</a> <a id="3340" class="Symbol">:</a> <a id="3342" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="3346" class="Symbol">}</a> <a id="3348" class="Symbol">→</a> <a id="3350" href="Cubical.Foundations.Isomorphism.html#744" class="Record">Iso</a> <a id="3354" href="Cubical.Talks.EPA2020.html#3336" class="Bound">A</a> <a id="3356" href="Cubical.Talks.EPA2020.html#3338" class="Bound">B</a> <a id="3358" class="Symbol">→</a> <a id="3360" href="Cubical.Talks.EPA2020.html#3336" class="Bound">A</a> <a id="3362" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="3364" href="Cubical.Talks.EPA2020.html#3338" class="Bound">B</a>
<a id="3366" href="Cubical.Talks.EPA2020.html#3322" class="Function">isoToPath&#39;</a> <a id="3377" href="Cubical.Talks.EPA2020.html#3377" class="Bound">e</a> <a id="3379" class="Symbol">=</a> <a id="3381" href="Cubical.Talks.EPA2020.html#3126" class="Function">ua&#39;</a> <a id="3385" class="Symbol">(</a><a id="3386" href="Cubical.Talks.EPA2020.html#3228" class="Function">isoToEquiv&#39;</a> <a id="3398" href="Cubical.Talks.EPA2020.html#3377" class="Bound">e</a><a id="3399" class="Symbol">)</a>

<a id="3402" class="Comment">-- ua satisfies the following computation rule</a>
<a id="3449" class="Comment">-- This suffices to be able to prove the standard formulation of univalence.</a>
<a id="uaβ&#39;"></a><a id="3526" href="Cubical.Talks.EPA2020.html#3526" class="Function">uaβ&#39;</a> <a id="3531" class="Symbol">:</a> <a id="3533" class="Symbol">{</a><a id="3534" href="Cubical.Talks.EPA2020.html#3534" class="Bound">A</a> <a id="3536" href="Cubical.Talks.EPA2020.html#3536" class="Bound">B</a> <a id="3538" class="Symbol">:</a> <a id="3540" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="3544" class="Symbol">}</a> <a id="3546" class="Symbol">(</a><a id="3547" href="Cubical.Talks.EPA2020.html#3547" class="Bound">e</a> <a id="3549" class="Symbol">:</a> <a id="3551" href="Cubical.Talks.EPA2020.html#3534" class="Bound">A</a> <a id="3553" href="Agda.Builtin.Cubical.Equiv.html#1012" class="Function Operator">≃</a> <a id="3555" href="Cubical.Talks.EPA2020.html#3536" class="Bound">B</a><a id="3556" class="Symbol">)</a> <a id="3558" class="Symbol">(</a><a id="3559" href="Cubical.Talks.EPA2020.html#3559" class="Bound">x</a> <a id="3561" class="Symbol">:</a> <a id="3563" href="Cubical.Talks.EPA2020.html#3534" class="Bound">A</a><a id="3564" class="Symbol">)</a>
     <a id="3571" class="Symbol">→</a> <a id="3573" href="Cubical.Foundations.Prelude.html#9674" class="Function">transport</a> <a id="3583" class="Symbol">(</a><a id="3584" href="Cubical.Talks.EPA2020.html#3126" class="Function">ua&#39;</a> <a id="3588" href="Cubical.Talks.EPA2020.html#3547" class="Bound">e</a><a id="3589" class="Symbol">)</a> <a id="3591" href="Cubical.Talks.EPA2020.html#3559" class="Bound">x</a> <a id="3593" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="3595" href="Agda.Builtin.Sigma.html#251" class="Field">fst</a> <a id="3599" href="Cubical.Talks.EPA2020.html#3547" class="Bound">e</a> <a id="3601" href="Cubical.Talks.EPA2020.html#3559" class="Bound">x</a>
<a id="3603" href="Cubical.Talks.EPA2020.html#3526" class="Function">uaβ&#39;</a> <a id="3608" href="Cubical.Talks.EPA2020.html#3608" class="Bound">e</a> <a id="3610" href="Cubical.Talks.EPA2020.html#3610" class="Bound">x</a> <a id="3612" class="Symbol">=</a> <a id="3614" href="Cubical.Foundations.Prelude.html#9895" class="Function">transportRefl</a> <a id="3628" class="Symbol">(</a><a id="3629" href="Agda.Builtin.Cubical.Equiv.html#1104" class="Function">equivFun</a> <a id="3638" href="Cubical.Talks.EPA2020.html#3608" class="Bound">e</a> <a id="3640" href="Cubical.Talks.EPA2020.html#3610" class="Bound">x</a><a id="3641" class="Symbol">)</a>



<a id="3646" class="Comment">-- Time for an example!</a>

<a id="3671" class="Comment">-- Booleans</a>
<a id="3683" class="Keyword">data</a> <a id="Bool"></a><a id="3688" href="Cubical.Talks.EPA2020.html#3688" class="Datatype">Bool</a> <a id="3693" class="Symbol">:</a> <a id="3695" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="3700" class="Keyword">where</a>
  <a id="Bool.false"></a><a id="3708" href="Cubical.Talks.EPA2020.html#3708" class="InductiveConstructor">false</a> <a id="Bool.true"></a><a id="3714" href="Cubical.Talks.EPA2020.html#3714" class="InductiveConstructor">true</a> <a id="3719" class="Symbol">:</a> <a id="3721" href="Cubical.Talks.EPA2020.html#3688" class="Datatype">Bool</a>

<a id="not"></a><a id="3727" href="Cubical.Talks.EPA2020.html#3727" class="Function">not</a> <a id="3731" class="Symbol">:</a> <a id="3733" href="Cubical.Talks.EPA2020.html#3688" class="Datatype">Bool</a> <a id="3738" class="Symbol">→</a> <a id="3740" href="Cubical.Talks.EPA2020.html#3688" class="Datatype">Bool</a>
<a id="3745" href="Cubical.Talks.EPA2020.html#3727" class="Function">not</a> <a id="3749" href="Cubical.Talks.EPA2020.html#3708" class="InductiveConstructor">false</a> <a id="3755" class="Symbol">=</a> <a id="3757" href="Cubical.Talks.EPA2020.html#3714" class="InductiveConstructor">true</a>
<a id="3762" href="Cubical.Talks.EPA2020.html#3727" class="Function">not</a> <a id="3766" href="Cubical.Talks.EPA2020.html#3714" class="InductiveConstructor">true</a>  <a id="3772" class="Symbol">=</a> <a id="3774" href="Cubical.Talks.EPA2020.html#3708" class="InductiveConstructor">false</a>

<a id="notPath"></a><a id="3781" href="Cubical.Talks.EPA2020.html#3781" class="Function">notPath</a> <a id="3789" class="Symbol">:</a> <a id="3791" href="Cubical.Talks.EPA2020.html#3688" class="Datatype">Bool</a> <a id="3796" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="3798" href="Cubical.Talks.EPA2020.html#3688" class="Datatype">Bool</a>
<a id="3803" href="Cubical.Talks.EPA2020.html#3781" class="Function">notPath</a> <a id="3811" class="Symbol">=</a> <a id="3813" href="Cubical.Talks.EPA2020.html#3322" class="Function">isoToPath&#39;</a> <a id="3824" class="Symbol">(</a><a id="3825" href="Cubical.Foundations.Isomorphism.html#840" class="InductiveConstructor">iso</a> <a id="3829" href="Cubical.Talks.EPA2020.html#3727" class="Function">not</a> <a id="3833" href="Cubical.Talks.EPA2020.html#3727" class="Function">not</a> <a id="3837" href="Cubical.Talks.EPA2020.html#3856" class="Function">rem</a> <a id="3841" href="Cubical.Talks.EPA2020.html#3856" class="Function">rem</a><a id="3844" class="Symbol">)</a>
  <a id="3848" class="Keyword">where</a>
  <a id="3856" href="Cubical.Talks.EPA2020.html#3856" class="Function">rem</a> <a id="3860" class="Symbol">:</a> <a id="3862" class="Symbol">(</a><a id="3863" href="Cubical.Talks.EPA2020.html#3863" class="Bound">b</a> <a id="3865" class="Symbol">:</a> <a id="3867" href="Cubical.Talks.EPA2020.html#3688" class="Datatype">Bool</a><a id="3871" class="Symbol">)</a> <a id="3873" class="Symbol">→</a> <a id="3875" href="Cubical.Talks.EPA2020.html#3727" class="Function">not</a> <a id="3879" class="Symbol">(</a><a id="3880" href="Cubical.Talks.EPA2020.html#3727" class="Function">not</a> <a id="3884" href="Cubical.Talks.EPA2020.html#3863" class="Bound">b</a><a id="3885" class="Symbol">)</a> <a id="3887" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="3889" href="Cubical.Talks.EPA2020.html#3863" class="Bound">b</a>
  <a id="3893" href="Cubical.Talks.EPA2020.html#3856" class="Function">rem</a> <a id="3897" href="Cubical.Talks.EPA2020.html#3708" class="InductiveConstructor">false</a> <a id="3903" class="Symbol">=</a> <a id="3905" href="Cubical.Foundations.Prelude.html#892" class="Function">refl</a>
  <a id="3912" href="Cubical.Talks.EPA2020.html#3856" class="Function">rem</a> <a id="3916" href="Cubical.Talks.EPA2020.html#3714" class="InductiveConstructor">true</a>  <a id="3922" class="Symbol">=</a> <a id="3924" href="Cubical.Foundations.Prelude.html#892" class="Function">refl</a>

<a id="3930" href="Cubical.Talks.EPA2020.html#3930" class="Function">_</a> <a id="3932" class="Symbol">:</a> <a id="3934" href="Cubical.Foundations.Prelude.html#9674" class="Function">transport</a> <a id="3944" href="Cubical.Talks.EPA2020.html#3781" class="Function">notPath</a> <a id="3952" href="Cubical.Talks.EPA2020.html#3714" class="InductiveConstructor">true</a> <a id="3957" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="3959" href="Cubical.Talks.EPA2020.html#3708" class="InductiveConstructor">false</a>
<a id="3965" class="Symbol">_</a> <a id="3967" class="Symbol">=</a> <a id="3969" href="Cubical.Foundations.Prelude.html#892" class="Function">refl</a>


<a id="3976" class="Comment">-- Another example, integers:</a>

<a id="sucPath"></a><a id="4007" href="Cubical.Talks.EPA2020.html#4007" class="Function">sucPath</a> <a id="4015" class="Symbol">:</a> <a id="4017" href="Cubical.Data.Int.Base.html#419" class="Datatype">ℤ</a> <a id="4019" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="4021" href="Cubical.Data.Int.Base.html#419" class="Datatype">ℤ</a>
<a id="4023" href="Cubical.Talks.EPA2020.html#4007" class="Function">sucPath</a> <a id="4031" class="Symbol">=</a> <a id="4033" href="Cubical.Talks.EPA2020.html#3322" class="Function">isoToPath&#39;</a> <a id="4044" class="Symbol">(</a><a id="4045" href="Cubical.Foundations.Isomorphism.html#840" class="InductiveConstructor">iso</a> <a id="4049" href="Cubical.Data.Int.Base.html#547" class="Function">sucℤ</a> <a id="4054" href="Cubical.Data.Int.Base.html#663" class="Function">predℤ</a> <a id="4060" href="Cubical.Data.Int.Properties.html#3479" class="Function">sucPred</a> <a id="4068" href="Cubical.Data.Int.Properties.html#3602" class="Function">predSuc</a><a id="4075" class="Symbol">)</a>

<a id="4078" href="Cubical.Talks.EPA2020.html#4078" class="Function">_</a> <a id="4080" class="Symbol">:</a> <a id="4082" href="Cubical.Foundations.Prelude.html#9674" class="Function">transport</a> <a id="4092" href="Cubical.Talks.EPA2020.html#4007" class="Function">sucPath</a> <a id="4100" class="Symbol">(</a><a id="4101" href="Cubical.Data.Int.Base.html#437" class="InductiveConstructor">pos</a> <a id="4105" class="Number">0</a><a id="4106" class="Symbol">)</a> <a id="4108" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="4110" href="Cubical.Data.Int.Base.html#437" class="InductiveConstructor">pos</a> <a id="4114" class="Number">1</a>
<a id="4116" class="Symbol">_</a> <a id="4118" class="Symbol">=</a> <a id="4120" href="Cubical.Foundations.Prelude.html#892" class="Function">refl</a>

<a id="4126" href="Cubical.Talks.EPA2020.html#4126" class="Function">_</a> <a id="4128" class="Symbol">:</a> <a id="4130" href="Cubical.Foundations.Prelude.html#9674" class="Function">transport</a> <a id="4140" class="Symbol">(</a><a id="4141" href="Cubical.Talks.EPA2020.html#4007" class="Function">sucPath</a> <a id="4149" href="Cubical.Foundations.Prelude.html#5184" class="Function Operator">∙</a> <a id="4151" href="Cubical.Talks.EPA2020.html#4007" class="Function">sucPath</a><a id="4158" class="Symbol">)</a> <a id="4160" class="Symbol">(</a><a id="4161" href="Cubical.Data.Int.Base.html#437" class="InductiveConstructor">pos</a> <a id="4165" class="Number">0</a><a id="4166" class="Symbol">)</a> <a id="4168" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="4170" href="Cubical.Data.Int.Base.html#437" class="InductiveConstructor">pos</a> <a id="4174" class="Number">2</a>
<a id="4176" class="Symbol">_</a> <a id="4178" class="Symbol">=</a> <a id="4180" href="Cubical.Foundations.Prelude.html#892" class="Function">refl</a>

<a id="4186" href="Cubical.Talks.EPA2020.html#4186" class="Function">_</a> <a id="4188" class="Symbol">:</a> <a id="4190" href="Cubical.Foundations.Prelude.html#9674" class="Function">transport</a> <a id="4200" class="Symbol">(</a><a id="4201" href="Cubical.Foundations.Prelude.html#945" class="Function">sym</a> <a id="4205" href="Cubical.Talks.EPA2020.html#4007" class="Function">sucPath</a><a id="4212" class="Symbol">)</a> <a id="4214" class="Symbol">(</a><a id="4215" href="Cubical.Data.Int.Base.html#437" class="InductiveConstructor">pos</a> <a id="4219" class="Number">0</a><a id="4220" class="Symbol">)</a> <a id="4222" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="4224" href="Cubical.Data.Int.Base.html#460" class="InductiveConstructor">negsuc</a> <a id="4231" class="Number">0</a>
<a id="4233" class="Symbol">_</a> <a id="4235" class="Symbol">=</a> <a id="4237" href="Cubical.Foundations.Prelude.html#892" class="Function">refl</a>



<a id="4245" class="Comment">-----------------------------------------------------------------------------</a>
<a id="4323" class="Comment">-- Higher inductive types</a>

<a id="4350" class="Comment">-- The following definition of finite multisets is due to Vikraman</a>
<a id="4417" class="Comment">-- Choudhury and Marcelo Fiore.</a>

<a id="4450" class="Keyword">infixr</a> <a id="4457" class="Number">5</a> <a id="4459" href="Cubical.Talks.EPA2020.html#4516" class="InductiveConstructor Operator">_∷_</a>

<a id="4464" class="Keyword">data</a> <a id="FMSet"></a><a id="4469" href="Cubical.Talks.EPA2020.html#4469" class="Datatype">FMSet</a> <a id="4475" class="Symbol">(</a><a id="4476" href="Cubical.Talks.EPA2020.html#4476" class="Bound">A</a> <a id="4478" class="Symbol">:</a> <a id="4480" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="4484" class="Symbol">)</a> <a id="4486" class="Symbol">:</a> <a id="4488" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="4493" class="Keyword">where</a>
  <a id="FMSet.[]"></a><a id="4501" href="Cubical.Talks.EPA2020.html#4501" class="InductiveConstructor">[]</a> <a id="4504" class="Symbol">:</a> <a id="4506" href="Cubical.Talks.EPA2020.html#4469" class="Datatype">FMSet</a> <a id="4512" href="Cubical.Talks.EPA2020.html#4476" class="Bound">A</a>
  <a id="FMSet._∷_"></a><a id="4516" href="Cubical.Talks.EPA2020.html#4516" class="InductiveConstructor Operator">_∷_</a> <a id="4520" class="Symbol">:</a> <a id="4522" class="Symbol">(</a><a id="4523" href="Cubical.Talks.EPA2020.html#4523" class="Bound">x</a> <a id="4525" class="Symbol">:</a> <a id="4527" href="Cubical.Talks.EPA2020.html#4476" class="Bound">A</a><a id="4528" class="Symbol">)</a> <a id="4530" class="Symbol">→</a> <a id="4532" class="Symbol">(</a><a id="4533" href="Cubical.Talks.EPA2020.html#4533" class="Bound">xs</a> <a id="4536" class="Symbol">:</a> <a id="4538" href="Cubical.Talks.EPA2020.html#4469" class="Datatype">FMSet</a> <a id="4544" href="Cubical.Talks.EPA2020.html#4476" class="Bound">A</a><a id="4545" class="Symbol">)</a> <a id="4547" class="Symbol">→</a> <a id="4549" href="Cubical.Talks.EPA2020.html#4469" class="Datatype">FMSet</a> <a id="4555" href="Cubical.Talks.EPA2020.html#4476" class="Bound">A</a>
  <a id="FMSet.comm"></a><a id="4559" href="Cubical.Talks.EPA2020.html#4559" class="InductiveConstructor">comm</a> <a id="4564" class="Symbol">:</a> <a id="4566" class="Symbol">(</a><a id="4567" href="Cubical.Talks.EPA2020.html#4567" class="Bound">x</a> <a id="4569" href="Cubical.Talks.EPA2020.html#4569" class="Bound">y</a> <a id="4571" class="Symbol">:</a> <a id="4573" href="Cubical.Talks.EPA2020.html#4476" class="Bound">A</a><a id="4574" class="Symbol">)</a> <a id="4576" class="Symbol">(</a><a id="4577" href="Cubical.Talks.EPA2020.html#4577" class="Bound">xs</a> <a id="4580" class="Symbol">:</a> <a id="4582" href="Cubical.Talks.EPA2020.html#4469" class="Datatype">FMSet</a> <a id="4588" href="Cubical.Talks.EPA2020.html#4476" class="Bound">A</a><a id="4589" class="Symbol">)</a> <a id="4591" class="Symbol">→</a> <a id="4593" href="Cubical.Talks.EPA2020.html#4567" class="Bound">x</a> <a id="4595" href="Cubical.Talks.EPA2020.html#4516" class="InductiveConstructor Operator">∷</a> <a id="4597" href="Cubical.Talks.EPA2020.html#4569" class="Bound">y</a> <a id="4599" href="Cubical.Talks.EPA2020.html#4516" class="InductiveConstructor Operator">∷</a> <a id="4601" href="Cubical.Talks.EPA2020.html#4577" class="Bound">xs</a> <a id="4604" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="4606" href="Cubical.Talks.EPA2020.html#4569" class="Bound">y</a> <a id="4608" href="Cubical.Talks.EPA2020.html#4516" class="InductiveConstructor Operator">∷</a> <a id="4610" href="Cubical.Talks.EPA2020.html#4567" class="Bound">x</a> <a id="4612" href="Cubical.Talks.EPA2020.html#4516" class="InductiveConstructor Operator">∷</a> <a id="4614" href="Cubical.Talks.EPA2020.html#4577" class="Bound">xs</a>
<a id="4617" class="Comment">--  trunc : (xs ys : FMSet A) (p q : xs ≡ ys) → p ≡ q</a>

<a id="4672" class="Comment">-- We need to add the trunc constructor for FMSets to be sets, omitted</a>
<a id="4743" class="Comment">-- here for simplicity.</a>

<a id="_++_"></a><a id="4768" href="Cubical.Talks.EPA2020.html#4768" class="Function Operator">_++_</a> <a id="4773" class="Symbol">:</a> <a id="4775" class="Symbol">∀</a> <a id="4777" class="Symbol">{</a><a id="4778" href="Cubical.Talks.EPA2020.html#4778" class="Bound">A</a> <a id="4780" class="Symbol">:</a> <a id="4782" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="4786" class="Symbol">}</a> <a id="4788" class="Symbol">(</a><a id="4789" href="Cubical.Talks.EPA2020.html#4789" class="Bound">xs</a> <a id="4792" href="Cubical.Talks.EPA2020.html#4792" class="Bound">ys</a> <a id="4795" class="Symbol">:</a> <a id="4797" href="Cubical.Talks.EPA2020.html#4469" class="Datatype">FMSet</a> <a id="4803" href="Cubical.Talks.EPA2020.html#4778" class="Bound">A</a><a id="4804" class="Symbol">)</a> <a id="4806" class="Symbol">→</a> <a id="4808" href="Cubical.Talks.EPA2020.html#4469" class="Datatype">FMSet</a> <a id="4814" href="Cubical.Talks.EPA2020.html#4778" class="Bound">A</a>
<a id="4816" href="Cubical.Talks.EPA2020.html#4501" class="InductiveConstructor">[]</a> <a id="4819" href="Cubical.Talks.EPA2020.html#4768" class="Function Operator">++</a> <a id="4822" href="Cubical.Talks.EPA2020.html#4822" class="Bound">ys</a> <a id="4825" class="Symbol">=</a> <a id="4827" href="Cubical.Talks.EPA2020.html#4822" class="Bound">ys</a>
<a id="4830" class="Symbol">(</a><a id="4831" href="Cubical.Talks.EPA2020.html#4831" class="Bound">x</a> <a id="4833" href="Cubical.Talks.EPA2020.html#4516" class="InductiveConstructor Operator">∷</a> <a id="4835" href="Cubical.Talks.EPA2020.html#4835" class="Bound">xs</a><a id="4837" class="Symbol">)</a> <a id="4839" href="Cubical.Talks.EPA2020.html#4768" class="Function Operator">++</a> <a id="4842" href="Cubical.Talks.EPA2020.html#4842" class="Bound">ys</a> <a id="4845" class="Symbol">=</a> <a id="4847" href="Cubical.Talks.EPA2020.html#4831" class="Bound">x</a> <a id="4849" href="Cubical.Talks.EPA2020.html#4516" class="InductiveConstructor Operator">∷</a> <a id="4851" href="Cubical.Talks.EPA2020.html#4835" class="Bound">xs</a> <a id="4854" href="Cubical.Talks.EPA2020.html#4768" class="Function Operator">++</a> <a id="4857" href="Cubical.Talks.EPA2020.html#4842" class="Bound">ys</a>
<a id="4860" href="Cubical.Talks.EPA2020.html#4559" class="InductiveConstructor">comm</a> <a id="4865" href="Cubical.Talks.EPA2020.html#4865" class="Bound">x</a> <a id="4867" href="Cubical.Talks.EPA2020.html#4867" class="Bound">y</a> <a id="4869" href="Cubical.Talks.EPA2020.html#4869" class="Bound">xs</a> <a id="4872" href="Cubical.Talks.EPA2020.html#4872" class="Bound">i</a> <a id="4874" href="Cubical.Talks.EPA2020.html#4768" class="Function Operator">++</a> <a id="4877" href="Cubical.Talks.EPA2020.html#4877" class="Bound">ys</a> <a id="4880" class="Symbol">=</a> <a id="4882" href="Cubical.Talks.EPA2020.html#4559" class="InductiveConstructor">comm</a> <a id="4887" href="Cubical.Talks.EPA2020.html#4865" class="Bound">x</a> <a id="4889" href="Cubical.Talks.EPA2020.html#4867" class="Bound">y</a> <a id="4891" class="Symbol">(</a><a id="4892" href="Cubical.Talks.EPA2020.html#4869" class="Bound">xs</a> <a id="4895" href="Cubical.Talks.EPA2020.html#4768" class="Function Operator">++</a> <a id="4898" href="Cubical.Talks.EPA2020.html#4877" class="Bound">ys</a><a id="4900" class="Symbol">)</a> <a id="4902" href="Cubical.Talks.EPA2020.html#4872" class="Bound">i</a>
<a id="4904" class="Comment">-- trunc xs zs p q i j ++ ys =</a>
<a id="4935" class="Comment">--   trunc (xs ++ ys) (zs ++ ys) (cong (_++ ys) p) (cong (_++ ys) q) i j</a>

<a id="unitr-++"></a><a id="5009" href="Cubical.Talks.EPA2020.html#5009" class="Function">unitr-++</a> <a id="5018" class="Symbol">:</a> <a id="5020" class="Symbol">{</a><a id="5021" href="Cubical.Talks.EPA2020.html#5021" class="Bound">A</a> <a id="5023" class="Symbol">:</a> <a id="5025" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="5029" class="Symbol">}</a> <a id="5031" class="Symbol">(</a><a id="5032" href="Cubical.Talks.EPA2020.html#5032" class="Bound">xs</a> <a id="5035" class="Symbol">:</a> <a id="5037" href="Cubical.Talks.EPA2020.html#4469" class="Datatype">FMSet</a> <a id="5043" href="Cubical.Talks.EPA2020.html#5021" class="Bound">A</a><a id="5044" class="Symbol">)</a> <a id="5046" class="Symbol">→</a> <a id="5048" href="Cubical.Talks.EPA2020.html#5032" class="Bound">xs</a> <a id="5051" href="Cubical.Talks.EPA2020.html#4768" class="Function Operator">++</a> <a id="5054" href="Cubical.Talks.EPA2020.html#4501" class="InductiveConstructor">[]</a> <a id="5057" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="5059" href="Cubical.Talks.EPA2020.html#5032" class="Bound">xs</a>
<a id="5062" href="Cubical.Talks.EPA2020.html#5009" class="Function">unitr-++</a> <a id="5071" href="Cubical.Talks.EPA2020.html#4501" class="InductiveConstructor">[]</a> <a id="5074" class="Symbol">=</a> <a id="5076" href="Cubical.Foundations.Prelude.html#892" class="Function">refl</a>
<a id="5081" href="Cubical.Talks.EPA2020.html#5009" class="Function">unitr-++</a> <a id="5090" class="Symbol">(</a><a id="5091" href="Cubical.Talks.EPA2020.html#5091" class="Bound">x</a> <a id="5093" href="Cubical.Talks.EPA2020.html#4516" class="InductiveConstructor Operator">∷</a> <a id="5095" href="Cubical.Talks.EPA2020.html#5095" class="Bound">xs</a><a id="5097" class="Symbol">)</a> <a id="5099" class="Symbol">=</a> <a id="5101" href="Cubical.Foundations.Prelude.html#1407" class="Function">cong</a> <a id="5106" class="Symbol">(</a><a id="5107" href="Cubical.Talks.EPA2020.html#5091" class="Bound">x</a> <a id="5109" href="Cubical.Talks.EPA2020.html#4516" class="InductiveConstructor Operator">∷_</a><a id="5111" class="Symbol">)</a> <a id="5113" class="Symbol">(</a><a id="5114" href="Cubical.Talks.EPA2020.html#5009" class="Function">unitr-++</a> <a id="5123" href="Cubical.Talks.EPA2020.html#5095" class="Bound">xs</a><a id="5125" class="Symbol">)</a>
<a id="5127" href="Cubical.Talks.EPA2020.html#5009" class="Function">unitr-++</a> <a id="5136" class="Symbol">(</a><a id="5137" href="Cubical.Talks.EPA2020.html#4559" class="InductiveConstructor">comm</a> <a id="5142" href="Cubical.Talks.EPA2020.html#5142" class="Bound">x</a> <a id="5144" href="Cubical.Talks.EPA2020.html#5144" class="Bound">y</a> <a id="5146" href="Cubical.Talks.EPA2020.html#5146" class="Bound">xs</a> <a id="5149" href="Cubical.Talks.EPA2020.html#5149" class="Bound">i</a><a id="5150" class="Symbol">)</a> <a id="5152" href="Cubical.Talks.EPA2020.html#5152" class="Bound">j</a> <a id="5154" class="Symbol">=</a> <a id="5156" href="Cubical.Talks.EPA2020.html#4559" class="InductiveConstructor">comm</a> <a id="5161" href="Cubical.Talks.EPA2020.html#5142" class="Bound">x</a> <a id="5163" href="Cubical.Talks.EPA2020.html#5144" class="Bound">y</a> <a id="5165" class="Symbol">(</a><a id="5166" href="Cubical.Talks.EPA2020.html#5009" class="Function">unitr-++</a> <a id="5175" href="Cubical.Talks.EPA2020.html#5146" class="Bound">xs</a> <a id="5178" href="Cubical.Talks.EPA2020.html#5152" class="Bound">j</a><a id="5179" class="Symbol">)</a> <a id="5181" href="Cubical.Talks.EPA2020.html#5149" class="Bound">i</a>
<a id="5183" class="Comment">-- unitr-++ (trunc xs ys x y i j) = {!!}</a>


<a id="5226" class="Comment">-- This is a special case of set quotients! Very useful for</a>
<a id="5286" class="Comment">-- programming and set level mathematics</a>

<a id="5328" class="Keyword">data</a> <a id="_/_"></a><a id="5333" href="Cubical.Talks.EPA2020.html#5333" class="Datatype Operator">_/_</a> <a id="5337" class="Symbol">(</a><a id="5338" href="Cubical.Talks.EPA2020.html#5338" class="Bound">A</a> <a id="5340" class="Symbol">:</a> <a id="5342" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="5346" class="Symbol">)</a> <a id="5348" class="Symbol">(</a><a id="5349" href="Cubical.Talks.EPA2020.html#5349" class="Bound">R</a> <a id="5351" class="Symbol">:</a> <a id="5353" href="Cubical.Talks.EPA2020.html#5338" class="Bound">A</a> <a id="5355" class="Symbol">→</a> <a id="5357" href="Cubical.Talks.EPA2020.html#5338" class="Bound">A</a> <a id="5359" class="Symbol">→</a> <a id="5361" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="5365" class="Symbol">)</a> <a id="5367" class="Symbol">:</a> <a id="5369" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="5374" class="Keyword">where</a>
  <a id="_/_.[_]"></a><a id="5382" href="Cubical.Talks.EPA2020.html#5382" class="InductiveConstructor Operator">[_]</a> <a id="5386" class="Symbol">:</a> <a id="5388" href="Cubical.Talks.EPA2020.html#5338" class="Bound">A</a> <a id="5390" class="Symbol">→</a> <a id="5392" href="Cubical.Talks.EPA2020.html#5338" class="Bound">A</a> <a id="5394" href="Cubical.Talks.EPA2020.html#5333" class="Datatype Operator">/</a> <a id="5396" href="Cubical.Talks.EPA2020.html#5349" class="Bound">R</a>
  <a id="_/_.eq/"></a><a id="5400" href="Cubical.Talks.EPA2020.html#5400" class="InductiveConstructor">eq/</a> <a id="5404" class="Symbol">:</a> <a id="5406" class="Symbol">(</a><a id="5407" href="Cubical.Talks.EPA2020.html#5407" class="Bound">a</a> <a id="5409" href="Cubical.Talks.EPA2020.html#5409" class="Bound">b</a> <a id="5411" class="Symbol">:</a> <a id="5413" href="Cubical.Talks.EPA2020.html#5338" class="Bound">A</a><a id="5414" class="Symbol">)</a> <a id="5416" class="Symbol">→</a> <a id="5418" href="Cubical.Talks.EPA2020.html#5349" class="Bound">R</a> <a id="5420" href="Cubical.Talks.EPA2020.html#5407" class="Bound">a</a> <a id="5422" href="Cubical.Talks.EPA2020.html#5409" class="Bound">b</a> <a id="5424" class="Symbol">→</a> <a id="5426" href="Cubical.Talks.EPA2020.html#5382" class="InductiveConstructor Operator">[</a> <a id="5428" href="Cubical.Talks.EPA2020.html#5407" class="Bound">a</a> <a id="5430" href="Cubical.Talks.EPA2020.html#5382" class="InductiveConstructor Operator">]</a> <a id="5432" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="5434" href="Cubical.Talks.EPA2020.html#5382" class="InductiveConstructor Operator">[</a> <a id="5436" href="Cubical.Talks.EPA2020.html#5409" class="Bound">b</a> <a id="5438" href="Cubical.Talks.EPA2020.html#5382" class="InductiveConstructor Operator">]</a>
  <a id="_/_.trunc"></a><a id="5442" href="Cubical.Talks.EPA2020.html#5442" class="InductiveConstructor">trunc</a> <a id="5448" class="Symbol">:</a> <a id="5450" class="Symbol">(</a><a id="5451" href="Cubical.Talks.EPA2020.html#5451" class="Bound">a</a> <a id="5453" href="Cubical.Talks.EPA2020.html#5453" class="Bound">b</a> <a id="5455" class="Symbol">:</a> <a id="5457" href="Cubical.Talks.EPA2020.html#5338" class="Bound">A</a> <a id="5459" href="Cubical.Talks.EPA2020.html#5333" class="Datatype Operator">/</a> <a id="5461" href="Cubical.Talks.EPA2020.html#5349" class="Bound">R</a><a id="5462" class="Symbol">)</a> <a id="5464" class="Symbol">(</a><a id="5465" href="Cubical.Talks.EPA2020.html#5465" class="Bound">p</a> <a id="5467" href="Cubical.Talks.EPA2020.html#5467" class="Bound">q</a> <a id="5469" class="Symbol">:</a> <a id="5471" href="Cubical.Talks.EPA2020.html#5451" class="Bound">a</a> <a id="5473" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="5475" href="Cubical.Talks.EPA2020.html#5453" class="Bound">b</a><a id="5476" class="Symbol">)</a> <a id="5478" class="Symbol">→</a> <a id="5480" href="Cubical.Talks.EPA2020.html#5465" class="Bound">p</a> <a id="5482" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="5484" href="Cubical.Talks.EPA2020.html#5467" class="Bound">q</a>

<a id="5487" class="Comment">-- Proving that they are effective ((a b : A) → [ a ] ≡ [ b ] → R a b)</a>
<a id="5558" class="Comment">-- requires univalence for propositions.</a>


<a id="5601" class="Comment">-------------------------------------------------------------------------</a>
<a id="5675" class="Comment">-- Topological examples of things that are not sets</a>

<a id="5728" class="Comment">-- We can define the circle as the following simple data declaration:</a>
<a id="5798" class="Keyword">data</a> <a id="S¹"></a><a id="5803" href="Cubical.Talks.EPA2020.html#5803" class="Datatype">S¹</a> <a id="5806" class="Symbol">:</a> <a id="5808" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="5813" class="Keyword">where</a>
  <a id="S¹.base"></a><a id="5821" href="Cubical.Talks.EPA2020.html#5821" class="InductiveConstructor">base</a> <a id="5826" class="Symbol">:</a> <a id="5828" href="Cubical.Talks.EPA2020.html#5803" class="Datatype">S¹</a>
  <a id="S¹.loop"></a><a id="5833" href="Cubical.Talks.EPA2020.html#5833" class="InductiveConstructor">loop</a> <a id="5838" class="Symbol">:</a> <a id="5840" href="Cubical.Talks.EPA2020.html#5821" class="InductiveConstructor">base</a> <a id="5845" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="5847" href="Cubical.Talks.EPA2020.html#5821" class="InductiveConstructor">base</a>

<a id="5853" class="Comment">-- We can write functions on S¹ using pattern-matching equations:</a>
<a id="double"></a><a id="5919" href="Cubical.Talks.EPA2020.html#5919" class="Function">double</a> <a id="5926" class="Symbol">:</a> <a id="5928" href="Cubical.Talks.EPA2020.html#5803" class="Datatype">S¹</a> <a id="5931" class="Symbol">→</a> <a id="5933" href="Cubical.Talks.EPA2020.html#5803" class="Datatype">S¹</a>
<a id="5936" href="Cubical.Talks.EPA2020.html#5919" class="Function">double</a> <a id="5943" href="Cubical.Talks.EPA2020.html#5821" class="InductiveConstructor">base</a> <a id="5948" class="Symbol">=</a> <a id="5950" href="Cubical.Talks.EPA2020.html#5821" class="InductiveConstructor">base</a>
<a id="5955" href="Cubical.Talks.EPA2020.html#5919" class="Function">double</a> <a id="5962" class="Symbol">(</a><a id="5963" href="Cubical.Talks.EPA2020.html#5833" class="InductiveConstructor">loop</a> <a id="5968" href="Cubical.Talks.EPA2020.html#5968" class="Bound">i</a><a id="5969" class="Symbol">)</a> <a id="5971" class="Symbol">=</a> <a id="5973" class="Symbol">(</a><a id="5974" href="Cubical.Talks.EPA2020.html#5833" class="InductiveConstructor">loop</a> <a id="5979" href="Cubical.Foundations.Prelude.html#5184" class="Function Operator">∙</a> <a id="5981" href="Cubical.Talks.EPA2020.html#5833" class="InductiveConstructor">loop</a><a id="5985" class="Symbol">)</a> <a id="5987" href="Cubical.Talks.EPA2020.html#5968" class="Bound">i</a>

<a id="helix"></a><a id="5990" href="Cubical.Talks.EPA2020.html#5990" class="Function">helix</a> <a id="5996" class="Symbol">:</a> <a id="5998" href="Cubical.Talks.EPA2020.html#5803" class="Datatype">S¹</a> <a id="6001" class="Symbol">→</a> <a id="6003" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="6008" href="Cubical.Talks.EPA2020.html#5990" class="Function">helix</a> <a id="6014" href="Cubical.Talks.EPA2020.html#5821" class="InductiveConstructor">base</a>     <a id="6023" class="Symbol">=</a> <a id="6025" href="Cubical.Data.Int.Base.html#419" class="Datatype">ℤ</a>
<a id="6027" href="Cubical.Talks.EPA2020.html#5990" class="Function">helix</a> <a id="6033" class="Symbol">(</a><a id="6034" href="Cubical.Talks.EPA2020.html#5833" class="InductiveConstructor">loop</a> <a id="6039" href="Cubical.Talks.EPA2020.html#6039" class="Bound">i</a><a id="6040" class="Symbol">)</a> <a id="6042" class="Symbol">=</a> <a id="6044" href="Cubical.Data.Int.Properties.html#23619" class="Function">sucPathℤ</a> <a id="6053" href="Cubical.Talks.EPA2020.html#6039" class="Bound">i</a>

<a id="ΩS¹"></a><a id="6056" href="Cubical.Talks.EPA2020.html#6056" class="Function">ΩS¹</a> <a id="6060" class="Symbol">:</a> <a id="6062" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="6067" href="Cubical.Talks.EPA2020.html#6056" class="Function">ΩS¹</a> <a id="6071" class="Symbol">=</a> <a id="6073" href="Cubical.Talks.EPA2020.html#5821" class="InductiveConstructor">base</a> <a id="6078" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="6080" href="Cubical.Talks.EPA2020.html#5821" class="InductiveConstructor">base</a>

<a id="winding"></a><a id="6086" href="Cubical.Talks.EPA2020.html#6086" class="Function">winding</a> <a id="6094" class="Symbol">:</a> <a id="6096" href="Cubical.Talks.EPA2020.html#6056" class="Function">ΩS¹</a> <a id="6100" class="Symbol">→</a> <a id="6102" href="Cubical.Data.Int.Base.html#419" class="Datatype">ℤ</a>
<a id="6104" href="Cubical.Talks.EPA2020.html#6086" class="Function">winding</a> <a id="6112" href="Cubical.Talks.EPA2020.html#6112" class="Bound">p</a> <a id="6114" class="Symbol">=</a> <a id="6116" href="Cubical.Foundations.Prelude.html#10205" class="Function">subst</a> <a id="6122" href="Cubical.Talks.EPA2020.html#5990" class="Function">helix</a> <a id="6128" href="Cubical.Talks.EPA2020.html#6112" class="Bound">p</a> <a id="6130" class="Symbol">(</a><a id="6131" href="Cubical.Data.Int.Base.html#437" class="InductiveConstructor">pos</a> <a id="6135" class="Number">0</a><a id="6136" class="Symbol">)</a>

<a id="6139" href="Cubical.Talks.EPA2020.html#6139" class="Function">_</a> <a id="6141" class="Symbol">:</a> <a id="6143" href="Cubical.Talks.EPA2020.html#6086" class="Function">winding</a> <a id="6151" class="Symbol">(λ</a> <a id="6154" href="Cubical.Talks.EPA2020.html#6154" class="Bound">i</a> <a id="6156" class="Symbol">→</a> <a id="6158" href="Cubical.Talks.EPA2020.html#5919" class="Function">double</a> <a id="6165" class="Symbol">((</a><a id="6167" href="Cubical.Talks.EPA2020.html#5833" class="InductiveConstructor">loop</a> <a id="6172" href="Cubical.Foundations.Prelude.html#5184" class="Function Operator">∙</a> <a id="6174" href="Cubical.Talks.EPA2020.html#5833" class="InductiveConstructor">loop</a><a id="6178" class="Symbol">)</a> <a id="6180" href="Cubical.Talks.EPA2020.html#6154" class="Bound">i</a><a id="6181" class="Symbol">))</a> <a id="6184" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="6186" href="Cubical.Data.Int.Base.html#437" class="InductiveConstructor">pos</a> <a id="6190" class="Number">4</a>
<a id="6192" class="Symbol">_</a> <a id="6194" class="Symbol">=</a> <a id="6196" href="Cubical.Foundations.Prelude.html#892" class="Function">refl</a>


<a id="6203" class="Comment">-- We can define the Torus as:</a>
<a id="6234" class="Keyword">data</a> <a id="Torus"></a><a id="6239" href="Cubical.Talks.EPA2020.html#6239" class="Datatype">Torus</a> <a id="6245" class="Symbol">:</a> <a id="6247" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="6252" class="Keyword">where</a>
  <a id="Torus.point"></a><a id="6260" href="Cubical.Talks.EPA2020.html#6260" class="InductiveConstructor">point</a> <a id="6266" class="Symbol">:</a> <a id="6268" href="Cubical.Talks.EPA2020.html#6239" class="Datatype">Torus</a>
  <a id="Torus.line1"></a><a id="6276" href="Cubical.Talks.EPA2020.html#6276" class="InductiveConstructor">line1</a> <a id="6282" class="Symbol">:</a> <a id="6284" href="Cubical.Talks.EPA2020.html#6260" class="InductiveConstructor">point</a> <a id="6290" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="6292" href="Cubical.Talks.EPA2020.html#6260" class="InductiveConstructor">point</a>
  <a id="Torus.line2"></a><a id="6300" href="Cubical.Talks.EPA2020.html#6300" class="InductiveConstructor">line2</a> <a id="6306" class="Symbol">:</a> <a id="6308" href="Cubical.Talks.EPA2020.html#6260" class="InductiveConstructor">point</a> <a id="6314" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="6316" href="Cubical.Talks.EPA2020.html#6260" class="InductiveConstructor">point</a>
  <a id="Torus.square"></a><a id="6324" href="Cubical.Talks.EPA2020.html#6324" class="InductiveConstructor">square</a> <a id="6331" class="Symbol">:</a> <a id="6333" href="Agda.Primitive.Cubical.html#2013" class="Postulate">PathP</a> <a id="6339" class="Symbol">(λ</a> <a id="6342" href="Cubical.Talks.EPA2020.html#6342" class="Bound">i</a> <a id="6344" class="Symbol">→</a> <a id="6346" href="Cubical.Talks.EPA2020.html#6276" class="InductiveConstructor">line1</a> <a id="6352" href="Cubical.Talks.EPA2020.html#6342" class="Bound">i</a> <a id="6354" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="6356" href="Cubical.Talks.EPA2020.html#6276" class="InductiveConstructor">line1</a> <a id="6362" href="Cubical.Talks.EPA2020.html#6342" class="Bound">i</a><a id="6363" class="Symbol">)</a> <a id="6365" href="Cubical.Talks.EPA2020.html#6300" class="InductiveConstructor">line2</a> <a id="6371" href="Cubical.Talks.EPA2020.html#6300" class="InductiveConstructor">line2</a>

<a id="6378" class="Comment">-- And prove that it is equivalent to two circle:</a>
<a id="t2c"></a><a id="6428" href="Cubical.Talks.EPA2020.html#6428" class="Function">t2c</a> <a id="6432" class="Symbol">:</a> <a id="6434" href="Cubical.Talks.EPA2020.html#6239" class="Datatype">Torus</a> <a id="6440" class="Symbol">→</a> <a id="6442" href="Cubical.Talks.EPA2020.html#5803" class="Datatype">S¹</a> <a id="6445" href="Cubical.Data.Prod.Base.html#645" class="Datatype Operator">×</a> <a id="6447" href="Cubical.Talks.EPA2020.html#5803" class="Datatype">S¹</a>
<a id="6450" href="Cubical.Talks.EPA2020.html#6428" class="Function">t2c</a> <a id="6454" href="Cubical.Talks.EPA2020.html#6260" class="InductiveConstructor">point</a>        <a id="6467" class="Symbol">=</a> <a id="6469" class="Symbol">(</a><a id="6470" href="Cubical.Talks.EPA2020.html#5821" class="InductiveConstructor">base</a> <a id="6475" href="Cubical.Data.Prod.Base.html#704" class="InductiveConstructor Operator">,</a> <a id="6477" href="Cubical.Talks.EPA2020.html#5821" class="InductiveConstructor">base</a><a id="6481" class="Symbol">)</a>
<a id="6483" href="Cubical.Talks.EPA2020.html#6428" class="Function">t2c</a> <a id="6487" class="Symbol">(</a><a id="6488" href="Cubical.Talks.EPA2020.html#6276" class="InductiveConstructor">line1</a> <a id="6494" href="Cubical.Talks.EPA2020.html#6494" class="Bound">i</a><a id="6495" class="Symbol">)</a>    <a id="6500" class="Symbol">=</a> <a id="6502" class="Symbol">(</a><a id="6503" href="Cubical.Talks.EPA2020.html#5833" class="InductiveConstructor">loop</a> <a id="6508" href="Cubical.Talks.EPA2020.html#6494" class="Bound">i</a> <a id="6510" href="Cubical.Data.Prod.Base.html#704" class="InductiveConstructor Operator">,</a> <a id="6512" href="Cubical.Talks.EPA2020.html#5821" class="InductiveConstructor">base</a><a id="6516" class="Symbol">)</a>
<a id="6518" href="Cubical.Talks.EPA2020.html#6428" class="Function">t2c</a> <a id="6522" class="Symbol">(</a><a id="6523" href="Cubical.Talks.EPA2020.html#6300" class="InductiveConstructor">line2</a> <a id="6529" href="Cubical.Talks.EPA2020.html#6529" class="Bound">j</a><a id="6530" class="Symbol">)</a>    <a id="6535" class="Symbol">=</a> <a id="6537" class="Symbol">(</a><a id="6538" href="Cubical.Talks.EPA2020.html#5821" class="InductiveConstructor">base</a> <a id="6543" href="Cubical.Data.Prod.Base.html#704" class="InductiveConstructor Operator">,</a> <a id="6545" href="Cubical.Talks.EPA2020.html#5833" class="InductiveConstructor">loop</a> <a id="6550" href="Cubical.Talks.EPA2020.html#6529" class="Bound">j</a><a id="6551" class="Symbol">)</a>
<a id="6553" href="Cubical.Talks.EPA2020.html#6428" class="Function">t2c</a> <a id="6557" class="Symbol">(</a><a id="6558" href="Cubical.Talks.EPA2020.html#6324" class="InductiveConstructor">square</a> <a id="6565" href="Cubical.Talks.EPA2020.html#6565" class="Bound">i</a> <a id="6567" href="Cubical.Talks.EPA2020.html#6567" class="Bound">j</a><a id="6568" class="Symbol">)</a> <a id="6570" class="Symbol">=</a> <a id="6572" class="Symbol">(</a><a id="6573" href="Cubical.Talks.EPA2020.html#5833" class="InductiveConstructor">loop</a> <a id="6578" href="Cubical.Talks.EPA2020.html#6565" class="Bound">i</a> <a id="6580" href="Cubical.Data.Prod.Base.html#704" class="InductiveConstructor Operator">,</a> <a id="6582" href="Cubical.Talks.EPA2020.html#5833" class="InductiveConstructor">loop</a> <a id="6587" href="Cubical.Talks.EPA2020.html#6567" class="Bound">j</a><a id="6588" class="Symbol">)</a>

<a id="c2t"></a><a id="6591" href="Cubical.Talks.EPA2020.html#6591" class="Function">c2t</a> <a id="6595" class="Symbol">:</a> <a id="6597" href="Cubical.Talks.EPA2020.html#5803" class="Datatype">S¹</a> <a id="6600" href="Cubical.Data.Prod.Base.html#645" class="Datatype Operator">×</a> <a id="6602" href="Cubical.Talks.EPA2020.html#5803" class="Datatype">S¹</a> <a id="6605" class="Symbol">→</a> <a id="6607" href="Cubical.Talks.EPA2020.html#6239" class="Datatype">Torus</a>
<a id="6613" href="Cubical.Talks.EPA2020.html#6591" class="Function">c2t</a> <a id="6617" class="Symbol">(</a><a id="6618" href="Cubical.Talks.EPA2020.html#5821" class="InductiveConstructor">base</a>   <a id="6625" href="Cubical.Data.Prod.Base.html#704" class="InductiveConstructor Operator">,</a> <a id="6627" href="Cubical.Talks.EPA2020.html#5821" class="InductiveConstructor">base</a><a id="6631" class="Symbol">)</a>   <a id="6635" class="Symbol">=</a> <a id="6637" href="Cubical.Talks.EPA2020.html#6260" class="InductiveConstructor">point</a>
<a id="6643" href="Cubical.Talks.EPA2020.html#6591" class="Function">c2t</a> <a id="6647" class="Symbol">(</a><a id="6648" href="Cubical.Talks.EPA2020.html#5833" class="InductiveConstructor">loop</a> <a id="6653" href="Cubical.Talks.EPA2020.html#6653" class="Bound">i</a> <a id="6655" href="Cubical.Data.Prod.Base.html#704" class="InductiveConstructor Operator">,</a> <a id="6657" href="Cubical.Talks.EPA2020.html#5821" class="InductiveConstructor">base</a><a id="6661" class="Symbol">)</a>   <a id="6665" class="Symbol">=</a> <a id="6667" href="Cubical.Talks.EPA2020.html#6276" class="InductiveConstructor">line1</a> <a id="6673" href="Cubical.Talks.EPA2020.html#6653" class="Bound">i</a>
<a id="6675" href="Cubical.Talks.EPA2020.html#6591" class="Function">c2t</a> <a id="6679" class="Symbol">(</a><a id="6680" href="Cubical.Talks.EPA2020.html#5821" class="InductiveConstructor">base</a>   <a id="6687" href="Cubical.Data.Prod.Base.html#704" class="InductiveConstructor Operator">,</a> <a id="6689" href="Cubical.Talks.EPA2020.html#5833" class="InductiveConstructor">loop</a> <a id="6694" href="Cubical.Talks.EPA2020.html#6694" class="Bound">j</a><a id="6695" class="Symbol">)</a> <a id="6697" class="Symbol">=</a> <a id="6699" href="Cubical.Talks.EPA2020.html#6300" class="InductiveConstructor">line2</a> <a id="6705" href="Cubical.Talks.EPA2020.html#6694" class="Bound">j</a>
<a id="6707" href="Cubical.Talks.EPA2020.html#6591" class="Function">c2t</a> <a id="6711" class="Symbol">(</a><a id="6712" href="Cubical.Talks.EPA2020.html#5833" class="InductiveConstructor">loop</a> <a id="6717" href="Cubical.Talks.EPA2020.html#6717" class="Bound">i</a> <a id="6719" href="Cubical.Data.Prod.Base.html#704" class="InductiveConstructor Operator">,</a> <a id="6721" href="Cubical.Talks.EPA2020.html#5833" class="InductiveConstructor">loop</a> <a id="6726" href="Cubical.Talks.EPA2020.html#6726" class="Bound">j</a><a id="6727" class="Symbol">)</a> <a id="6729" class="Symbol">=</a> <a id="6731" href="Cubical.Talks.EPA2020.html#6324" class="InductiveConstructor">square</a> <a id="6738" href="Cubical.Talks.EPA2020.html#6717" class="Bound">i</a> <a id="6740" href="Cubical.Talks.EPA2020.html#6726" class="Bound">j</a>

<a id="c2t-t2c"></a><a id="6743" href="Cubical.Talks.EPA2020.html#6743" class="Function">c2t-t2c</a> <a id="6751" class="Symbol">:</a> <a id="6753" class="Symbol">(</a><a id="6754" href="Cubical.Talks.EPA2020.html#6754" class="Bound">t</a> <a id="6756" class="Symbol">:</a> <a id="6758" href="Cubical.Talks.EPA2020.html#6239" class="Datatype">Torus</a><a id="6763" class="Symbol">)</a> <a id="6765" class="Symbol">→</a> <a id="6767" href="Cubical.Talks.EPA2020.html#6591" class="Function">c2t</a> <a id="6771" class="Symbol">(</a><a id="6772" href="Cubical.Talks.EPA2020.html#6428" class="Function">t2c</a> <a id="6776" href="Cubical.Talks.EPA2020.html#6754" class="Bound">t</a><a id="6777" class="Symbol">)</a> <a id="6779" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="6781" href="Cubical.Talks.EPA2020.html#6754" class="Bound">t</a>
<a id="6783" href="Cubical.Talks.EPA2020.html#6743" class="Function">c2t-t2c</a> <a id="6791" href="Cubical.Talks.EPA2020.html#6260" class="InductiveConstructor">point</a>        <a id="6804" class="Symbol">=</a> <a id="6806" href="Cubical.Foundations.Prelude.html#892" class="Function">refl</a>
<a id="6811" href="Cubical.Talks.EPA2020.html#6743" class="Function">c2t-t2c</a> <a id="6819" class="Symbol">(</a><a id="6820" href="Cubical.Talks.EPA2020.html#6276" class="InductiveConstructor">line1</a> <a id="6826" class="Symbol">_)</a>    <a id="6832" class="Symbol">=</a> <a id="6834" href="Cubical.Foundations.Prelude.html#892" class="Function">refl</a>
<a id="6839" href="Cubical.Talks.EPA2020.html#6743" class="Function">c2t-t2c</a> <a id="6847" class="Symbol">(</a><a id="6848" href="Cubical.Talks.EPA2020.html#6300" class="InductiveConstructor">line2</a> <a id="6854" class="Symbol">_)</a>    <a id="6860" class="Symbol">=</a> <a id="6862" href="Cubical.Foundations.Prelude.html#892" class="Function">refl</a>
<a id="6867" href="Cubical.Talks.EPA2020.html#6743" class="Function">c2t-t2c</a> <a id="6875" class="Symbol">(</a><a id="6876" href="Cubical.Talks.EPA2020.html#6324" class="InductiveConstructor">square</a> <a id="6883" class="Symbol">_</a> <a id="6885" class="Symbol">_)</a> <a id="6888" class="Symbol">=</a> <a id="6890" href="Cubical.Foundations.Prelude.html#892" class="Function">refl</a>

<a id="t2c-c2t"></a><a id="6896" href="Cubical.Talks.EPA2020.html#6896" class="Function">t2c-c2t</a> <a id="6904" class="Symbol">:</a> <a id="6906" class="Symbol">(</a><a id="6907" href="Cubical.Talks.EPA2020.html#6907" class="Bound">p</a> <a id="6909" class="Symbol">:</a> <a id="6911" href="Cubical.Talks.EPA2020.html#5803" class="Datatype">S¹</a> <a id="6914" href="Cubical.Data.Prod.Base.html#645" class="Datatype Operator">×</a> <a id="6916" href="Cubical.Talks.EPA2020.html#5803" class="Datatype">S¹</a><a id="6918" class="Symbol">)</a> <a id="6920" class="Symbol">→</a> <a id="6922" href="Cubical.Talks.EPA2020.html#6428" class="Function">t2c</a> <a id="6926" class="Symbol">(</a><a id="6927" href="Cubical.Talks.EPA2020.html#6591" class="Function">c2t</a> <a id="6931" href="Cubical.Talks.EPA2020.html#6907" class="Bound">p</a><a id="6932" class="Symbol">)</a> <a id="6934" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="6936" href="Cubical.Talks.EPA2020.html#6907" class="Bound">p</a>
<a id="6938" href="Cubical.Talks.EPA2020.html#6896" class="Function">t2c-c2t</a> <a id="6946" class="Symbol">(</a><a id="6947" href="Cubical.Talks.EPA2020.html#5821" class="InductiveConstructor">base</a>   <a id="6954" href="Cubical.Data.Prod.Base.html#704" class="InductiveConstructor Operator">,</a> <a id="6956" href="Cubical.Talks.EPA2020.html#5821" class="InductiveConstructor">base</a><a id="6960" class="Symbol">)</a>   <a id="6964" class="Symbol">=</a> <a id="6966" href="Cubical.Foundations.Prelude.html#892" class="Function">refl</a>
<a id="6971" href="Cubical.Talks.EPA2020.html#6896" class="Function">t2c-c2t</a> <a id="6979" class="Symbol">(</a><a id="6980" href="Cubical.Talks.EPA2020.html#5821" class="InductiveConstructor">base</a>   <a id="6987" href="Cubical.Data.Prod.Base.html#704" class="InductiveConstructor Operator">,</a> <a id="6989" href="Cubical.Talks.EPA2020.html#5833" class="InductiveConstructor">loop</a> <a id="6994" class="Symbol">_)</a> <a id="6997" class="Symbol">=</a> <a id="6999" href="Cubical.Foundations.Prelude.html#892" class="Function">refl</a>
<a id="7004" href="Cubical.Talks.EPA2020.html#6896" class="Function">t2c-c2t</a> <a id="7012" class="Symbol">(</a><a id="7013" href="Cubical.Talks.EPA2020.html#5833" class="InductiveConstructor">loop</a> <a id="7018" class="Symbol">_</a> <a id="7020" href="Cubical.Data.Prod.Base.html#704" class="InductiveConstructor Operator">,</a> <a id="7022" href="Cubical.Talks.EPA2020.html#5821" class="InductiveConstructor">base</a><a id="7026" class="Symbol">)</a>   <a id="7030" class="Symbol">=</a> <a id="7032" href="Cubical.Foundations.Prelude.html#892" class="Function">refl</a>
<a id="7037" href="Cubical.Talks.EPA2020.html#6896" class="Function">t2c-c2t</a> <a id="7045" class="Symbol">(</a><a id="7046" href="Cubical.Talks.EPA2020.html#5833" class="InductiveConstructor">loop</a> <a id="7051" class="Symbol">_</a> <a id="7053" href="Cubical.Data.Prod.Base.html#704" class="InductiveConstructor Operator">,</a> <a id="7055" href="Cubical.Talks.EPA2020.html#5833" class="InductiveConstructor">loop</a> <a id="7060" class="Symbol">_)</a> <a id="7063" class="Symbol">=</a> <a id="7065" href="Cubical.Foundations.Prelude.html#892" class="Function">refl</a>

<a id="7071" class="Comment">-- Using univalence we get the following equality:</a>
<a id="Torus≡S¹×S¹"></a><a id="7122" href="Cubical.Talks.EPA2020.html#7122" class="Function">Torus≡S¹×S¹</a> <a id="7134" class="Symbol">:</a> <a id="7136" href="Cubical.Talks.EPA2020.html#6239" class="Datatype">Torus</a> <a id="7142" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="7144" href="Cubical.Talks.EPA2020.html#5803" class="Datatype">S¹</a> <a id="7147" href="Cubical.Data.Prod.Base.html#645" class="Datatype Operator">×</a> <a id="7149" href="Cubical.Talks.EPA2020.html#5803" class="Datatype">S¹</a>
<a id="7152" href="Cubical.Talks.EPA2020.html#7122" class="Function">Torus≡S¹×S¹</a> <a id="7164" class="Symbol">=</a> <a id="7166" href="Cubical.Talks.EPA2020.html#3322" class="Function">isoToPath&#39;</a> <a id="7177" class="Symbol">(</a><a id="7178" href="Cubical.Foundations.Isomorphism.html#840" class="InductiveConstructor">iso</a> <a id="7182" href="Cubical.Talks.EPA2020.html#6428" class="Function">t2c</a> <a id="7186" href="Cubical.Talks.EPA2020.html#6591" class="Function">c2t</a> <a id="7190" href="Cubical.Talks.EPA2020.html#6896" class="Function">t2c-c2t</a> <a id="7198" href="Cubical.Talks.EPA2020.html#6743" class="Function">c2t-t2c</a><a id="7205" class="Symbol">)</a>


<a id="windingTorus"></a><a id="7209" href="Cubical.Talks.EPA2020.html#7209" class="Function">windingTorus</a> <a id="7222" class="Symbol">:</a> <a id="7224" href="Cubical.Talks.EPA2020.html#6260" class="InductiveConstructor">point</a> <a id="7230" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="7232" href="Cubical.Talks.EPA2020.html#6260" class="InductiveConstructor">point</a> <a id="7238" class="Symbol">→</a> <a id="7240" href="Cubical.Data.Int.Base.html#419" class="Datatype">ℤ</a> <a id="7242" href="Cubical.Data.Prod.Base.html#645" class="Datatype Operator">×</a> <a id="7244" href="Cubical.Data.Int.Base.html#419" class="Datatype">ℤ</a>
<a id="7246" href="Cubical.Talks.EPA2020.html#7209" class="Function">windingTorus</a> <a id="7259" href="Cubical.Talks.EPA2020.html#7259" class="Bound">l</a> <a id="7261" class="Symbol">=</a> <a id="7263" class="Symbol">(</a> <a id="7265" href="Cubical.Talks.EPA2020.html#6086" class="Function">winding</a> <a id="7273" class="Symbol">(λ</a> <a id="7276" href="Cubical.Talks.EPA2020.html#7276" class="Bound">i</a> <a id="7278" class="Symbol">→</a> <a id="7280" href="Cubical.Data.Prod.Base.html#739" class="Function">proj₁</a> <a id="7286" class="Symbol">(</a><a id="7287" href="Cubical.Talks.EPA2020.html#6428" class="Function">t2c</a> <a id="7291" class="Symbol">(</a><a id="7292" href="Cubical.Talks.EPA2020.html#7259" class="Bound">l</a> <a id="7294" href="Cubical.Talks.EPA2020.html#7276" class="Bound">i</a><a id="7295" class="Symbol">)))</a>
                 <a id="7316" href="Cubical.Data.Prod.Base.html#704" class="InductiveConstructor Operator">,</a> <a id="7318" href="Cubical.Talks.EPA2020.html#6086" class="Function">winding</a> <a id="7326" class="Symbol">(λ</a> <a id="7329" href="Cubical.Talks.EPA2020.html#7329" class="Bound">i</a> <a id="7331" class="Symbol">→</a> <a id="7333" href="Cubical.Data.Prod.Base.html#805" class="Function">proj₂</a> <a id="7339" class="Symbol">(</a><a id="7340" href="Cubical.Talks.EPA2020.html#6428" class="Function">t2c</a> <a id="7344" class="Symbol">(</a><a id="7345" href="Cubical.Talks.EPA2020.html#7259" class="Bound">l</a> <a id="7347" href="Cubical.Talks.EPA2020.html#7329" class="Bound">i</a><a id="7348" class="Symbol">))))</a>

<a id="7354" href="Cubical.Talks.EPA2020.html#7354" class="Function">_</a> <a id="7356" class="Symbol">:</a> <a id="7358" href="Cubical.Talks.EPA2020.html#7209" class="Function">windingTorus</a> <a id="7371" class="Symbol">(</a><a id="7372" href="Cubical.Talks.EPA2020.html#6276" class="InductiveConstructor">line1</a> <a id="7378" href="Cubical.Foundations.Prelude.html#5184" class="Function Operator">∙</a> <a id="7380" href="Cubical.Foundations.Prelude.html#945" class="Function">sym</a> <a id="7384" href="Cubical.Talks.EPA2020.html#6300" class="InductiveConstructor">line2</a><a id="7389" class="Symbol">)</a> <a id="7391" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="7393" class="Symbol">(</a><a id="7394" href="Cubical.Data.Int.Base.html#437" class="InductiveConstructor">pos</a> <a id="7398" class="Number">1</a> <a id="7400" class="InductiveConstructor Operator">,</a> <a id="7402" href="Cubical.Data.Int.Base.html#460" class="InductiveConstructor">negsuc</a> <a id="7409" class="Number">0</a><a id="7410" class="Symbol">)</a>
<a id="7412" class="Symbol">_</a> <a id="7414" class="Symbol">=</a> <a id="7416" href="Cubical.Foundations.Prelude.html#892" class="Function">refl</a>

<a id="7422" class="Comment">-- We have many more topological examples, including Klein bottle, RP^n,</a>
<a id="7495" class="Comment">-- higher spheres, suspensions, join, wedges, smash product:</a>
<a id="7556" class="Keyword">open</a> <a id="7561" class="Keyword">import</a> <a id="7568" href="Cubical.HITs.KleinBottle.html" class="Module">Cubical.HITs.KleinBottle</a>
<a id="7593" class="Keyword">open</a> <a id="7598" class="Keyword">import</a> <a id="7605" href="Cubical.HITs.RPn.html" class="Module">Cubical.HITs.RPn</a>
<a id="7622" class="Keyword">open</a> <a id="7627" class="Keyword">import</a> <a id="7634" href="Cubical.HITs.S2.html" class="Module">Cubical.HITs.S2</a>
<a id="7650" class="Keyword">open</a> <a id="7655" class="Keyword">import</a> <a id="7662" href="Cubical.HITs.S3.html" class="Module">Cubical.HITs.S3</a>
<a id="7678" class="Keyword">open</a> <a id="7683" class="Keyword">import</a> <a id="7690" href="Cubical.HITs.Susp.html" class="Module">Cubical.HITs.Susp</a>
<a id="7708" class="Keyword">open</a> <a id="7713" class="Keyword">import</a> <a id="7720" href="Cubical.HITs.Join.html" class="Module">Cubical.HITs.Join</a>
<a id="7738" class="Keyword">open</a> <a id="7743" class="Keyword">import</a> <a id="7750" href="Cubical.HITs.Wedge.html" class="Module">Cubical.HITs.Wedge</a>
<a id="7769" class="Keyword">open</a> <a id="7774" class="Keyword">import</a> <a id="7781" href="Cubical.HITs.SmashProduct.html" class="Module">Cubical.HITs.SmashProduct</a>

<a id="7808" class="Comment">-- There&#39;s also a proof of the &quot;3x3 lemma&quot; for pushouts in less than</a>
<a id="7877" class="Comment">-- 200LOC. In HoTT-Agda this took about 3000LOC. For details see:</a>
<a id="7943" class="Comment">-- https://github.com/HoTT/HoTT-Agda/tree/master/theorems/homotopy/3x3</a>
<a id="8014" class="Keyword">open</a> <a id="8019" class="Keyword">import</a> <a id="8026" href="Cubical.HITs.Pushout.html" class="Module">Cubical.HITs.Pushout</a>

<a id="8048" class="Comment">-- We also defined the Hopf fibration and proved that its total space</a>
<a id="8118" class="Comment">-- is S³ in about 300LOC:</a>
<a id="8144" class="Keyword">open</a> <a id="8149" class="Keyword">import</a> <a id="8156" href="Cubical.Homotopy.Hopf.html" class="Module">Cubical.Homotopy.Hopf</a>
<a id="8178" class="Keyword">open</a> <a id="8183" href="Cubical.Homotopy.Hopf.html#14695" class="Module">S¹Hopf</a>

<a id="8191" class="Comment">-- There is also some integer cohomology in Cubical.ZCohomology.</a>
<a id="8256" class="Comment">-- To compute cohomology groups of various spaces we need a bunch of</a>
<a id="8325" class="Comment">-- interesting theorems: Freudenthal suspension theorem,</a>
<a id="8382" class="Comment">-- Mayer-Vietoris sequence...</a>
<a id="8412" class="Keyword">open</a> <a id="8417" class="Keyword">import</a> <a id="8424" href="Cubical.Homotopy.Freudenthal.html" class="Module">Cubical.Homotopy.Freudenthal</a>
<a id="8453" class="Keyword">open</a> <a id="8458" class="Keyword">import</a> <a id="8465" href="Cubical.ZCohomology.MayerVietorisUnreduced.html" class="Module">Cubical.ZCohomology.MayerVietorisUnreduced</a>


<a id="8510" class="Comment">-------------------------------------------------------------------------</a>
<a id="8584" class="Comment">-- The structure identity principle</a>

<a id="8621" class="Comment">-- A more efficient version of finite multisets based on association lists</a>
<a id="8696" class="Keyword">open</a> <a id="8701" class="Keyword">import</a> <a id="8708" href="Cubical.HITs.AssocList.Base.html" class="Module">Cubical.HITs.AssocList.Base</a>

<a id="8737" class="Comment">-- data AssocList (A : Type) : Type where</a>
<a id="8779" class="Comment">--  ⟨⟩ : AssocList A</a>
<a id="8800" class="Comment">--  ⟨_,_⟩∷_ : (a : A) (n : ℕ) (xs : AssocList A) → AssocList A</a>
<a id="8863" class="Comment">--  per : (a b : A) (m n : ℕ) (xs : AssocList A)</a>
<a id="8912" class="Comment">--      → ⟨ a , m ⟩∷ ⟨ b , n ⟩∷ xs ≡ ⟨ b , n ⟩∷ ⟨ a , m ⟩∷ xs</a>
<a id="8974" class="Comment">--  agg : (a : A) (m n : ℕ) (xs : AssocList A)</a>
<a id="9021" class="Comment">--      → ⟨ a , m ⟩∷ ⟨ a , n ⟩∷ xs ≡ ⟨ a , m + n ⟩∷ xs</a>
<a id="9076" class="Comment">--  del : (a : A) (xs : AssocList A) → ⟨ a , 0 ⟩∷ xs ≡ xs</a>
<a id="9134" class="Comment">--  trunc : (xs ys : AssocList A) (p q : xs ≡ ys) → p ≡ q</a>


<a id="9194" class="Comment">-- Programming and proving is more complicated with AssocList compared</a>
<a id="9265" class="Comment">-- to FMSet. This kind of example occurs everywhere in programming and</a>
<a id="9336" class="Comment">-- mathematics: one representation is easier to work with, but not</a>
<a id="9403" class="Comment">-- efficient, while another is efficient but difficult to work with.</a>

<a id="9473" class="Comment">-- Solution: substitute using univalence</a>
<a id="substIso"></a><a id="9514" href="Cubical.Talks.EPA2020.html#9514" class="Function">substIso</a> <a id="9523" class="Symbol">:</a> <a id="9525" class="Symbol">{</a><a id="9526" href="Cubical.Talks.EPA2020.html#9526" class="Bound">A</a> <a id="9528" href="Cubical.Talks.EPA2020.html#9528" class="Bound">B</a> <a id="9530" class="Symbol">:</a> <a id="9532" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="9536" class="Symbol">}</a> <a id="9538" class="Symbol">(</a><a id="9539" href="Cubical.Talks.EPA2020.html#9539" class="Bound">P</a> <a id="9541" class="Symbol">:</a> <a id="9543" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="9548" class="Symbol">→</a> <a id="9550" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="9554" class="Symbol">)</a> <a id="9556" class="Symbol">(</a><a id="9557" href="Cubical.Talks.EPA2020.html#9557" class="Bound">e</a> <a id="9559" class="Symbol">:</a> <a id="9561" href="Cubical.Foundations.Isomorphism.html#744" class="Record">Iso</a> <a id="9565" href="Cubical.Talks.EPA2020.html#9526" class="Bound">A</a> <a id="9567" href="Cubical.Talks.EPA2020.html#9528" class="Bound">B</a><a id="9568" class="Symbol">)</a> <a id="9570" class="Symbol">→</a> <a id="9572" href="Cubical.Talks.EPA2020.html#9539" class="Bound">P</a> <a id="9574" href="Cubical.Talks.EPA2020.html#9526" class="Bound">A</a> <a id="9576" class="Symbol">→</a> <a id="9578" href="Cubical.Talks.EPA2020.html#9539" class="Bound">P</a> <a id="9580" href="Cubical.Talks.EPA2020.html#9528" class="Bound">B</a>
<a id="9582" href="Cubical.Talks.EPA2020.html#9514" class="Function">substIso</a> <a id="9591" href="Cubical.Talks.EPA2020.html#9591" class="Bound">P</a> <a id="9593" href="Cubical.Talks.EPA2020.html#9593" class="Bound">e</a> <a id="9595" class="Symbol">=</a> <a id="9597" href="Cubical.Foundations.Prelude.html#10205" class="Function">subst</a> <a id="9603" href="Cubical.Talks.EPA2020.html#9591" class="Bound">P</a> <a id="9605" class="Symbol">(</a><a id="9606" href="Cubical.Foundations.Isomorphism.html#3691" class="Function">isoToPath</a> <a id="9616" href="Cubical.Talks.EPA2020.html#9593" class="Bound">e</a><a id="9617" class="Symbol">)</a>

<a id="9620" class="Comment">-- Can transport for example Monoid structure from FMSet to AssocList</a>
<a id="9690" class="Comment">-- this way, but the achieved Monoid structure is not very efficient</a>
<a id="9759" class="Comment">-- to work with. A better solution is to prove that FMSet and</a>
<a id="9821" class="Comment">-- AssocList are equal *as monoids*, but how to do this?</a>

<a id="9879" class="Comment">-- Solution: structure identity principle (SIP)</a>
<a id="9927" class="Comment">-- This is a very useful consequence of univalence</a>
<a id="9978" class="Keyword">open</a> <a id="9983" class="Keyword">import</a> <a id="9990" href="Cubical.Foundations.SIP.html" class="Module">Cubical.Foundations.SIP</a>

<a id="sip&#39;"></a><a id="10015" href="Cubical.Talks.EPA2020.html#10015" class="Function">sip&#39;</a> <a id="10020" class="Symbol">:</a> <a id="10022" class="Symbol">{</a><a id="10023" href="Cubical.Talks.EPA2020.html#10023" class="Bound">ℓ</a> <a id="10025" class="Symbol">:</a> <a id="10027" href="Agda.Primitive.html#742" class="Postulate">Level</a><a id="10032" class="Symbol">}</a> <a id="10034" class="Symbol">{</a><a id="10035" href="Cubical.Talks.EPA2020.html#10035" class="Bound">S</a> <a id="10037" class="Symbol">:</a> <a id="10039" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="10044" href="Cubical.Talks.EPA2020.html#10023" class="Bound">ℓ</a> <a id="10046" class="Symbol">→</a> <a id="10048" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="10053" href="Cubical.Talks.EPA2020.html#10023" class="Bound">ℓ</a><a id="10054" class="Symbol">}</a> <a id="10056" class="Symbol">{</a><a id="10057" href="Cubical.Talks.EPA2020.html#10057" class="Bound">ι</a> <a id="10059" class="Symbol">:</a> <a id="10061" href="Cubical.Foundations.Structure.html#1565" class="Function">StrEquiv</a> <a id="10070" href="Cubical.Talks.EPA2020.html#10035" class="Bound">S</a> <a id="10072" href="Cubical.Talks.EPA2020.html#10023" class="Bound">ℓ</a><a id="10073" class="Symbol">}</a>
       <a id="10082" class="Symbol">(</a><a id="10083" href="Cubical.Talks.EPA2020.html#10083" class="Bound">θ</a> <a id="10085" class="Symbol">:</a> <a id="10087" href="Cubical.Foundations.SIP.html#1640" class="Function">UnivalentStr</a> <a id="10100" href="Cubical.Talks.EPA2020.html#10035" class="Bound">S</a> <a id="10102" href="Cubical.Talks.EPA2020.html#10057" class="Bound">ι</a><a id="10103" class="Symbol">)</a> <a id="10105" class="Symbol">(</a><a id="10106" href="Cubical.Talks.EPA2020.html#10106" class="Bound">A</a> <a id="10108" href="Cubical.Talks.EPA2020.html#10108" class="Bound">B</a> <a id="10110" class="Symbol">:</a> <a id="10112" href="Cubical.Foundations.Structure.html#378" class="Function">TypeWithStr</a> <a id="10124" href="Cubical.Talks.EPA2020.html#10023" class="Bound">ℓ</a> <a id="10126" href="Cubical.Talks.EPA2020.html#10035" class="Bound">S</a><a id="10127" class="Symbol">)</a> <a id="10129" class="Symbol">→</a> <a id="10131" href="Cubical.Talks.EPA2020.html#10106" class="Bound">A</a> <a id="10133" href="Cubical.Foundations.SIP.html#1400" class="Function Operator">≃[</a> <a id="10136" href="Cubical.Talks.EPA2020.html#10057" class="Bound">ι</a> <a id="10138" href="Cubical.Foundations.SIP.html#1400" class="Function Operator">]</a> <a id="10140" href="Cubical.Talks.EPA2020.html#10108" class="Bound">B</a> <a id="10142" class="Symbol">→</a> <a id="10144" href="Cubical.Talks.EPA2020.html#10106" class="Bound">A</a> <a id="10146" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">≡</a> <a id="10148" href="Cubical.Talks.EPA2020.html#10108" class="Bound">B</a>
<a id="10150" href="Cubical.Talks.EPA2020.html#10015" class="Function">sip&#39;</a> <a id="10155" class="Symbol">=</a> <a id="10157" href="Cubical.Foundations.SIP.html#4291" class="Function">sip</a>

<a id="10162" class="Comment">-- The tricky thing is to prove that (S,ι) is a univalent structure.</a>
<a id="10231" class="Comment">-- Luckily we provide automation for this in the library, see for example:</a>
<a id="10306" class="Keyword">open</a> <a id="10311" class="Keyword">import</a> <a id="10318" href="Cubical.Algebra.Monoid.Base.html" class="Module">Cubical.Algebra.Monoid.Base</a>

<a id="10347" class="Comment">-- Another cool application of the SIP: matrices represented as</a>
<a id="10411" class="Comment">-- functions out of pairs of Fin&#39;s and vectors are equal as abelian</a>
<a id="10479" class="Comment">-- groups:</a>
<a id="10490" class="Keyword">open</a> <a id="10495" class="Keyword">import</a> <a id="10502" href="Cubical.Algebra.Matrix.html" class="Module">Cubical.Algebra.Matrix</a>


<a id="10527" class="Comment">-- The end, back to slides!</a>
</pre></body></html>