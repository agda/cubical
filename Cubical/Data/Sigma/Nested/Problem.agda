{-

This file is included only temporarly to show problems

I plan to remove it before final pull request (or maybe move it to the experiments folder?)

-}

{-# OPTIONS --cubical --no-import-sorts --safe #-}

module Cubical.Data.Sigma.Nested.Problem where

open import Cubical.Data.Nat

open import Cubical.Data.Bool
open import Cubical.Data.Sigma
open import Cubical.Data.Vec
open import Cubical.Data.List

open import Cubical.Foundations.Everything

open import Cubical.Data.Sigma.Nested.Base
open import Cubical.Data.Sigma.Nested.Nested
open import Cubical.Data.Sigma.Nested.Currying
open import Cubical.Data.Sigma.Nested.Path

-- -- (Cube, is chosen as example to illustrate extracting only becouse it is example of
-- --  function with lots of implicit and explicit arguments)

{-

extract-Test1 : Type₀ → Sig ℓ-zero 26
extract-Test1 A = extractSig (0 ∷ 8 ∷ 1 ∷ 8 ∷ 1 ∷ 2 ∷ 1 ∷ 2 ∷ 3 ∷ [])
                        (λ {y} {y1} {y2} {y3} {y4} {y5} {y6} {y7} →
                             Cube {A = A} {y} {y1} {y2} {y3} {y4} {y5} {y6} {y7})


-- type of holes mention fst, and snd a lot, but
-- C-u C-u C-c C-, is clearing everytihng


extracted-Test : ∀ A → NestedΣᵣ (extract-Test1 A)
extracted-Test A = {!!} , {!!} , {!!} , {!!} , {!!} , {!!} , {!!} , {!!} , {!!}
                   , {!!} , {!!} , {!!} , {!!} , {!!} , {!!} , {!!} , {!!} , {!!}
                   , {!!} , {!!} , {!!} , {!!} , {!!} , {!!} , {!!} , {!!}

-}


-- -- some problem with this implementations force us to write first
-- -- string of implicit arguemnts ( (y, y1 ,y2...) in the definition of extracted-Test1)
-- -- by hand

-- -- note that after the initial string of 8 implicit arguments,
-- -- strings of arguments are changed back and forth from implicit and explicit, and
-- -- everything works


-- -- On the other side:
-- -- in this definition of Cube, only te explicity of first argument is changed from explicit to
-- -- implicit, and now the signature can be fully extracted by extractSig function

Cube-first-explicit : {A : Type₀} →
-- ↓ this argument is explicit in this example
  (a₀₀₀ : A) → {a₀₀₁ : A} {a₀₀₋ : a₀₀₀ ≡ a₀₀₁}
  {a₀₁₀ a₀₁₁ : A} {a₀₁₋ : a₀₁₀ ≡ a₀₁₁}
  {a₀₋₀ : a₀₀₀ ≡ a₀₁₀} {a₀₋₁ : a₀₀₁ ≡ a₀₁₁}
  (a₀₋₋ : Square a₀₀₋ a₀₁₋ a₀₋₀ a₀₋₁)
  {a₁₀₀ a₁₀₁ : A} {a₁₀₋ : a₁₀₀ ≡ a₁₀₁}
  {a₁₁₀ a₁₁₁ : A} {a₁₁₋ : a₁₁₀ ≡ a₁₁₁}
  {a₁₋₀ : a₁₀₀ ≡ a₁₁₀} {a₁₋₁ : a₁₀₁ ≡ a₁₁₁}
  (a₁₋₋ : Square a₁₀₋ a₁₁₋ a₁₋₀ a₁₋₁)
  {a₋₀₀ : a₀₀₀ ≡ a₁₀₀} {a₋₀₁ : a₀₀₁ ≡ a₁₀₁}
  (a₋₀₋ : Square a₀₀₋ a₁₀₋ a₋₀₀ a₋₀₁)
  {a₋₁₀ : a₀₁₀ ≡ a₁₁₀} {a₋₁₁ : a₀₁₁ ≡ a₁₁₁}
  (a₋₁₋ : Square a₀₁₋ a₁₁₋ a₋₁₀ a₋₁₁)
  (a₋₋₀ : Square a₀₋₀ a₁₋₀ a₋₀₀ a₋₁₀)
  (a₋₋₁ : Square a₀₋₁ a₁₋₁ a₋₀₁ a₋₁₁)
  → Type _
Cube-first-explicit a₀₀₀ = Cube {a₀₀₀ = a₀₀₀}

extract-Test2 : Type₀ → Sig ℓ-zero 26
extract-Test2 A = extractSig (1 ∷ 7 ∷ 1 ∷ 8 ∷ 1 ∷ 2 ∷ 1 ∷ 2 ∷ 3 ∷ [])
                        (Cube-first-explicit {A = A})


-- to uncury Cube it is sufficient to provide the explicity of arguments (and indirectly their number)

uncurried-Cube : (A : Type₀) → _ → Type₀
                           --  ↑ this nested sigma do not containt any unwanted artefacts
                           -- it is large but clear
uncurried-Cube A = n-uncurryᵣ-conf (impex (1 ∷ 7 ∷ 1 ∷ 8 ∷ 1 ∷ 2 ∷ 1 ∷ 2 ∷ 3 ∷ []))
                     _ ((Cube-first-explicit {A = A}))


-- holes in the argument of uncurried Cube, are in normal form even without using C-u C-u C-c C-,
-- i am not shure why it is not the case for NestedΣ in singature generated by extractSig

{-
uncurried-Cube-test : (A : Type₀) → _
uncurried-Cube-test A = uncurried-Cube A
                          ( {!!} , {!!} , {!!} , {!!} , {!!} , {!!} , {!!} , {!!} , {!!}
                         , {!!} , {!!} , {!!} , {!!} , {!!} , {!!} , {!!} , {!!} , {!!}
                         , {!!} , {!!} , {!!} , {!!} , {!!} , {!!} , {!!} , {!!})
-}




-- i think that the similiar problem is manifested here:

-- (there is simple fix to this, implemented at this moment in the Path.agda
-- but it requires Type ℓ argument, A to be explicit )

-- those definitions typecheck properly:

Square'' : ∀ {ℓ} → {A : Type ℓ} → toTypeFamTy (pathⁿ-args-desc 2) (NCubeSig 2 A)
Square'' = Square

Square''' : ∀ {ℓ} → {A : Type ℓ} → toTypeFamTy (pathⁿ-args-desc 2) (NCubeSig 2 A)
Square''' {A = A} {a} = toTypeFam (pathⁿ-args-desc 2) (NCubeSig 2 A) {a}

Cube'' : ∀ {ℓ} → {A : Type ℓ} → toTypeFamTy (pathⁿ-args-desc 3) (NCubeSig 3 A)
Cube'' = Cube

Cube''' : ∀ {ℓ} → {A : Type ℓ} → toTypeFamTy (pathⁿ-args-desc 3) (NCubeSig 3 A)
Cube''' {A = A} {a} = toTypeFam (pathⁿ-args-desc 3) (NCubeSig 3 A) {a}

-- but this do not work (agda complains about unsolved metas)

{-
do-not-work-Square : ∀ {ℓ} → {A : Type ℓ} →  Square'' {ℓ} {A} ≡ Square''' {ℓ} {A}
do-not-work-Square = refl

do-not-work-Cube : ∀ {ℓ} → {A : Type ℓ} → Cube'' {ℓ} {A} ≡ Cube''' {ℓ} {A}
do-not-work-Cube = refl
-}
