Principal Ideals
----------------

<!--
```
{-# OPTIONS --cubical --no-import-sorts --safe #-}
module Cubical.Algebra.CommRing.PrincipalIdeal where

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Powerset
open import Cubical.Foundations.HLevels

open import Cubical.Data.Sigma

open import Cubical.HITs.PropositionalTruncation

open import Cubical.Algebra.CommRing
open import Cubical.Algebra.Ring
open import Cubical.Algebra.Ring.Ideal
open import Cubical.Algebra.Ring.QuotientRing

private
  variable
    ℓ : Level
```
-->

A principal ideal is an ideal generated by an element of a ring.
Let us fix a commutative ring and an element:

```
module _ ((R , str) : CommRing {ℓ}) (r : R) where
   open CommRingStr str
   isSetR = isSetCommRing (R , str)
```
The principal ideal generated by 'r' is the subset of 'R' consisting of all multiples of 'r'.

```
   LPrincipalIdeal : R → hProp ℓ
   LPrincipalIdeal x = ∥ Σ[ y ∈ R ] x ≡ y · r ∥ , propTruncIsProp
```

Let us write '⟨ r ⟩i' for the principal ideal generated by r:

```
⟨_⟩i : ⦃(R , _) : CommRing {ℓ}⦄ → R → R → hProp ℓ
⟨_⟩i {{R}} r = LPrincipalIdeal R r
```
Now we prove that this is indeed an ideal:

```
module _ {(R , str) : CommRing {ℓ}} where
  private
    instance
      _ : CommRing {ℓ}
      _ = (R , str)
  isIdealPrincipalIdeal : (r : R) → isIdeal (CommRing→Ring (R , str)) ⟨ r ⟩i
  isIdealPrincipalIdeal r =
    let open CommRingStr str
        open Theory (CommRing→Ring (R , str))
    in record
      { +-closed = elim (λ _ → isOfHLevelΠ 1 (λ _ → propTruncIsProp))
                   -- somehow elim2 does not work here
                        (λ {(a , x≡a·r) →
                          elim (λ _ → propTruncIsProp)
                               λ {(b , y≡b·r) →
                                ∣ (a + b) ,
                                   (_ + _            ≡[ i ]⟨ x≡a·r i + y≡b·r i ⟩
                                   (a · r) + (b · r) ≡⟨ sym (·Ldist+ _ _ _) ⟩
                                   (a + b) · r ∎) ∣ }})
      ; -closed = elim (λ _ → propTruncIsProp)
                       (λ {(a , x≡a·r) →
                         ∣ (- a) , ( _          ≡⟨  cong (-_) x≡a·r ⟩
                                      - (a · r)  ≡⟨  sym (-DistL· _ _) ⟩
                                      (- a) · r ∎) ∣})
      ; 0r-closed = ∣ 0r , (sym (0LeftAnnihilates _)) ∣
      ; ·-closedLeft = λ s → elim (λ _ → propTruncIsProp)
                                  λ {(a , x≡a·r) → ∣ (s · a) ,
                                                      (s · _       ≡[ i ]⟨ s · (x≡a·r i) ⟩
                                                       s · (a · r) ≡⟨ ·Assoc _ _ _ ⟩
                                                       (s · a) · r ∎) ∣}
      ; ·-closedRight = λ s → elim (λ _ → propTruncIsProp)
                                  λ {(a , x≡a·r) → ∣ (a · s) ,
                                                      (_ · s       ≡[ i ]⟨ (x≡a·r i) · s ⟩
                                                       (a · r) · s ≡⟨ sym (·Assoc _ _ _) ⟩
                                                       a · (r · s) ≡[ i ]⟨ a · (·-comm r s  i) ⟩
                                                       a · (s · r) ≡⟨ ·Assoc _ _ _ ⟩
                                                       (a · s) · r ∎) ∣}
      }

  principalIdeal : (a : R) → IdealsIn (CommRing→Ring (R , str))
  principalIdeal a = ⟨ a ⟩i , isIdealPrincipalIdeal a
```

The Quotient by a principal ideal has a universal property:

```
  module _ {a : R} where
    Q = (CommRing→Ring (R , str)) / (principalIdeal a)

    module _ {(S , strS) : CommRing {ℓ}} where
      open CommRingStr {{...}}
      R′ = CommRing→Ring (R , str)
      S′ = CommRing→Ring (S , strS)
      private
        instance
          _ : CommRingStr R
          _ = str
          _ : CommRingStr S
          _ = strS

      inducedMap : (f : RingHom R′ S′)
                   → f $ a ≡ CommRingStr.0r strS
                   → RingHom Q S′
      inducedMap fHom eq =
        let open UniversalProperty R′ (principalIdeal a)
            open RingHom fHom renaming (map to f)
            open Theory S′
        in inducedHom
             fHom
             λ r → elim (λ r∈⟨a⟩ → isSetCommRing (S , strS) (f r) (CommRingStr.0r strS))
                         λ {(x , r≡x·a) →
                               f r                        ≡⟨ cong f r≡x·a ⟩
                               f (x · a)                  ≡⟨ isHom· x a ⟩
                               f x · f a                  ≡[ i ]⟨ f x · (eq i) ⟩
                               f x · CommRingStr.0r strS  ≡⟨ 0RightAnnihilates (f x) ⟩
                               CommRingStr.0r strS ∎}
```
