{-

This module provides an implementation that can be perceived as a free monoidal groupoid generated by terms. It works under the assumption that there is only one interval variable in the context and that terms are free of composition operations. The core functionality involves decomposing terms and traversing them to identify subterms containing interval variables. These subterms are then marked as "paths" by wrapping them into temporary definitions.

### Steps

- **Path Identification**: Identifies subterms containing interval variables and marks them as "paths."
- **Term Wrapping**: Wraps identified "path" subterms into temporary definitions (`PathWrap`, `FillWrap`, `CompWrap`).
- **Normalization**: Treats terms with multiple subterms identified as "paths" as functors applied to the product of these subterms. Terms prepared in that way can be normalized according to monoidal-groupoid laws, generalizing the `congâ‚‚Funct` lemma from the `Foundations.GroupoidLaws` module.


### Specialized Definitions Used only temporairly as markers during processing AST

- **`ASTMarkers`**: Defines markers for `PathWrap`, `FillWrap`, and `CompWrap`.
- **Term Patterns**: Various term patterns (`fw`, `pw`, `cwd`, etc.) are used for identifying and manipulating wrapped terms.


### Utilities**
Functions like `intervalTest`, `transpose`, and `reduceComps` are utility functions aiding the main functionalities.

At the end, whole process is wrapped into _â†™_ operator, which can be seen as analogue of `compPath-filler` from prelude, but operating only on already normalised paths, and with composition operation resulting in "normalised" path according to monoidal-groipoid laws.

-}

{-# OPTIONS --safe -v testMarkVert:3 -v tactic:3 #-}

module Cubical.Tactics.PathSolver.MonoidalSolver.PathEval where

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Structure
open import Cubical.Foundations.Function

open import Cubical.Relation.Nullary

open import Cubical.Data.Bool
open import Cubical.Data.Empty
open import Cubical.Data.Sum as âŠ
open import Cubical.Data.Maybe as Mb
open import Cubical.Data.List as L
open import Cubical.Data.Nat as â„•

open import Cubical.Data.Sigma.Base


open import Cubical.Reflection.Base renaming (v to ğ’—)
open import Cubical.Reflection.Sugar
open import Agda.Builtin.Nat using () renaming (_==_ to _=â„•_ ; _<_ to _<â„•_)

import Agda.Builtin.Reflection as R

open import Cubical.Tactics.PathSolver.Reflection
open import Cubical.Tactics.PathSolver.Path

open import Agda.Builtin.String

open import Cubical.Tactics.Reflection.Utilities
open import Cubical.Tactics.Reflection.Error
open import Cubical.Tactics.Reflection.Dimensions
open import Cubical.Tactics.Reflection.QuoteCubical


data ASTMarkers : Type where
 PathWrap' FillWrap' CompWrap' : ASTMarkers

PathWrap FillWrap CompWrap : ASTMarkers
PathWrap = PathWrap'
FillWrap = FillWrap'
CompWrap = CompWrap'

WTerm = R.Term
CTerm = R.Term


pattern fw[1,_] x = R.def (quote FillWrap) (R.lit (R.name (quote true)) vâˆ· v[ x ])
pattern fw[0,_] x = R.def (quote FillWrap) (R.lit (R.name (quote false)) vâˆ· v[ x ])


pattern pw[_] x = R.def (quote PathWrap) (x vâˆ· [])
pattern pwd args = R.def (quote PathWrap) args


pattern cwd args = R.def (quote CompWrap) args

pattern cw[] = R.def (quote CompWrap) []
pattern cw[_] x = R.def (quote CompWrap) (x vâˆ· [])
pattern cw xs = R.def (quote CompWrap) xs
pattern _âˆ·cw_ x xs = R.def (quote CompWrap) (x vâˆ· xs)


intervalTest : â„• â†’ R.Term â†’ Bool
intervalTest _ (R.def (quote _âˆ¨_) _) = true
intervalTest _ (R.def (quote _âˆ§_) _) = true
intervalTest _ (R.def (quote ~_) _) = true
intervalTest n (R.var k []) = n =â„• k
intervalTest _ _ = false


wrapPaths : R.Term â†’ WTerm
wrapPaths = atVarOrConM' f h g
 where
  f : â„• â†’ â„• â†’ List (R.Arg R.Term) â†’ Maybe R.Term
  f n v args =
     if any? (L.map (intervalTest n âˆ˜S unArg) args)
     then  just pw[ (R.var (v + n) args) ]
     else nothing

  h : â„• â†’ R.Name â†’ List (R.Arg R.Term) â†’ Maybe R.Term
  h n nm args =
     if any? (L.map (intervalTest n âˆ˜S unArg) args)
     then  just pw[ (R.con nm args) ]
     else nothing

  g : â„• â†’ R.Name â†’ List (R.Arg R.Term) â†’ Maybe R.Term
  g n nm args =
     if any? (L.map (intervalTest n âˆ˜S unArg) args)
     then  just pw[ (R.def nm args) ]
     else nothing

wrapFills : R.Term â†’ WTerm
wrapFills = atVarOrConM' f h g
 where
  f : â„• â†’ â„• â†’ List (R.Arg R.Term) â†’ Maybe R.Term
  f n v args =
     if any? (L.map (intervalTest n âˆ˜S unArg) args)
     then  just fw[1, pw[ (R.var (v + n) args) ] ]
     else nothing

  h : â„• â†’ R.Name â†’ List (R.Arg R.Term) â†’ Maybe R.Term
  h n nm args =
     if any? (L.map (intervalTest n âˆ˜S unArg) args)
     then  just fw[1, pw[ (R.con nm args) ] ]
     else nothing


  g : â„• â†’ R.Name â†’ List (R.Arg R.Term) â†’ Maybe R.Term
  g n nm args =
     if any? (L.map (intervalTest n âˆ˜S unArg) args)
     then  just fw[1, pw[ (R.def nm args) ] ]
     else nothing



dropPathWraps : CTerm â†’ R.Term
dropPathWraps = atVarOrDefM {{_}} {{RawMonadIdentityM}}
  (Î» _ v _ argsM â†’ R.var v argsM)
  Î» _ d _ argsM â†’ w (R.def d argsM)

 where
  w : R.Term â†’ R.Term
  w pw[ x ] = x
  w x = x


absorb : â„• â†’ WTerm â†’ CTerm â†’ R.TC CTerm


absorbStep : â„• â†’ WTerm â†’ WTerm â†’ R.TC (Maybe CTerm)
absorbStep n (cwd _) _ = R.typeError [ "cwd in absorbStep" ]â‚‘
absorbStep n _ (cwd _) = R.typeError [ "cwd in absorbStep" ]â‚‘
absorbStep zero pw[ x ] pw[ y ] = do
  -- R.debugPrint "testMarkVert" 3 $ "-----" âˆ·nl x âˆ·nl "** \n" âˆ·nl [ y ]â‚‘
  (if_then (just fw[0, y ]) else nothing) <$> unifyTest (suc zero) x (invVar zero y)
absorbStep (suc _) pw[ x ] pw[ y ] =
 R.typeError [ "absorbStep: todo - paths under abstraction" ]â‚‘
absorbStep n x pw[ y ] = pure nothing
absorbStep n pw[ x ] y = pure nothing
absorbStep n (pwd _) _ = R.typeError [ "pwd1 in absorbStep!" ]â‚‘
absorbStep n _ (pwd _) = R.typeError [ "pwd2 in absorbStep!" ]â‚‘
absorbStep n x y = just <$> h x y
 where

 hs : R.Sort â†’ R.Sort â†’ R.TC R.Sort
 h : WTerm â†’ WTerm â†’ R.TC CTerm

 ha : List (R.Arg R.Term) â†’ List (R.Arg R.Term) â†’ R.TC (List (R.Arg R.Term))
 ha [] [] = pure []
 ha (R.arg ax x âˆ· xs) (R.arg _ x' âˆ· xs')  =
   â¦‡ â¦‡ R.arg â¦‡ ax â¦ˆ (absorb n x x') â¦ˆ  âˆ· ha xs xs' â¦ˆ
 ha _ _ = R.typeError [ "absorbStep: ha-failed" ]â‚‘

 h (R.var x args) (R.var _ args') = R.var x <$> ha args args'
 h (R.con c args) (R.con _ args') = R.con c <$> ha args args'
 h (R.def f args) (R.def _ args') = R.def f <$> ha args args'
 h (R.lam v (R.abs ai t)) (R.lam v' (R.abs _ t')) =
    â¦‡ R.lam â¦‡ v â¦ˆ â¦‡ R.abs â¦‡ ai â¦ˆ (absorb (suc n) t t') â¦ˆ  â¦ˆ
 h (R.pat-lam cs args) (R.pat-lam cs' args') = R.typeError [ "absorbStep: todo - patLamb" ]â‚‘
 h (R.pi (R.arg ai a) (R.abs bi b)) (R.pi (R.arg ai' a') (R.abs bi' b')) =
     â¦‡ R.pi â¦‡ R.arg â¦‡ ai â¦ˆ (absorb n a a') â¦ˆ â¦‡ R.abs â¦‡ bi â¦ˆ (absorb (suc n) b b') â¦ˆ  â¦ˆ
 h (R.agda-sort s) (R.agda-sort s') = R.agda-sort <$> hs s s'
 h (R.lit l) (R.lit l') = pure (R.lit l)
 h (R.meta x xâ‚‚) (R.meta x' xâ‚‚') = R.typeError [ "absorbStep: todo - meta" ]â‚‘
 h R.unknown R.unknown = â¦‡ R.unknown â¦ˆ
 h t t' = R.typeError
   $ "absorbStep: h-failed" âˆ·nl t âˆ·nl "---" âˆ·nl [ t' ]â‚‘

 hs (R.set t) (R.set t') = R.set <$> absorb n t t'
 hs (R.lit n) (R.lit _) = pure (R.lit n)
 hs (R.prop t) (R.prop t') = R.prop <$> absorb n t t'
 hs (R.propLit n) (R.propLit n') = pure (R.propLit n)
 hs (R.inf n) (R.inf n') = pure (R.inf n)
 hs R.unknown R.unknown = pure (R.unknown)
 hs _ _ = R.typeError [ "absorbStep: hs-failed" ]â‚‘

absorbStep' : â„• â†’ WTerm â†’ WTerm â†’ R.TC (Maybe CTerm)
absorbStep' n x y =
  w (hasVar zero x) (hasVar zero y)

 where
  w : Bool â†’ Bool â†’ R.TC (Maybe CTerm)
  w true true = absorbStep n x y
  w true false = pure $ just (wrapFills (dropPathWraps x))
  w false false = pure (just x)
  w false true = pure (just y)

absorb _ _ cw[] = R.typeError [ "cw[] in absorb!" ]â‚‘
absorb _ _ (cw[ y ]) = R.typeError [ "cw[_] in absorb!" ]â‚‘
absorb n x (y âˆ·cw ys) =
 absorbStep' n x y >>=
  Mb.rec (pure (cw (fw[1, x ] vâˆ· y vâˆ· ys))) (pure âˆ˜S _âˆ·cw ys)
absorb n x y = absorbStep' n x y >>=
  Mb.rec (pure (fw[1, x ] âˆ·cw v[ y ]))
          pure


cTermEnd : CTerm â†’ R.TC (Maybe WTerm)
cTermEnd = fixMb âˆ˜S
  atVarOrDefM (Î» _ v _ argM â†’ R.var v <$> argM)
     (Î» n def _ argsM â†’ ((R.def def) <$> argsM) >>= reduceComps n) âˆ˜S evFills

 where
  evFills : CTerm â†’ CTerm
  evFills =
   atVarOrM
    (Î» _ _ _ â†’ nothing )
    Î» _ nm args â†’ atD (R.def nm args)

   where
    atD : R.Term â†’ Maybe R.Term
    atD fw[1, x ] = just x
    atD fw[0, x ] = just (replaceVarWithCon (Î» { zero â†’ just (quote i1) ; _ â†’ nothing }) x)
    atD _ = nothing

  reduceComps : â„• â†’ R.Term â†’ R.TC R.Term
  reduceComps _ cw[] = R.typeError [ "cTermEnd : reduceComps : unexpected cw[]" ]â‚‘
  reduceComps n cw[ p ] = pure p --if (hasVar n p) then  else {!!}
  reduceComps n t@(p âˆ·cw ps@((R.arg _ ps0) âˆ· _)) =
   if (hasVar n p) then pure t  else
    (pure (if length ps =â„• 1 then ps0 else cw ps))
  reduceComps _ x = pure x

  fixMb : R.TC WTerm â†’ R.TC (Maybe WTerm)
  fixMb x = x >>= Î» x â†’ pure $ if (hasVar 0 x) then just x else nothing

data FillWrapEval : Type where
 headFW dropFW : FillWrapEval

dropFillWraps : FillWrapEval -> CTerm â†’ R.Term
dropFillWraps fwe = atVarOrDefM {{_}} {{RawMonadIdentityM}}
  (Î» _ v _ argsM â†’ R.var v argsM)
  Î» _ d _ argsM â†’ w fwe (R.def d argsM)

 where

  lift0Dim = remapVars Î» { zero â†’ suc zero ; n â†’ n }

  w : FillWrapEval â†’ R.Term â†’ R.Term
  -- w offsetFW fw[1, x ] = lift0Dim x
  -- w offsetFW fw[0, x ] = invVar 1 (lift0Dim x)
  w headFW fw[1, x ] = replaceVarWithTerm
    (Î» { zero â†’ just (R.def (quote _âˆ¨_) (ğ’— 1 vâˆ· v[ ğ’— 0 ]))
       ; _ â†’ nothing }) x
  w headFW fw[0, x ] = replaceVarWithTerm
    (Î» { zero â†’ just (R.def (quote _âˆ¨_) ((R.def (quote ~_) v[ ğ’— 1 ]) vâˆ· v[ ğ’— 0 ])) ; _ â†’ nothing }) x
  w dropFW fw[1, x ] = x
  w dropFW fw[0, x ] = x
  w _ x = x


transpose : âˆ€ {â„“} {A : Type â„“} â†’ A â†’ List (List A) â†’ List (List A)
transpose default [] = [ [] ]
transpose default xss@(xs âˆ· _) =
  L.map (Î» (k , ys) â†’ L.map (Î» ys â†’ lookupAlways default ys k) xss ) (zipWithIndex xs)

fill-flatten' : CTerm â†’ List R.Term
fill-flatten' = hTop âˆ˜S atVarOrConOrDefMmp
  (Î» _ v _ _ args' â†’ R.var v <$> (h args'))
  (Î» _ c _ _ args' â†’ R.con c <$> (h args'))
  df âˆ˜S dropPathWraps âˆ˜S liftVarsFrom 1 1

 where



 fill-offsetPa' : â„• â†’ List (R.Arg R.Term) â†’ List (R.Arg R.Term)
 fill-offsetPa' n xs =
  let hd = fromJust-def (varg (R.lit (R.string "fatal in PathEval - offsetPa'")))
            (lookup xs zero)
      hs* = mapArg (dropFillWraps headFW) hd
      hd' = mapArg
             (replaceVarWithCon (Î» { zero â†’ just (quote i0) ; _ â†’ nothing })) hs*
  in repeat (n âˆ¸ length xs ) hd' ++
       hs* âˆ· L.map (mapArg (dropFillWraps dropFW)) (tail xs)


 h : List (List (R.Arg R.Term)) â†’ List (List (R.Arg R.Term))
 h xs =
  let maxL = foldr (max âˆ˜S length) 1 xs
      xs' = L.map (fill-offsetPa' maxL) xs
  in transpose ((varg (R.lit (R.string "fatal in PathEval - flatten")))) xs'

 hTop : List R.Term â†’ List R.Term
 hTop = L.map (Mb.fromJust-def ( (R.lit (R.string "imposible in fill-flatten'")) )
   âˆ˜S map-Maybe (unArg) âˆ˜S flip lookup zero) âˆ˜S h âˆ˜S [_] âˆ˜S L.map varg

 df : â„• â†’
        R.Name â†’
        List (R.Arg R.Term) â†’
        List (List (R.Arg R.Term)) â†’
        List (List (R.Arg R.Term)) â†’ List R.Term
 df _ (quote CompWrap) _ _ args' = unArg <$> join args'
 df _ nm _ _ args' = R.def nm <$> (h args')



foldPath : List R.Term â†’ R.Term
foldPath [] = q[ refl ]
foldPath (x âˆ· []) = vlam "ğ“²" x
foldPath (x âˆ· xs@(_ âˆ· _)) = Râˆ™' (vlam "ğ“²" x) (foldPath xs)

foldPath' : List R.Term â†’ Maybe R.Term
foldPath' [] = nothing
foldPath' (x âˆ· []) = just $ vlam "ğ“²" x
foldPath' (x âˆ· xs@(_ âˆ· _)) = just $ Râˆ™' (vlam "ğ“²" x) (foldPath xs)

fillHeadTrm : R.Term â†’ Maybe R.Term â†’ R.TC R.Term
fillHeadTrm p nothing = pure (vlam "ğ’‹" (vlam "ğ’Š" p))
fillHeadTrm p (just q) = do
   pâ‚€ â† hasVar 0
       <$> (addNDimsToCtx 2 $ R.normalise
        (replaceVarWithCon (Î» { (suc zero) â†’ just (quote i0) ; _ â†’ nothing }) p))
   pâ‚ â†  hasVar 0 <$> (addNDimsToCtx 2 $ R.normalise
        (replaceVarWithCon (Î» { (suc zero) â†’ just (quote i1) ; _ â†’ nothing }) p))
   h pâ‚€ pâ‚

 where
  h : Bool â†’ Bool â†’ R.TC R.Term
  h false false = R.typeError [ "imposible in fillHeadTrm" ]â‚‘
  h false true = pure $ R.def (quote _âˆ™f1_) (vlam "ğ’‹" (vlam "ğ’Š" p) vâˆ· v[ vlam "ğ’‹" q ])
  h true false = pure $ R.def (quote _âˆ™f0_) (vlam "ğ’‹" (vlam "ğ’Š" p) vâˆ· v[ vlam "ğ’‹" q ])
  h true true = pure $ vlam "ğ’‹" (Râˆ™' (vlam "ğ“²" p) q)



PathTerm = R.Term âŠ R.Term

pattern ğ’“efl x = inl x
pattern ğ’‘Î» x = inr x


record SquareTerm : Type where
 constructor squareTerm
 field
  term : R.Term


asPathTerm : R.Term â†’ PathTerm
asPathTerm tm =
  if (hasVar zero tm) then (ğ’‘Î» tm) else (ğ’“efl tm)


bfs' : CTerm â†’ R.TC R.Term
bfs' xs =  do
    let q = (foldPath' (tail (fill-flatten' xs)))
    hd â† Mb.rec (R.typeError [ "imposible tfctâ‰¡" ]â‚‘ )
           pure (listToMaybe (fill-flatten' xs))
    -- addNDimsToCtx 2 $  R.typeError [ hd ]â‚‘
    fillHeadTrm hd q




-- compPath'-filler, but composition is 'simplified' according to groupoid laws
-- (p : x â‰¡ y) â†’ (q : y â‰¡ z) â†’ (Î£ (pâˆ™q âˆˆ x â‰¡ z) (Square q pâˆ™q p refl))
-- assumes that terms are already pre processed ussing : addNDimsToCtx 1 âˆ˜S R.normalise âˆ˜S pathApp

_â†™_ : PathTerm â†’ PathTerm â†’ R.TC (PathTerm Ã— SquareTerm)
ğ’“efl x â†™ q = q ,_ <$>  (squareTerm <$> bfs' (âŠ.rec (idfun _) (idfun _) q))
ğ’‘Î» x â†™ ğ’“efl y =
  (ğ’‘Î» (wrapPaths x) ,_) <$> (squareTerm <$> (bfs' (wrapFills x)) )
ğ’‘Î» p â†™ ğ’‘Î» q = do
  pq-sq â† (absorb 0 (wrapPaths p) q)

  pq â† (cTermEnd pq-sq) >>= Mb.rec
     ( ğ’“efl <$> (addNDimsToCtx 1 $ R.normalise
          (replaceVarWithCon (Î» { zero â†’ just (quote i0) ; _ â†’ nothing }) p))) (pure âˆ˜S ğ’‘Î»)

  pq ,_ <$> (squareTerm <$> bfs' pq-sq)


macro
 â†™-test : R.Term â†’ R.Term â†’ R.Term â†’ R.TC Unit
 â†™-test p q h = do
   p' â† asPathTerm <$> (addNDimsToCtx 1 âˆ˜S R.normalise âˆ˜S pathApp) p
   q' â† asPathTerm âˆ˜S wrapPaths <$> (addNDimsToCtx 1 âˆ˜S R.normalise âˆ˜S pathApp) q
   pq â† (SquareTerm.term âˆ˜S snd) <$> p' â†™ q'
   R.unify pq h
