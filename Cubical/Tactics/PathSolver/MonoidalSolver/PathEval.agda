{-

This module provides an implementation that can be perceived as a free monoidal groupoid generated by terms. It works under the assumption that there is only one interval variable in the context and that terms are free of composition operations. The core functionality involves decomposing terms and traversing them to identify subterms containing interval variables. These subterms are then marked as "paths" by wrapping them into temporary definitions.

### Steps

- **Path Identification**: Identifies subterms containing interval variables and marks them as "paths."
- **Term Wrapping**: Wraps identified "path" subterms into temporary definitions (`PathWrap`, `FillWrap`, `CompWrap`).
- **Normalization**: Treats terms with multiple subterms identified as "paths" as functors applied to the product of these subterms. Terms prepared in that way can be normalized according to monoidal-groupoid laws, generalizing the `cong‚ÇÇFunct` lemma from the `Foundations.GroupoidLaws` module.


### Specialized Definitions Used only temporairly as markers during processing AST

- **`ASTMarkers`**: Defines markers for `PathWrap`, `FillWrap`, and `CompWrap`.
- **Term Patterns**: Various term patterns (`fw`, `pw`, `cwd`, etc.) are used for identifying and manipulating wrapped terms.


### Utilities**
Functions like `intervalTest`, `transpose`, and `reduceComps` are utility functions aiding the main functionalities.

At the end, whole process is wrapped into _‚Üô_ operator, which can be seen as analogue of `compPath-filler` from prelude, but operating only on already normalised paths, and with composition operation resulting in "normalised" path according to monoidal-groipoid laws.

-}

{-# OPTIONS --safe -v testMarkVert:3 -v tactic:3 #-}

module Cubical.Tactics.PathSolver.MonoidalSolver.PathEval where

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Structure
open import Cubical.Foundations.Function

open import Cubical.Relation.Nullary

open import Cubical.Data.Bool
open import Cubical.Data.Empty
open import Cubical.Data.Sum as ‚äé
open import Cubical.Data.Maybe as Mb
open import Cubical.Data.List as L
open import Cubical.Data.Nat as ‚Ñï

open import Cubical.Data.Sigma.Base


open import Cubical.Reflection.Base renaming (v to ùíó)
open import Cubical.Reflection.Sugar
open import Agda.Builtin.Nat using () renaming (_==_ to _=‚Ñï_ ; _<_ to _<‚Ñï_)

import Agda.Builtin.Reflection as R

open import Cubical.Tactics.PathSolver.Reflection
open import Cubical.Tactics.PathSolver.Path

open import Agda.Builtin.String

open import Cubical.Tactics.Reflection.Utilities
open import Cubical.Tactics.Reflection.Error
open import Cubical.Tactics.Reflection.Dimensions
open import Cubical.Tactics.Reflection.QuoteCubical


data ASTMarkers : Type where
 PathWrap' FillWrap' CompWrap' : ASTMarkers

PathWrap FillWrap CompWrap : ASTMarkers
PathWrap = PathWrap'
FillWrap = FillWrap'
CompWrap = CompWrap'

WTerm = R.Term
CTerm = R.Term


pattern fw[1,_] x = R.def (quote FillWrap) (R.lit (R.name (quote true)) v‚à∑ v[ x ])
pattern fw[0,_] x = R.def (quote FillWrap) (R.lit (R.name (quote false)) v‚à∑ v[ x ])


pattern pw[_] x = R.def (quote PathWrap) (x v‚à∑ [])
pattern pwd args = R.def (quote PathWrap) args


pattern cwd args = R.def (quote CompWrap) args

pattern cw[] = R.def (quote CompWrap) []
pattern cw[_] x = R.def (quote CompWrap) (x v‚à∑ [])
pattern cw xs = R.def (quote CompWrap) xs
pattern _‚à∑cw_ x xs = R.def (quote CompWrap) (x v‚à∑ xs)


intervalTest : ‚Ñï ‚Üí R.Term ‚Üí Bool
intervalTest _ (R.def (quote _‚à®_) _) = true
intervalTest _ (R.def (quote _‚àß_) _) = true
intervalTest _ (R.def (quote ~_) _) = true
intervalTest n (R.var k []) = n =‚Ñï k
intervalTest _ _ = false


wrapPaths : R.Term ‚Üí WTerm
wrapPaths = atVarOrConM' f h g
 where
  f : ‚Ñï ‚Üí ‚Ñï ‚Üí List (R.Arg R.Term) ‚Üí Maybe R.Term
  f n v args =
     if any? (L.map (intervalTest n ‚àòS unArg) args)
     then  just pw[ (R.var (v + n) args) ]
     else nothing

  h : ‚Ñï ‚Üí R.Name ‚Üí List (R.Arg R.Term) ‚Üí Maybe R.Term
  h n nm args =
     if any? (L.map (intervalTest n ‚àòS unArg) args)
     then  just pw[ (R.con nm args) ]
     else nothing

  g : ‚Ñï ‚Üí R.Name ‚Üí List (R.Arg R.Term) ‚Üí Maybe R.Term
  g n nm args =
     if any? (L.map (intervalTest n ‚àòS unArg) args)
     then  just pw[ (R.def nm args) ]
     else nothing

wrapFills : R.Term ‚Üí WTerm
wrapFills = atVarOrConM' f h g
 where
  f : ‚Ñï ‚Üí ‚Ñï ‚Üí List (R.Arg R.Term) ‚Üí Maybe R.Term
  f n v args =
     if any? (L.map (intervalTest n ‚àòS unArg) args)
     then  just fw[1, pw[ (R.var (v + n) args) ] ]
     else nothing

  h : ‚Ñï ‚Üí R.Name ‚Üí List (R.Arg R.Term) ‚Üí Maybe R.Term
  h n nm args =
     if any? (L.map (intervalTest n ‚àòS unArg) args)
     then  just fw[1, pw[ (R.con nm args) ] ]
     else nothing


  g : ‚Ñï ‚Üí R.Name ‚Üí List (R.Arg R.Term) ‚Üí Maybe R.Term
  g n nm args =
     if any? (L.map (intervalTest n ‚àòS unArg) args)
     then  just fw[1, pw[ (R.def nm args) ] ]
     else nothing



dropPathWraps : CTerm ‚Üí R.Term
dropPathWraps = atVarOrDefM {{_}} {{RawMonadIdentityM}}
  (Œª _ v _ argsM ‚Üí R.var v argsM)
  Œª _ d _ argsM ‚Üí w (R.def d argsM)

 where
  w : R.Term ‚Üí R.Term
  w pw[ x ] = x
  w x = x


absorb : ‚Ñï ‚Üí WTerm ‚Üí CTerm ‚Üí R.TC CTerm


absorbStep : ‚Ñï ‚Üí WTerm ‚Üí WTerm ‚Üí R.TC (Maybe CTerm)
absorbStep n (cwd _) _ = R.typeError [ "cwd in absorbStep" ]‚Çë
absorbStep n _ (cwd _) = R.typeError [ "cwd in absorbStep" ]‚Çë
absorbStep zero pw[ x ] pw[ y ] = do
  -- R.debugPrint "testMarkVert" 3 $ "-----" ‚à∑nl x ‚à∑nl "** \n" ‚à∑nl [ y ]‚Çë
  (if_then (just fw[0, y ]) else nothing) <$> unifyTest (suc zero) x (invVar zero y)
absorbStep (suc _) pw[ x ] pw[ y ] =
 R.typeError [ "absorbStep: todo - paths under abstraction" ]‚Çë
absorbStep n x pw[ y ] = pure nothing
absorbStep n pw[ x ] y = pure nothing
absorbStep n (pwd _) _ = R.typeError [ "pwd1 in absorbStep!" ]‚Çë
absorbStep n _ (pwd _) = R.typeError [ "pwd2 in absorbStep!" ]‚Çë
absorbStep n x y = just <$> h x y
 where

 hs : R.Sort ‚Üí R.Sort ‚Üí R.TC R.Sort
 h : WTerm ‚Üí WTerm ‚Üí R.TC CTerm

 ha : List (R.Arg R.Term) ‚Üí List (R.Arg R.Term) ‚Üí R.TC (List (R.Arg R.Term))
 ha [] [] = pure []
 ha (R.arg ax x ‚à∑ xs) (R.arg _ x' ‚à∑ xs')  =
   ‚¶á ‚¶á R.arg ‚¶á ax ‚¶à (absorb n x x') ‚¶à  ‚à∑ ha xs xs' ‚¶à
 ha _ _ = R.typeError [ "absorbStep: ha-failed" ]‚Çë

 h (R.var x args) (R.var _ args') = R.var x <$> ha args args'
 h (R.con c args) (R.con _ args') = R.con c <$> ha args args'
 h (R.def f args) (R.def _ args') = R.def f <$> ha args args'
 h (R.lam v (R.abs ai t)) (R.lam v' (R.abs _ t')) =
    ‚¶á R.lam ‚¶á v ‚¶à ‚¶á R.abs ‚¶á ai ‚¶à (absorb (suc n) t t') ‚¶à  ‚¶à
 h (R.pat-lam cs args) (R.pat-lam cs' args') = R.typeError [ "absorbStep: todo - patLamb" ]‚Çë
 h (R.pi (R.arg ai a) (R.abs bi b)) (R.pi (R.arg ai' a') (R.abs bi' b')) =
     ‚¶á R.pi ‚¶á R.arg ‚¶á ai ‚¶à (absorb n a a') ‚¶à ‚¶á R.abs ‚¶á bi ‚¶à (absorb (suc n) b b') ‚¶à  ‚¶à
 h (R.agda-sort s) (R.agda-sort s') = R.agda-sort <$> hs s s'
 h (R.lit l) (R.lit l') = pure (R.lit l)
 h (R.meta x x‚ÇÇ) (R.meta x' x‚ÇÇ') = R.typeError [ "absorbStep: todo - meta" ]‚Çë
 h R.unknown R.unknown = ‚¶á R.unknown ‚¶à
 h t t' = R.typeError
   $ "absorbStep: h-failed" ‚à∑nl t ‚à∑nl "---" ‚à∑nl [ t' ]‚Çë

 hs (R.set t) (R.set t') = R.set <$> absorb n t t'
 hs (R.lit n) (R.lit _) = pure (R.lit n)
 hs (R.prop t) (R.prop t') = R.prop <$> absorb n t t'
 hs (R.propLit n) (R.propLit n') = pure (R.propLit n)
 hs (R.inf n) (R.inf n') = pure (R.inf n)
 hs R.unknown R.unknown = pure (R.unknown)
 hs _ _ = R.typeError [ "absorbStep: hs-failed" ]‚Çë

absorbStep' : ‚Ñï ‚Üí WTerm ‚Üí WTerm ‚Üí R.TC (Maybe CTerm)
absorbStep' n x y =
  w (hasVar zero x) (hasVar zero y)

 where
  w : Bool ‚Üí Bool ‚Üí R.TC (Maybe CTerm)
  w true true = absorbStep n x y
  w true false = pure $ just (wrapFills (dropPathWraps x))
  w false false = pure (just x)
  w false true = pure (just y)

absorb _ _ cw[] = R.typeError [ "cw[] in absorb!" ]‚Çë
absorb _ _ (cw[ y ]) = R.typeError [ "cw[_] in absorb!" ]‚Çë
absorb n x (y ‚à∑cw ys) =
 absorbStep' n x y >>=
  Mb.rec (pure (cw (fw[1, x ] v‚à∑ y v‚à∑ ys))) (pure ‚àòS _‚à∑cw ys)
absorb n x y = absorbStep' n x y >>=
  Mb.rec (pure (fw[1, x ] ‚à∑cw v[ y ]))
          pure


cTermEnd : CTerm ‚Üí R.TC (Maybe WTerm)
cTermEnd = fixMb ‚àòS
  atVarOrDefM (Œª _ v _ argM ‚Üí R.var v <$> argM)
     (Œª n def _ argsM ‚Üí ((R.def def) <$> argsM) >>= reduceComps n) ‚àòS evFills

 where
  evFills : CTerm ‚Üí CTerm
  evFills =
   atVarOrM
    (Œª _ _ _ ‚Üí nothing )
    Œª _ nm args ‚Üí atD (R.def nm args)

   where
    atD : R.Term ‚Üí Maybe R.Term
    atD fw[1, x ] = just x
    atD fw[0, x ] = just (replaceVarWithCon (Œª { zero ‚Üí just (quote i1) ; _ ‚Üí nothing }) x)
    atD _ = nothing

  reduceComps : ‚Ñï ‚Üí R.Term ‚Üí R.TC R.Term
  reduceComps _ cw[] = R.typeError [ "cTermEnd : reduceComps : unexpected cw[]" ]‚Çë
  reduceComps n cw[ p ] = pure p --if (hasVar n p) then  else {!!}
  reduceComps n t@(p ‚à∑cw ps@((R.arg _ ps0) ‚à∑ _)) =
   if (hasVar n p) then pure t  else
    (pure (if length ps =‚Ñï 1 then ps0 else cw ps))
  reduceComps _ x = pure x

  fixMb : R.TC WTerm ‚Üí R.TC (Maybe WTerm)
  fixMb x = x >>= Œª x ‚Üí pure $ if (hasVar 0 x) then just x else nothing

data FillWrapEval : Type where
 headFW dropFW : FillWrapEval

dropFillWraps : FillWrapEval -> CTerm ‚Üí R.Term
dropFillWraps fwe = atVarOrDefM {{_}} {{RawMonadIdentityM}}
  (Œª _ v _ argsM ‚Üí R.var v argsM)
  Œª _ d _ argsM ‚Üí w fwe (R.def d argsM)

 where

  lift0Dim = remapVars Œª { zero ‚Üí suc zero ; n ‚Üí n }

  w : FillWrapEval ‚Üí R.Term ‚Üí R.Term
  -- w offsetFW fw[1, x ] = lift0Dim x
  -- w offsetFW fw[0, x ] = invVar 1 (lift0Dim x)
  w headFW fw[1, x ] = replaceVarWithTerm
    (Œª { zero ‚Üí just (R.def (quote _‚à®_) (ùíó 1 v‚à∑ v[ ùíó 0 ]))
       ; _ ‚Üí nothing }) x
  w headFW fw[0, x ] = replaceVarWithTerm
    (Œª { zero ‚Üí just (R.def (quote _‚à®_) ((R.def (quote ~_) v[ ùíó 1 ]) v‚à∑ v[ ùíó 0 ])) ; _ ‚Üí nothing }) x
  w dropFW fw[1, x ] = x
  w dropFW fw[0, x ] = x
  w _ x = x


transpose : ‚àÄ {‚Ñì} {A : Type ‚Ñì} ‚Üí A ‚Üí List (List A) ‚Üí List (List A)
transpose default [] = [ [] ]
transpose default xss@(xs ‚à∑ _) =
  L.map (Œª (k , ys) ‚Üí L.map (Œª ys ‚Üí lookupAlways default ys k) xss ) (zipWithIndex xs)

fill-flatten' : CTerm ‚Üí List R.Term
fill-flatten' = hTop ‚àòS atVarOrConOrDefMmp
  (Œª _ v _ _ args' ‚Üí R.var v <$> (h args'))
  (Œª _ c _ _ args' ‚Üí R.con c <$> (h args'))
  df ‚àòS dropPathWraps ‚àòS liftVarsFrom 1 1

 where



 fill-offsetPa' : ‚Ñï ‚Üí List (R.Arg R.Term) ‚Üí List (R.Arg R.Term)
 fill-offsetPa' n xs =
  let hd = fromJust-def (varg (R.lit (R.string "fatal in PathEval - offsetPa'")))
            (lookup xs zero)
      hs* = mapArg (dropFillWraps headFW) hd
      hd' = mapArg
             (replaceVarWithCon (Œª { zero ‚Üí just (quote i0) ; _ ‚Üí nothing })) hs*
  in repeat (n ‚à∏ length xs ) hd' ++
       hs* ‚à∑ L.map (mapArg (dropFillWraps dropFW)) (tail xs)


 h : List (List (R.Arg R.Term)) ‚Üí List (List (R.Arg R.Term))
 h xs =
  let maxL = foldr (max ‚àòS length) 1 xs
      xs' = L.map (fill-offsetPa' maxL) xs
  in transpose ((varg (R.lit (R.string "fatal in PathEval - flatten")))) xs'

 hTop : List R.Term ‚Üí List R.Term
 hTop = L.map (Mb.fromJust-def ( (R.lit (R.string "imposible in fill-flatten'")) )
   ‚àòS map-Maybe (unArg) ‚àòS flip lookup zero) ‚àòS h ‚àòS [_] ‚àòS L.map varg

 df : ‚Ñï ‚Üí
        R.Name ‚Üí
        List (R.Arg R.Term) ‚Üí
        List (List (R.Arg R.Term)) ‚Üí
        List (List (R.Arg R.Term)) ‚Üí List R.Term
 df _ (quote CompWrap) _ _ args' = unArg <$> join args'
 df _ nm _ _ args' = R.def nm <$> (h args')



foldPath : List R.Term ‚Üí R.Term
foldPath [] = q[ refl ]
foldPath (x ‚à∑ []) = vlam "ùì≤" x
foldPath (x ‚à∑ xs@(_ ‚à∑ _)) = R‚àô' (vlam "ùì≤" x) (foldPath xs)

foldPath' : List R.Term ‚Üí Maybe R.Term
foldPath' [] = nothing
foldPath' (x ‚à∑ []) = just $ vlam "ùì≤" x
foldPath' (x ‚à∑ xs@(_ ‚à∑ _)) = just $ R‚àô' (vlam "ùì≤" x) (foldPath xs)

fillHeadTrm : R.Term ‚Üí Maybe R.Term ‚Üí R.TC R.Term
fillHeadTrm p nothing = pure (vlam "ùíã" (vlam "ùíä" p))
fillHeadTrm p (just q) = do
   p‚ÇÄ ‚Üê hasVar 0
       <$> (addNDimsToCtx 2 $ R.normalise
        (replaceVarWithCon (Œª { (suc zero) ‚Üí just (quote i0) ; _ ‚Üí nothing }) p))
   p‚ÇÅ ‚Üê  hasVar 0 <$> (addNDimsToCtx 2 $ R.normalise
        (replaceVarWithCon (Œª { (suc zero) ‚Üí just (quote i1) ; _ ‚Üí nothing }) p))
   h p‚ÇÄ p‚ÇÅ

 where
  h : Bool ‚Üí Bool ‚Üí R.TC R.Term
  h false false = R.typeError [ "imposible in fillHeadTrm" ]‚Çë
  h false true = pure $ R.def (quote _‚àôf1_) (vlam "ùíã" (vlam "ùíä" p) v‚à∑ v[ vlam "ùíã" q ])
  h true false = pure $ R.def (quote _‚àôf0_) (vlam "ùíã" (vlam "ùíä" p) v‚à∑ v[ vlam "ùíã" q ])
  h true true = pure $ vlam "ùíã" (R‚àô' (vlam "ùì≤" p) q)



PathTerm = R.Term ‚äé R.Term

pattern ùíìefl x = inl x
pattern ùíëŒª x = inr x


record SquareTerm : Type where
 constructor squareTerm
 field
  term : R.Term


asPathTerm : R.Term ‚Üí PathTerm
asPathTerm tm =
  if (hasVar zero tm) then (ùíëŒª tm) else (ùíìefl tm)


bfs' : CTerm ‚Üí R.TC R.Term
bfs' xs =  do
    let q = (foldPath' (tail (fill-flatten' xs)))
    hd ‚Üê Mb.rec (R.typeError [ "imposible tfct‚â°" ]‚Çë )
           pure (listToMaybe (fill-flatten' xs))
    -- addNDimsToCtx 2 $  R.typeError [ hd ]‚Çë
    fillHeadTrm hd q




-- compPath'-filler, but composition is 'simplified' according to groupoid laws
-- (p : x ‚â° y) ‚Üí (q : y ‚â° z) ‚Üí (Œ£ (p‚àôq ‚àà x ‚â° z) (Square q p‚àôq p refl))
-- assumes that terms are already pre processed ussing : addNDimsToCtx 1 ‚àòS R.normalise ‚àòS pathApp

_‚Üô_ : PathTerm ‚Üí PathTerm ‚Üí R.TC (PathTerm √ó SquareTerm)
ùíìefl x ‚Üô q = q ,_ <$>  (squareTerm <$> bfs' (‚äé.rec (idfun _) (idfun _) q))
ùíëŒª x ‚Üô ùíìefl y =
  (ùíëŒª (wrapPaths x) ,_) <$> (squareTerm <$> (bfs' (wrapFills x)) )
ùíëŒª p ‚Üô ùíëŒª q = do
  pq-sq ‚Üê (absorb 0 (wrapPaths p) q)

  pq ‚Üê (cTermEnd pq-sq) >>= Mb.rec
     ( ùíìefl <$> (addNDimsToCtx 1 $ R.normalise
          (replaceVarWithCon (Œª { zero ‚Üí just (quote i0) ; _ ‚Üí nothing }) p))) (pure ‚àòS ùíëŒª)

  pq ,_ <$> (squareTerm <$> bfs' pq-sq)


macro
 ‚Üô-test : R.Term ‚Üí R.Term ‚Üí R.Term ‚Üí R.TC Unit
 ‚Üô-test p q h = do
   p' ‚Üê asPathTerm <$> (addNDimsToCtx 1 ‚àòS R.normalise ‚àòS pathApp) p
   q' ‚Üê asPathTerm ‚àòS wrapPaths <$> (addNDimsToCtx 1 ‚àòS R.normalise ‚àòS pathApp) q
   pq ‚Üê (SquareTerm.term ‚àòS snd) <$> p' ‚Üô q'
   R.unify pq h
