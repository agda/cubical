{-# OPTIONS --safe #-}

module Cubical.Tactics.GroupSolver.Solver where


open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Structure
open import Cubical.Foundations.Function
open import Cubical.Foundations.HLevels

open import Cubical.Data.Bool as ùüö hiding (_‚â§_)
open import Cubical.Data.Nat as ‚Ñï hiding (_¬∑_)
open import Cubical.Data.Unit
open import Cubical.Data.Sigma
open import Cubical.Data.List as Li
open import Cubical.Data.Maybe as Mb

open import Cubical.Algebra.Group

open import Cubical.Reflection.Base
import Agda.Builtin.Reflection as R
open import Cubical.Tactics.GroupSolver.GroupExpression
open import Cubical.Tactics.GroupSolver.Reflection

private
  variable
    ‚Ñì : Level

module _ (G : Group ‚Ñì) where
 open GroupStr (snd G)
 data IsTrm : ‚ü® G ‚ü© ‚Üí Type ‚Ñì where
  is1g : IsTrm 1g
  isOp : ‚àÄ x y ‚Üí IsTrm (_¬∑_ x y)
  isInv : ‚àÄ x ‚Üí IsTrm (inv x)


1g' : (G : Group ‚Ñì) ‚Üí ‚ü® G ‚ü©
1g' G = GroupStr.1g (snd G)

module tryGE (skipInv : Bool) (tG : R.Term)  where
 tryG : ‚Ñï ‚Üí R.Term ‚Üí R.TC (GE.GroupExpr R.Term)
 tryG' : Bool ‚Üí ‚Ñï ‚Üí  R.Term ‚Üí R.TC (GE.GroupExpr R.Term)

 try1g : R.Term ‚Üí R.TC (GE.GroupExpr R.Term)
 try1g t = do
       _ ‚Üê R.unify t (R.def (quote 1g') [ varg tG ])
       R.returnTC GE.Œµ

 tryOp : ‚Ñï ‚Üí R.Term ‚Üí R.TC (GE.GroupExpr R.Term)
 tryOp zero _ = R.typeError []
 tryOp (suc k) t = do
       tm ‚Üê (R.checkType (R.con (quote isOp)
          (varg R.unknown ‚à∑ [ varg R.unknown ])) (R.def (quote IsTrm)
           ((varg tG) ‚à∑ [ varg t ])))
       (t1 , t2) ‚Üê h tm
       t1' ‚Üê tryG' false k t1
       t2' ‚Üê tryG' false k t2
       R.returnTC (t1' GE.¬∑ t2')

  where

  h : R.Term ‚Üí R.TC (R.Term √ó R.Term)
  h (R.con (quote isOp) l) = match2Vargs l
  h _ = R.typeError []

 tryInv : ‚Ñï ‚Üí R.Term ‚Üí R.TC (GE.GroupExpr R.Term)
 tryInv zero _ = R.typeError []
 tryInv (suc k) t =  do
       tm ‚Üê -- R.noConstraints
        (R.checkType (R.con (quote isInv)
          ([ varg R.unknown ])) (R.def (quote IsTrm)
           ((varg tG) ‚à∑ [ varg t ])))
       t1 ‚Üê h tm
       t1' ‚Üê tryG' true k t1
       R.returnTC (GE.inv t1')

  where
  h' : List (R.Arg R.Term) ‚Üí R.TC (R.Term)
  h' (harg _ ‚à∑ xs) = h' xs
  h' (varg t1 ‚à∑ []) = R.returnTC t1
  h' _ = R.typeError []

  h : R.Term ‚Üí R.TC (R.Term)
  h (R.con (quote isInv) l) = h' l
  h _ = R.typeError []


 atom : R.Term ‚Üí R.TC (GE.GroupExpr R.Term)
 atom x = R.returnTC (GE.Œ∑ x)


 tryG' _ zero _ = R.typeError [ (R.strErr "Magic number to low") ]
 tryG' b (suc k) t =
   R.catchTC
    (try1g t)
    (catchOrSkip (skipInv)(tryInv k t)
               (R.catchTC (tryOp k t)
                           (atom t)))

 tryG = tryG' false

groupSolverMain : Bool ‚Üí R.Term ‚Üí R.Term ‚Üí R.Term ‚Üí R.Term ‚Üí R.TC Unit
groupSolverMain debugFlag skipInvsTM mbAtomsFromUserTM tG hole = do
 skipInvs ‚Üê R.unquoteTC skipInvsTM
 (_ , (t0 , t1)) ‚Üê inferEnds hole
 atomsFromUser ‚Üê quotedMaybe‚ÜímaybeTerm mbAtomsFromUserTM
    >>= (Mb.rec (R.returnTC nothing) Œª l ‚Üí quotedList‚ÜíListOfTerms l >>= (R.returnTC ‚àò just) )

 t0N ‚Üê R.normalise t0
 t1N ‚Üê R.normalise t1
 r0 ‚Üê tryGE.tryG skipInvs tG 100 t0N
 r1 ‚Üê tryGE.tryG skipInvs tG 100 t1N
 ul ‚Üê Mb.rec (uniqeAtoms (GE.atoms _ r0 ++ GE.atoms _ r1)) R.returnTC atomsFromUser
 (r0* , r0') ‚Üê travGroupExprTC (lookT ul) r0 >>= Œª x ‚Üí R.quoteTC x >>= Œª x' ‚Üí R.returnTC (x , x')
 (r1* , r1') ‚Üê travGroupExprTC (lookT ul) r1 >>= Œª x ‚Üí R.quoteTC x >>= Œª x' ‚Üí R.returnTC (x , x')

 final ‚Üê R.reduce (R.def (quote Solver.solve) (tG v‚à∑ (quoteList ul) v‚à∑ r0' v‚à∑ r1' v‚à∑ [] ))
 R.catchTC
  (R.unify hole final)
  (do finalTy ‚Üê R.inferType final
      (R.typeError
        (let finalInferedType =
                (R.strErr "finalTy: ") ‚à∑ (R.termErr finalTy) ‚à∑ [ R.strErr "\n" ]
             inferedEnds =
              ((R.strErr "LHS: ") ‚à∑ (R.termErr t0N) ‚à∑ (R.strErr "\n")
               ‚à∑ (R.strErr "RHS: ") ‚à∑  (R.termErr t1N)  ‚à∑ [(R.strErr "\n")])
             groupExprEnds =
              ((R.strErr "LHS: ") ‚à∑ (R.strErr (showNormalizedGE‚Ñï r0*)) ‚à∑ (R.strErr "\n")
               ‚à∑ (R.strErr "RHS: ") ‚à∑  (R.strErr (showNormalizedGE‚Ñï r1*))  ‚à∑ [(R.strErr "\n")])
             debugMsg = finalInferedType ++ inferedEnds ++ groupExprEnds ++ (Li.map R.termErr ul)
             failMsg = (R.strErr "LHS ‚â† RHS ‚Äº\n") ‚à∑
                        groupExprEnds ++ R.strErr "\n" ‚à∑ niceAtomList 0 ul
        in if debugFlag then debugMsg else failMsg )))

 where
 niceAtomList : ‚Ñï ‚Üí List (R.Term) ‚Üí List R.ErrorPart
 niceAtomList _ [] = []
 niceAtomList k (x ‚à∑ xs) =
   (R.strErr (mkNiceVar k  <> " = ") ‚à∑ R.termErr x ‚à∑ [ R.strErr "\n" ]) ++ niceAtomList (suc k) xs

macro
 solveGroupDebug : R.Term ‚Üí R.Term ‚Üí R.Term ‚Üí R.Term ‚Üí R.TC Unit
 solveGroupDebug = groupSolverMain true

 solveGroup : R.Term ‚Üí R.Term ‚Üí R.TC Unit
 solveGroup = groupSolverMain false (R.con (quote false) [])  (R.con (quote nothing) [])

 -- solveœÄ‚ÇÅ : R.Term ‚Üí R.Term ‚Üí R.Term ‚Üí R.TC Unit
 -- solveœÄ‚ÇÅ atomExprList = groupSolverMain false (R.con (quote true) [])
 --   (R.con (quote just) ((harg {q = R.quantity-0} R.unknown) ‚à∑ (harg {q = R.quantity-0} R.unknown)
 --     ‚à∑ [ varg atomExprList ]))


module _ (A : Type ‚Ñì) (a : A)  where

 data IsŒ©Trm : a ‚â° a ‚Üí Type ‚Ñì where
  isRefl : IsŒ©Trm refl
  isComp : (x y z : _) ‚Üí IsŒ©Trm (x ‚àô‚àô y ‚àô‚àô z)

 module _ (p q r : a ‚â° a) where
  zz : IsŒ©Trm (p ‚àô‚àô q ‚àô‚àô r)
  zz = isComp _ _ _

module tryŒ©E (qt-A qt-a : R.Term)  where

 tryŒ© : ‚Ñï ‚Üí R.Term ‚Üí R.TC (GE.œÄ‚ÇÅGroupExpr R.Term)


 tryRefl : R.Term ‚Üí R.TC (GE.œÄ‚ÇÅGroupExpr R.Term)
 tryRefl t = do
       -- R.debugPrint "" 1 $ R.strErr "tryRefl\n" ‚à∑  [ R.termErr t ]
       _ ‚Üê R.checkType
             (R.con (quote isRefl) [])
             (R.def (quote IsŒ©Trm) (qt-A v‚à∑ qt-a v‚à∑ [ varg t ]))
       R.returnTC GE.reflGE

 tryComp : ‚Ñï ‚Üí R.Term ‚Üí R.TC (GE.œÄ‚ÇÅGroupExpr R.Term)
 tryComp zero _ = R.typeError []
 tryComp (suc k) t = do
       -- R.debugPrint "" 1 $ R.strErr "tryComp\n" ‚à∑  [ R.termErr t ]
       tm ‚Üê R.checkType
             (R.con (quote isComp) (R.unknown v‚à∑ R.unknown v‚à∑ [ varg R.unknown ]))
             (R.def (quote IsŒ©Trm) (qt-A v‚à∑ qt-a v‚à∑ [ varg t ]))
       (t1 , t2 , t3) ‚Üê h tm
       -- R.debugPrint "" 1 $ R.strErr "sucess Comp!\n"
       --                      ‚à∑ R.termErr t1 ‚à∑ R.strErr "\n"
       --                      ‚à∑ R.termErr t2 ‚à∑ R.strErr "\n"
       --                      ‚à∑ R.termErr t3 ‚à∑ R.strErr "\n"
       --                      ‚à∑ []
       t1' ‚Üê tryŒ© k t1
       t2' ‚Üê tryŒ© k t2
       t3' ‚Üê tryŒ© k t3
       R.returnTC (t1' GE.¬∑¬∑ t2' ¬∑¬∑ t3')

  where

  h : R.Term ‚Üí R.TC (R.Term √ó R.Term √ó R.Term)
  h (R.con (quote isComp) l) = match3Vargs l
  h _ = R.typeError []


 atom : R.Term ‚Üí R.TC (GE.œÄ‚ÇÅGroupExpr R.Term)
 atom x = R.returnTC (GE.atomGE x)


 tryŒ© zero _ = R.typeError [ (R.strErr "Magic number to low") ]
 tryŒ© (suc k) t =
   R.catchTC
    (tryRefl t)
    (R.catchTC (tryComp k t) (atom t))

-- appI : {A : Type ‚Ñì} {a : A} ‚Üí Path A a a ‚Üí I ‚Üí A
-- appI p i = p i

unLam : R.Term ‚Üí R.TC R.Term
unLam (R.lam _ (R.abs _ t)) = R.returnTC t
unLam t = R.typeError []

appendIfUniqe : R.Term ‚Üí List R.Term ‚Üí   R.TC (List R.Term)
appendIfUniqe x [] = R.returnTC [ x ]
appendIfUniqe x xs@(x‚ÇÅ ‚à∑ xs') = do
 x' ‚Üê R.checkType x (R.def (quote _‚â°_) (R.unknown v‚à∑ R.unknown v‚à∑ [])) >>= unLam
 x‚ÇÅ' ‚Üê R.checkType x‚ÇÅ (R.def (quote _‚â°_) (R.unknown v‚à∑ R.unknown v‚à∑ [])) >>= unLam
 sym[x‚ÇÅ'] ‚Üê R.checkType (R.def (quote sym) [ varg x‚ÇÅ ]) (R.def (quote _‚â°_) (R.unknown v‚à∑ R.unknown v‚à∑ [])) >>= unLam
 R.catchTC (R.extendContext "i" (varg (R.def (quote I) [])) $
                ( R.noConstraints $ R.unify (x') (x‚ÇÅ') >> R.returnTC xs))
    (
      R.catchTC
     (R.extendContext "i" (varg (R.def (quote I) [])) $
                ( R.noConstraints $ R.unify (x') sym[x‚ÇÅ'] >> R.returnTC xs))
        (appendIfUniqe x xs' >>= (R.returnTC ‚àò (x‚ÇÅ ‚à∑_))  )
        )

comparePathTerms : R.Term ‚Üí R.Term ‚Üí R.TC (Maybe Bool)
comparePathTerms x x‚ÇÅ = do
 x' ‚Üê R.checkType x (R.def (quote _‚â°_) (R.unknown v‚à∑ R.unknown v‚à∑ [])) >>= unLam
 x‚ÇÅ' ‚Üê R.checkType x‚ÇÅ (R.def (quote _‚â°_) (R.unknown v‚à∑ R.unknown v‚à∑ [])) >>= unLam
 sym[x‚ÇÅ'] ‚Üê R.checkType (R.def (quote sym) [ varg x‚ÇÅ ]) (R.def (quote _‚â°_) (R.unknown v‚à∑ R.unknown v‚à∑ [])) >>= unLam
 R.catchTC (R.extendContext "i" (varg (R.def (quote I) [])) $
                ( R.noConstraints $ R.unify (x') (x‚ÇÅ') >> R.returnTC (just true)))
    (
      R.catchTC
     (R.extendContext "i" (varg (R.def (quote I) [])) $
                ( R.noConstraints $ R.unify (x') sym[x‚ÇÅ'] >> R.returnTC (just false)))
        (R.returnTC nothing)
        )

concatUniq : List R.Term ‚Üí List R.Term ‚Üí  R.TC (List R.Term)
concatUniq [] = R.returnTC
concatUniq (x ‚à∑ x‚ÇÇ) x‚ÇÅ  = appendIfUniqe x x‚ÇÅ >>= concatUniq x‚ÇÇ

indexOfAlways : R.Term ‚Üí List R.Term ‚Üí   R.TC ((List R.Term) √ó (Bool √ó ‚Ñï))
indexOfAlways t [] = R.returnTC ([ t ] , (true , 0))
indexOfAlways t xs@(x ‚à∑ xs') =
  comparePathTerms t x >>=
   Mb.rec ((Œª (l , (b , k) ) ‚Üí (x ‚à∑ l) , (b , (suc k))) <$> indexOfAlways t xs' )
          (Œª b ‚Üí R.returnTC (xs , (b , 0)))

gatherUniqeAtomPaths : GE.œÄ‚ÇÅGroupExpr R.Term ‚Üí R.TC (List R.Term)
gatherUniqeAtomPaths = flip w []
 where

 w : GE.œÄ‚ÇÅGroupExpr R.Term ‚Üí List R.Term ‚Üí  R.TC (List R.Term)
 w (GE.atomGE x) l = appendIfUniqe x l
 w GE.reflGE l = R.returnTC l
 w (x GE.¬∑¬∑ x‚ÇÅ ¬∑¬∑ x‚ÇÇ) l = do l' ‚Üê w x l ; w x‚ÇÅ l' >>= w x‚ÇÇ


unMapAtoms : List R.Term ‚Üí GE.œÄ‚ÇÅGroupExpr R.Term ‚Üí
     (R.TC ((List R.Term) √ó GE.œÄ‚ÇÅGroupExpr (Bool √ó ‚Ñï)))
unMapAtoms l (GE.atomGE x) =
 do (l' , y) ‚Üê indexOfAlways x l
    R.returnTC (l' , GE.atomGE y)
unMapAtoms l GE.reflGE = R.returnTC (l , GE.reflGE)
unMapAtoms l (e GE.¬∑¬∑ e‚ÇÅ ¬∑¬∑ e‚ÇÇ) = do
  (l' , e') ‚Üê unMapAtoms l e
  (l'' , e‚ÇÅ') ‚Üê unMapAtoms l' e‚ÇÅ
  (l''' , e‚ÇÇ') ‚Üê unMapAtoms l'' e‚ÇÇ
  (R.returnTC (l''' , (e' GE.¬∑¬∑ e‚ÇÅ' ¬∑¬∑ e‚ÇÇ')))



œÄ‚ÇÅgroupSolverMain : Bool ‚Üí R.Term ‚Üí R.Term ‚Üí R.Term ‚Üí R.Term ‚Üí R.TC Unit
œÄ‚ÇÅgroupSolverMain debugFlag t-A t-isGrpA t-a hole = do
 (_ , (t0 , t1)) ‚Üê inferEnds hole
 t0N ‚Üê R.normalise t0
 t1N ‚Üê R.normalise t1
 r0 ‚Üê tryŒ©E.tryŒ© t-A t-a 100 t0N
 r1 ‚Üê tryŒ©E.tryŒ© t-A t-a 100 t1N
 (aL' , e0) ‚Üê unMapAtoms [] r0
 (aL , e1) ‚Üê unMapAtoms aL' r1
 e0Q ‚Üê R.quoteTC e0
 e1Q ‚Üê R.quoteTC e1

 let dbgInfo =   (R.strErr "LHS: ") ‚à∑ (R.strErr $ showœÄ‚ÇÅGE‚Ñï e0)
               ‚à∑ (R.strErr "\n")
               ‚à∑ (R.strErr "RHS: ") ‚à∑  (R.strErr $ showœÄ‚ÇÅGE‚Ñï e1)
               ‚à∑ (R.strErr "\n")
               ‚à∑ ((niceAtomList 0 aL))

 final ‚Üê R.reduce (R.def (quote œÄSolver.solveœÄ) (t-A v‚à∑ t-isGrpA v‚à∑ t-a v‚à∑ (quoteList aL)
    v‚à∑ e0Q v‚à∑ e1Q v‚à∑ [] ))
 R.catchTC
  (R.unify hole final)
  (R.typeError $ (R.strErr "LHS ‚â¢ RHS \n\n") ‚à∑ dbgInfo)

 where
 niceAtomList : ‚Ñï ‚Üí List (R.Term) ‚Üí List R.ErrorPart
 niceAtomList _ [] = []
 niceAtomList k (x ‚à∑ xs) =
   (R.strErr (mkNiceVar k  <> " = ") ‚à∑ R.termErr x ‚à∑ [ R.strErr "\n" ]) ++ niceAtomList (suc k) xs

macro
 œÄ‚ÇÅsolveGroupDebug : R.Term ‚Üí R.Term ‚Üí R.Term ‚Üí R.Term ‚Üí R.TC Unit
 œÄ‚ÇÅsolveGroupDebug = œÄ‚ÇÅgroupSolverMain true

 œÄ‚ÇÅsolveGroup : R.Term ‚Üí R.Term ‚Üí R.Term ‚Üí R.Term ‚Üí R.TC Unit
 œÄ‚ÇÅsolveGroup = œÄ‚ÇÅgroupSolverMain false
