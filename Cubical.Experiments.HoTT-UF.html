<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Cubical.Experiments.HoTT-UF</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">{-

This is a HoTT-UF core library based on cubical type theory, where the
cubical machinery is hidden, using the HoTT Book terminology and
notation.

The point is that function extensionality, propositional truncation
and univalence compute (an example is given below).

For the moment, this requires the development version of Agda.

-}</a>

<a id="341" class="Symbol">{-#</a> <a id="345" class="Keyword">OPTIONS</a> <a id="353" class="Pragma">--exact-split</a> <a id="367" class="Pragma">--safe</a> <a id="374" class="Symbol">#-}</a>

<a id="379" class="Keyword">module</a> <a id="386" href="Cubical.Experiments.HoTT-UF.html" class="Module">Cubical.Experiments.HoTT-UF</a> <a id="414" class="Keyword">where</a>

<a id="421" class="Keyword">open</a> <a id="426" class="Keyword">import</a> <a id="433" href="Cubical.Core.Primitives.html" class="Module">Cubical.Core.Primitives</a> <a id="457" class="Keyword">hiding</a> <a id="464" class="Symbol">(</a> <a id="466" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">_≡_</a> <a id="470" class="Symbol">)</a>
<a id="472" class="Keyword">open</a> <a id="477" class="Keyword">import</a> <a id="484" href="Cubical.Core.Id.html" class="Module">Cubical.Core.Id</a> <a id="500" class="Keyword">public</a>

<a id="508" class="Keyword">open</a> <a id="513" class="Keyword">import</a> <a id="520" href="Cubical.Foundations.Id.html" class="Module">Cubical.Foundations.Id</a> <a id="543" class="Keyword">public</a>
     <a id="555" class="Keyword">using</a> <a id="561" class="Symbol">(</a> <a id="563" href="Cubical.Core.Id.html#981" class="Function Operator">_≡_</a>            <a id="578" class="Comment">-- The identity type.</a>
           <a id="611" class="Symbol">;</a> <a id="613" href="Cubical.Foundations.Id.html#2031" class="Function">refl</a>           <a id="628" class="Comment">-- Unfortunately, pattern matching on refl is not available.</a>
           <a id="700" class="Symbol">;</a> <a id="702" href="Cubical.Foundations.Id.html#2193" class="Function">J</a>              <a id="717" class="Comment">-- Until it is, you have to use the induction principle J.</a>

           <a id="788" class="Symbol">;</a> <a id="790" href="Cubical.Foundations.Id.html#2624" class="Function">transport</a>      <a id="805" class="Comment">-- As in the HoTT Book.</a>
           <a id="840" class="Symbol">;</a> <a id="842" href="Cubical.Foundations.Id.html#2814" class="Function">ap</a>
           <a id="856" class="Symbol">;</a> <a id="858" href="Cubical.Foundations.Id.html#2920" class="Function Operator">_∙_</a>
           <a id="873" class="Symbol">;</a> <a id="875" href="Cubical.Foundations.Id.html#2740" class="Function Operator">_⁻¹</a>

           <a id="891" class="Symbol">;</a> <a id="893" href="Cubical.Foundations.Id.html#3043" class="Function Operator">_≡⟨_⟩_</a>         <a id="908" class="Comment">-- Standard equational reasoning.</a>
           <a id="953" class="Symbol">;</a> <a id="955" href="Cubical.Foundations.Id.html#3114" class="Function Operator">_∎</a>

           <a id="970" class="Symbol">;</a> <a id="972" href="Cubical.Foundations.Id.html#4043" class="Function">funExt</a>         <a id="987" class="Comment">-- Function extensionality</a>
                            <a id="1042" class="Comment">-- (can also be derived from univalence).</a>

           <a id="1096" class="Symbol">;</a> <a id="1098" href="Agda.Builtin.Sigma.html#148" class="Record">Σ</a>              <a id="1113" class="Comment">-- Sum type. Needed to define contractible types, equivalences</a>
           <a id="1187" class="Symbol">;</a> <a id="1189" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">_,_</a>            <a id="1204" class="Comment">-- and univalence.</a>
           <a id="1234" class="Symbol">;</a> <a id="1236" href="Cubical.Foundations.Id.html#954" class="Field">pr₁</a>            <a id="1251" class="Comment">-- The eta rule is available.</a>
           <a id="1292" class="Symbol">;</a> <a id="1294" href="Cubical.Foundations.Id.html#1007" class="Field">pr₂</a>

           <a id="1310" class="Symbol">;</a> <a id="1312" href="Cubical.Foundations.Id.html#4401" class="Function">isProp</a>         <a id="1327" class="Comment">-- The usual notions of proposition, contractible type, set.</a>
           <a id="1399" class="Symbol">;</a> <a id="1401" href="Cubical.Foundations.Id.html#4337" class="Function">isContr</a>
           <a id="1420" class="Symbol">;</a> <a id="1422" href="Cubical.Foundations.Id.html#4456" class="Function">isSet</a>

           <a id="1440" class="Symbol">;</a> <a id="1442" href="Cubical.Foundations.Id.html#4525" class="Record">isEquiv</a>        <a id="1457" class="Comment">-- A map with contractible fibers</a>
                            <a id="1519" class="Comment">-- (Voevodsky&#39;s version of the notion).</a>
           <a id="1570" class="Symbol">;</a> <a id="1572" href="Cubical.Foundations.Id.html#4689" class="Function Operator">_≃_</a>            <a id="1587" class="Comment">-- The type of equivalences between two given types.</a>
           <a id="1651" class="Symbol">;</a> <a id="1653" href="Cubical.Foundations.Id.html#9111" class="Function">EquivContr</a>     <a id="1668" class="Comment">-- A formulation of univalence.</a>

           <a id="1712" class="Symbol">;</a> <a id="1714" href="Cubical.HITs.PropositionalTruncation.Base.html#249" class="Datatype Operator">∥_∥₁</a>            <a id="1730" class="Comment">-- Propositional truncation.</a>
           <a id="1770" class="Symbol">;</a> <a id="1772" href="Cubical.HITs.PropositionalTruncation.Base.html#288" class="InductiveConstructor Operator">∣_∣₁</a>             <a id="1789" class="Comment">-- Map into the propositional truncation.</a>
           <a id="1842" class="Symbol">;</a> <a id="1844" href="Cubical.Foundations.Id.html#9651" class="Function">∥∥-isProp</a>       <a id="1860" class="Comment">-- A truncated type is a proposition.</a>
           <a id="1909" class="Symbol">;</a> <a id="1911" href="Cubical.Foundations.Id.html#9728" class="Function">∥∥-recursion</a>    <a id="1927" class="Comment">-- Non-dependent elimination.</a>
           <a id="1968" class="Symbol">;</a> <a id="1970" href="Cubical.Foundations.Id.html#9879" class="Function">∥∥-induction</a>    <a id="1986" class="Comment">-- Dependent elimination.</a>
           <a id="2023" class="Symbol">)</a>

<a id="2026" class="Comment">{-

Here is an illustration of how function extensionality computes.

-}</a>

<a id="2100" class="Keyword">private</a>

  <a id="2111" class="Keyword">data</a> <a id="ℕ"></a><a id="2116" href="Cubical.Experiments.HoTT-UF.html#2116" class="Datatype">ℕ</a> <a id="2118" class="Symbol">:</a> <a id="2120" href="Agda.Primitive.html#320" class="Primitive">Type₀</a> <a id="2126" class="Keyword">where</a>
   <a id="ℕ.zero"></a><a id="2135" href="Cubical.Experiments.HoTT-UF.html#2135" class="InductiveConstructor">zero</a> <a id="2140" class="Symbol">:</a> <a id="2142" href="Cubical.Experiments.HoTT-UF.html#2116" class="Datatype">ℕ</a>
   <a id="ℕ.succ"></a><a id="2147" href="Cubical.Experiments.HoTT-UF.html#2147" class="InductiveConstructor">succ</a> <a id="2152" class="Symbol">:</a> <a id="2154" href="Cubical.Experiments.HoTT-UF.html#2116" class="Datatype">ℕ</a> <a id="2156" class="Symbol">→</a> <a id="2158" href="Cubical.Experiments.HoTT-UF.html#2116" class="Datatype">ℕ</a>

  <a id="f"></a><a id="2163" href="Cubical.Experiments.HoTT-UF.html#2163" class="Function">f</a> <a id="g"></a><a id="2165" href="Cubical.Experiments.HoTT-UF.html#2165" class="Function">g</a> <a id="2167" class="Symbol">:</a> <a id="2169" href="Cubical.Experiments.HoTT-UF.html#2116" class="Datatype">ℕ</a> <a id="2171" class="Symbol">→</a> <a id="2173" href="Cubical.Experiments.HoTT-UF.html#2116" class="Datatype">ℕ</a>

  <a id="2178" href="Cubical.Experiments.HoTT-UF.html#2163" class="Function">f</a> <a id="2180" href="Cubical.Experiments.HoTT-UF.html#2180" class="Bound">n</a> <a id="2182" class="Symbol">=</a> <a id="2184" href="Cubical.Experiments.HoTT-UF.html#2180" class="Bound">n</a>

  <a id="2189" href="Cubical.Experiments.HoTT-UF.html#2165" class="Function">g</a> <a id="2191" href="Cubical.Experiments.HoTT-UF.html#2135" class="InductiveConstructor">zero</a> <a id="2196" class="Symbol">=</a> <a id="2198" href="Cubical.Experiments.HoTT-UF.html#2135" class="InductiveConstructor">zero</a>
  <a id="2205" href="Cubical.Experiments.HoTT-UF.html#2165" class="Function">g</a> <a id="2207" class="Symbol">(</a><a id="2208" href="Cubical.Experiments.HoTT-UF.html#2147" class="InductiveConstructor">succ</a> <a id="2213" href="Cubical.Experiments.HoTT-UF.html#2213" class="Bound">n</a><a id="2214" class="Symbol">)</a> <a id="2216" class="Symbol">=</a> <a id="2218" href="Cubical.Experiments.HoTT-UF.html#2147" class="InductiveConstructor">succ</a> <a id="2223" class="Symbol">(</a><a id="2224" href="Cubical.Experiments.HoTT-UF.html#2165" class="Function">g</a> <a id="2226" href="Cubical.Experiments.HoTT-UF.html#2213" class="Bound">n</a><a id="2227" class="Symbol">)</a>

  <a id="h"></a><a id="2232" href="Cubical.Experiments.HoTT-UF.html#2232" class="Function">h</a> <a id="2234" class="Symbol">:</a> <a id="2236" class="Symbol">(</a><a id="2237" href="Cubical.Experiments.HoTT-UF.html#2237" class="Bound">n</a> <a id="2239" class="Symbol">:</a> <a id="2241" href="Cubical.Experiments.HoTT-UF.html#2116" class="Datatype">ℕ</a><a id="2242" class="Symbol">)</a> <a id="2244" class="Symbol">→</a> <a id="2246" href="Cubical.Experiments.HoTT-UF.html#2163" class="Function">f</a> <a id="2248" href="Cubical.Experiments.HoTT-UF.html#2237" class="Bound">n</a> <a id="2250" href="Cubical.Core.Id.html#981" class="Function Operator">≡</a> <a id="2252" href="Cubical.Experiments.HoTT-UF.html#2165" class="Function">g</a> <a id="2254" href="Cubical.Experiments.HoTT-UF.html#2237" class="Bound">n</a>
  <a id="2258" href="Cubical.Experiments.HoTT-UF.html#2232" class="Function">h</a> <a id="2260" href="Cubical.Experiments.HoTT-UF.html#2135" class="InductiveConstructor">zero</a> <a id="2265" class="Symbol">=</a> <a id="2267" href="Cubical.Foundations.Id.html#2031" class="Function">refl</a>
  <a id="2274" href="Cubical.Experiments.HoTT-UF.html#2232" class="Function">h</a> <a id="2276" class="Symbol">(</a><a id="2277" href="Cubical.Experiments.HoTT-UF.html#2147" class="InductiveConstructor">succ</a> <a id="2282" href="Cubical.Experiments.HoTT-UF.html#2282" class="Bound">n</a><a id="2283" class="Symbol">)</a> <a id="2285" class="Symbol">=</a> <a id="2287" href="Cubical.Foundations.Id.html#2814" class="Function">ap</a> <a id="2290" href="Cubical.Experiments.HoTT-UF.html#2147" class="InductiveConstructor">succ</a> <a id="2295" class="Symbol">(</a><a id="2296" href="Cubical.Experiments.HoTT-UF.html#2232" class="Function">h</a> <a id="2298" href="Cubical.Experiments.HoTT-UF.html#2282" class="Bound">n</a><a id="2299" class="Symbol">)</a>

  <a id="p"></a><a id="2304" href="Cubical.Experiments.HoTT-UF.html#2304" class="Function">p</a> <a id="2306" class="Symbol">:</a> <a id="2308" href="Cubical.Experiments.HoTT-UF.html#2163" class="Function">f</a> <a id="2310" href="Cubical.Core.Id.html#981" class="Function Operator">≡</a> <a id="2312" href="Cubical.Experiments.HoTT-UF.html#2165" class="Function">g</a>
  <a id="2316" href="Cubical.Experiments.HoTT-UF.html#2304" class="Function">p</a> <a id="2318" class="Symbol">=</a> <a id="2320" href="Cubical.Foundations.Id.html#4043" class="Function">funExt</a> <a id="2327" href="Cubical.Experiments.HoTT-UF.html#2232" class="Function">h</a>

  <a id="five"></a><a id="2332" href="Cubical.Experiments.HoTT-UF.html#2332" class="Function">five</a> <a id="2337" class="Symbol">:</a> <a id="2339" href="Cubical.Experiments.HoTT-UF.html#2116" class="Datatype">ℕ</a>
  <a id="2343" href="Cubical.Experiments.HoTT-UF.html#2332" class="Function">five</a> <a id="2348" class="Symbol">=</a> <a id="2350" href="Cubical.Experiments.HoTT-UF.html#2147" class="InductiveConstructor">succ</a> <a id="2355" class="Symbol">(</a><a id="2356" href="Cubical.Experiments.HoTT-UF.html#2147" class="InductiveConstructor">succ</a> <a id="2361" class="Symbol">(</a><a id="2362" href="Cubical.Experiments.HoTT-UF.html#2147" class="InductiveConstructor">succ</a> <a id="2367" class="Symbol">(</a><a id="2368" href="Cubical.Experiments.HoTT-UF.html#2147" class="InductiveConstructor">succ</a> <a id="2373" class="Symbol">(</a><a id="2374" href="Cubical.Experiments.HoTT-UF.html#2147" class="InductiveConstructor">succ</a> <a id="2379" href="Cubical.Experiments.HoTT-UF.html#2135" class="InductiveConstructor">zero</a><a id="2383" class="Symbol">))))</a>

  <a id="a"></a><a id="2391" href="Cubical.Experiments.HoTT-UF.html#2391" class="Function">a</a> <a id="2393" class="Symbol">:</a> <a id="2395" href="Agda.Builtin.Sigma.html#148" class="Record">Σ</a> <a id="2397" href="Cubical.Experiments.HoTT-UF.html#2116" class="Datatype">ℕ</a> <a id="2399" class="Symbol">(λ</a> <a id="2402" href="Cubical.Experiments.HoTT-UF.html#2402" class="Bound">n</a> <a id="2404" class="Symbol">→</a> <a id="2406" href="Cubical.Experiments.HoTT-UF.html#2163" class="Function">f</a> <a id="2408" href="Cubical.Experiments.HoTT-UF.html#2402" class="Bound">n</a> <a id="2410" href="Cubical.Core.Id.html#981" class="Function Operator">≡</a> <a id="2412" href="Cubical.Experiments.HoTT-UF.html#2332" class="Function">five</a><a id="2416" class="Symbol">)</a>
  <a id="2420" href="Cubical.Experiments.HoTT-UF.html#2391" class="Function">a</a> <a id="2422" class="Symbol">=</a> <a id="2424" href="Cubical.Experiments.HoTT-UF.html#2332" class="Function">five</a> <a id="2429" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="2431" href="Cubical.Foundations.Id.html#2031" class="Function">refl</a>

  <a id="b"></a><a id="2439" href="Cubical.Experiments.HoTT-UF.html#2439" class="Function">b</a> <a id="2441" class="Symbol">:</a> <a id="2443" href="Agda.Builtin.Sigma.html#148" class="Record">Σ</a> <a id="2445" href="Cubical.Experiments.HoTT-UF.html#2116" class="Datatype">ℕ</a> <a id="2447" class="Symbol">(λ</a> <a id="2450" href="Cubical.Experiments.HoTT-UF.html#2450" class="Bound">n</a> <a id="2452" class="Symbol">→</a> <a id="2454" href="Cubical.Experiments.HoTT-UF.html#2165" class="Function">g</a> <a id="2456" href="Cubical.Experiments.HoTT-UF.html#2450" class="Bound">n</a> <a id="2458" href="Cubical.Core.Id.html#981" class="Function Operator">≡</a> <a id="2460" href="Cubical.Experiments.HoTT-UF.html#2332" class="Function">five</a><a id="2464" class="Symbol">)</a>
  <a id="2468" href="Cubical.Experiments.HoTT-UF.html#2439" class="Function">b</a> <a id="2470" class="Symbol">=</a> <a id="2472" href="Cubical.Foundations.Id.html#2624" class="Function">transport</a> <a id="2482" class="Symbol">(λ</a> <a id="2485" href="Cubical.Experiments.HoTT-UF.html#2485" class="Bound">-</a> <a id="2487" class="Symbol">→</a> <a id="2489" href="Agda.Builtin.Sigma.html#148" class="Record">Σ</a> <a id="2491" href="Cubical.Experiments.HoTT-UF.html#2116" class="Datatype">ℕ</a> <a id="2493" class="Symbol">(λ</a> <a id="2496" href="Cubical.Experiments.HoTT-UF.html#2496" class="Bound">n</a> <a id="2498" class="Symbol">→</a> <a id="2500" href="Cubical.Experiments.HoTT-UF.html#2485" class="Bound">-</a> <a id="2502" href="Cubical.Experiments.HoTT-UF.html#2496" class="Bound">n</a> <a id="2504" href="Cubical.Core.Id.html#981" class="Function Operator">≡</a> <a id="2506" href="Cubical.Experiments.HoTT-UF.html#2332" class="Function">five</a><a id="2510" class="Symbol">))</a> <a id="2513" href="Cubical.Experiments.HoTT-UF.html#2304" class="Function">p</a> <a id="2515" href="Cubical.Experiments.HoTT-UF.html#2391" class="Function">a</a>

  <a id="c"></a><a id="2520" href="Cubical.Experiments.HoTT-UF.html#2520" class="Function">c</a> <a id="2522" class="Symbol">:</a> <a id="2524" href="Cubical.Foundations.Id.html#954" class="Field">pr₁</a> <a id="2528" href="Cubical.Experiments.HoTT-UF.html#2439" class="Function">b</a> <a id="2530" href="Cubical.Core.Id.html#981" class="Function Operator">≡</a> <a id="2532" href="Cubical.Experiments.HoTT-UF.html#2332" class="Function">five</a>
  <a id="2539" href="Cubical.Experiments.HoTT-UF.html#2520" class="Function">c</a> <a id="2541" class="Symbol">=</a> <a id="2543" href="Cubical.Foundations.Id.html#2031" class="Function">refl</a>

<a id="2549" class="Comment">{-

If we had funExt as a postulate, then the definition of c would not
type check. Moreover, the term pr₁ b would not evaluate to five, as it
does with the cubical type theory implementation of funext.

TODO. A similar computational example with univalence.

-}</a>
</pre></body></html>