<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Cubical.Experiments.HoTT-UF</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">{-

This is a HoTT-UF core library based on cubical type theory, where the
cubical machinery is hidden, using the HoTT Book terminology and
notation.

The point is that function extensionality, propositional truncation
and univalence compute (an example is given below).

For the moment, this requires the development version of Agda.

-}</a>

<a id="341" class="Symbol">{-#</a> <a id="345" class="Keyword">OPTIONS</a> <a id="353" class="Pragma">--exact-split</a> <a id="367" class="Symbol">#-}</a>

<a id="372" class="Keyword">module</a> <a id="379" href="Cubical.Experiments.HoTT-UF.html" class="Module">Cubical.Experiments.HoTT-UF</a> <a id="407" class="Keyword">where</a>

<a id="414" class="Keyword">open</a> <a id="419" class="Keyword">import</a> <a id="426" href="Cubical.Core.Primitives.html" class="Module">Cubical.Core.Primitives</a> <a id="450" class="Keyword">hiding</a> <a id="457" class="Symbol">(</a> <a id="459" href="Agda.Builtin.Cubical.Path.html#272" class="Function Operator">_≡_</a> <a id="463" class="Symbol">)</a>

<a id="466" class="Keyword">open</a> <a id="471" class="Keyword">import</a> <a id="478" href="Cubical.Data.Equality.html" class="Module">Cubical.Data.Equality</a> <a id="500" class="Keyword">public</a>
     <a id="512" class="Keyword">using</a> <a id="518" class="Symbol">(</a> <a id="520" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">_≡_</a>            <a id="535" class="Comment">-- The identity type.</a>
           <a id="568" class="Symbol">;</a> <a id="570" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>           <a id="585" class="Comment">-- Unfortunately, pattern matching on refl is not available.</a>
           <a id="657" class="Symbol">;</a> <a id="659" href="Cubical.Data.Equality.Base.html#564" class="Function">J</a>              <a id="674" class="Comment">-- Until it is, you have to use the induction principle J.</a>

           <a id="745" class="Symbol">;</a> <a id="747" href="Cubical.Data.Equality.Base.html#955" class="Function">transport</a>      <a id="762" class="Comment">-- As in the HoTT Book.</a>
           <a id="797" class="Symbol">;</a> <a id="799" href="Cubical.Data.Equality.Base.html#652" class="Function">ap</a>
           <a id="813" class="Symbol">;</a> <a id="815" href="Cubical.Data.Equality.Base.html#731" class="Function Operator">_∙_</a>

           <a id="831" class="Symbol">;</a> <a id="833" href="Cubical.Data.Equality.Base.html#803" class="Function">step-≡</a>         <a id="848" class="Comment">-- Standard equational reasoning.</a>
           <a id="893" class="Symbol">;</a> <a id="895" href="Cubical.Data.Equality.Base.html#922" class="Function Operator">_∎</a>

           <a id="910" class="Symbol">;</a> <a id="912" href="Cubical.Data.Equality.Conversion.html#2835" class="Function">funExt</a>         <a id="927" class="Comment">-- Function extensionality</a>
                            <a id="982" class="Comment">-- (can also be derived from univalence).</a>

           <a id="1036" class="Symbol">;</a> <a id="1038" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a>              <a id="1053" class="Comment">-- Sum type. Needed to define contractible types, equivalences</a>
           <a id="1127" class="Symbol">;</a> <a id="1129" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a>            <a id="1144" class="Comment">-- and univalence.</a>
           <a id="1174" class="Symbol">;</a> <a id="1176" href="Cubical.Data.Equality.Base.html#361" class="Field">pr₁</a>            <a id="1191" class="Comment">-- The eta rule is available.</a>
           <a id="1232" class="Symbol">;</a> <a id="1234" href="Cubical.Data.Equality.Base.html#373" class="Field">pr₂</a>

           <a id="1250" class="Symbol">;</a> <a id="1252" href="Cubical.Data.Equality.Base.html#2278" class="Function">isProp</a>         <a id="1267" class="Comment">-- The usual notions of proposition, contractible type, set.</a>
           <a id="1339" class="Symbol">;</a> <a id="1341" href="Cubical.Data.Equality.Base.html#2214" class="Function">isContr</a>

           <a id="1361" class="Symbol">;</a> <a id="1363" href="Cubical.Data.Equality.Base.html#2340" class="Record">isEquiv</a>        <a id="1378" class="Comment">-- A map with contractible fibers</a>
                            <a id="1440" class="Comment">-- (Voevodsky&#39;s version of the notion).</a>
           <a id="1491" class="Symbol">;</a> <a id="1493" href="Cubical.Data.Equality.Base.html#2498" class="Function Operator">_≃_</a>            <a id="1508" class="Comment">-- The type of equivalences between two given types.</a>
           <a id="1572" class="Symbol">;</a> <a id="1574" href="Cubical.Data.Equality.Univalence.html#1894" class="Function">univalence</a>
           <a id="1596" class="Symbol">;</a> <a id="1598" href="Cubical.Data.Equality.Univalence.html#990" class="Function">ua</a>             <a id="1613" class="Comment">-- A formulation of univalence.</a>

           <a id="1657" class="Symbol">;</a> <a id="1659" href="Cubical.HITs.PropositionalTruncation.Base.html#226" class="Datatype Operator">∥_∥₁</a>            <a id="1675" class="Comment">-- Propositional truncation.</a>
           <a id="1715" class="Symbol">;</a> <a id="1717" href="Cubical.HITs.PropositionalTruncation.Base.html#265" class="InductiveConstructor Operator">∣_∣₁</a>            <a id="1733" class="Comment">-- Map into the propositional truncation.</a>
           <a id="1786" class="Symbol">;</a> <a id="1788" href="Cubical.Data.Equality.PropositionalTruncation.html#569" class="Function">squash₁</a>         <a id="1804" class="Comment">-- A truncated type is a proposition.</a>
           <a id="1853" class="Symbol">;</a> <a id="1855" href="Cubical.Data.Equality.PropositionalTruncation.html#644" class="Function">∥∥-rec</a>          <a id="1871" class="Comment">-- Non-dependent elimination.</a>
           <a id="1912" class="Symbol">;</a> <a id="1914" href="Cubical.Data.Equality.PropositionalTruncation.html#774" class="Function">∥∥-elim</a>         <a id="1930" class="Comment">-- Dependent elimination.</a>
           <a id="1967" class="Symbol">)</a>
           <a id="1980" class="Keyword">renaming</a> <a id="1989" class="Symbol">(</a><a id="1990" href="Cubical.Data.Equality.Base.html#1041" class="Function">sym</a> <a id="1994" class="Symbol">to</a> <a id="1997" class="Function">_⁻¹</a><a id="2000" class="Symbol">)</a>

<a id="2003" class="Comment">{-

Here is an illustration of how function extensionality computes.

-}</a>

<a id="2077" class="Keyword">private</a>

  <a id="2088" class="Keyword">data</a> <a id="ℕ"></a><a id="2093" href="Cubical.Experiments.HoTT-UF.html#2093" class="Datatype">ℕ</a> <a id="2095" class="Symbol">:</a> <a id="2097" href="Agda.Primitive.html#388" class="Primitive">Type₀</a> <a id="2103" class="Keyword">where</a>
   <a id="ℕ.zero"></a><a id="2112" href="Cubical.Experiments.HoTT-UF.html#2112" class="InductiveConstructor">zero</a> <a id="2117" class="Symbol">:</a> <a id="2119" href="Cubical.Experiments.HoTT-UF.html#2093" class="Datatype">ℕ</a>
   <a id="ℕ.succ"></a><a id="2124" href="Cubical.Experiments.HoTT-UF.html#2124" class="InductiveConstructor">succ</a> <a id="2129" class="Symbol">:</a> <a id="2131" href="Cubical.Experiments.HoTT-UF.html#2093" class="Datatype">ℕ</a> <a id="2133" class="Symbol">→</a> <a id="2135" href="Cubical.Experiments.HoTT-UF.html#2093" class="Datatype">ℕ</a>

  <a id="f"></a><a id="2140" href="Cubical.Experiments.HoTT-UF.html#2140" class="Function">f</a> <a id="g"></a><a id="2142" href="Cubical.Experiments.HoTT-UF.html#2142" class="Function">g</a> <a id="2144" class="Symbol">:</a> <a id="2146" href="Cubical.Experiments.HoTT-UF.html#2093" class="Datatype">ℕ</a> <a id="2148" class="Symbol">→</a> <a id="2150" href="Cubical.Experiments.HoTT-UF.html#2093" class="Datatype">ℕ</a>

  <a id="2155" href="Cubical.Experiments.HoTT-UF.html#2140" class="Function">f</a> <a id="2157" href="Cubical.Experiments.HoTT-UF.html#2157" class="Bound">n</a> <a id="2159" class="Symbol">=</a> <a id="2161" href="Cubical.Experiments.HoTT-UF.html#2157" class="Bound">n</a>

  <a id="2166" href="Cubical.Experiments.HoTT-UF.html#2142" class="Function">g</a> <a id="2168" href="Cubical.Experiments.HoTT-UF.html#2112" class="InductiveConstructor">zero</a> <a id="2173" class="Symbol">=</a> <a id="2175" href="Cubical.Experiments.HoTT-UF.html#2112" class="InductiveConstructor">zero</a>
  <a id="2182" href="Cubical.Experiments.HoTT-UF.html#2142" class="Function">g</a> <a id="2184" class="Symbol">(</a><a id="2185" href="Cubical.Experiments.HoTT-UF.html#2124" class="InductiveConstructor">succ</a> <a id="2190" href="Cubical.Experiments.HoTT-UF.html#2190" class="Bound">n</a><a id="2191" class="Symbol">)</a> <a id="2193" class="Symbol">=</a> <a id="2195" href="Cubical.Experiments.HoTT-UF.html#2124" class="InductiveConstructor">succ</a> <a id="2200" class="Symbol">(</a><a id="2201" href="Cubical.Experiments.HoTT-UF.html#2142" class="Function">g</a> <a id="2203" href="Cubical.Experiments.HoTT-UF.html#2190" class="Bound">n</a><a id="2204" class="Symbol">)</a>

  <a id="h"></a><a id="2209" href="Cubical.Experiments.HoTT-UF.html#2209" class="Function">h</a> <a id="2211" class="Symbol">:</a> <a id="2213" class="Symbol">(</a><a id="2214" href="Cubical.Experiments.HoTT-UF.html#2214" class="Bound">n</a> <a id="2216" class="Symbol">:</a> <a id="2218" href="Cubical.Experiments.HoTT-UF.html#2093" class="Datatype">ℕ</a><a id="2219" class="Symbol">)</a> <a id="2221" class="Symbol">→</a> <a id="2223" href="Cubical.Experiments.HoTT-UF.html#2140" class="Function">f</a> <a id="2225" href="Cubical.Experiments.HoTT-UF.html#2214" class="Bound">n</a> <a id="2227" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2229" href="Cubical.Experiments.HoTT-UF.html#2142" class="Function">g</a> <a id="2231" href="Cubical.Experiments.HoTT-UF.html#2214" class="Bound">n</a>
  <a id="2235" href="Cubical.Experiments.HoTT-UF.html#2209" class="Function">h</a> <a id="2237" href="Cubical.Experiments.HoTT-UF.html#2112" class="InductiveConstructor">zero</a> <a id="2242" class="Symbol">=</a> <a id="2244" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
  <a id="2251" href="Cubical.Experiments.HoTT-UF.html#2209" class="Function">h</a> <a id="2253" class="Symbol">(</a><a id="2254" href="Cubical.Experiments.HoTT-UF.html#2124" class="InductiveConstructor">succ</a> <a id="2259" href="Cubical.Experiments.HoTT-UF.html#2259" class="Bound">n</a><a id="2260" class="Symbol">)</a> <a id="2262" class="Symbol">=</a> <a id="2264" href="Cubical.Data.Equality.Base.html#652" class="Function">ap</a> <a id="2267" href="Cubical.Experiments.HoTT-UF.html#2124" class="InductiveConstructor">succ</a> <a id="2272" class="Symbol">(</a><a id="2273" href="Cubical.Experiments.HoTT-UF.html#2209" class="Function">h</a> <a id="2275" href="Cubical.Experiments.HoTT-UF.html#2259" class="Bound">n</a><a id="2276" class="Symbol">)</a>

  <a id="p"></a><a id="2281" href="Cubical.Experiments.HoTT-UF.html#2281" class="Function">p</a> <a id="2283" class="Symbol">:</a> <a id="2285" href="Cubical.Experiments.HoTT-UF.html#2140" class="Function">f</a> <a id="2287" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2289" href="Cubical.Experiments.HoTT-UF.html#2142" class="Function">g</a>
  <a id="2293" href="Cubical.Experiments.HoTT-UF.html#2281" class="Function">p</a> <a id="2295" class="Symbol">=</a> <a id="2297" href="Cubical.Data.Equality.Conversion.html#2835" class="Function">funExt</a> <a id="2304" href="Cubical.Experiments.HoTT-UF.html#2209" class="Function">h</a>

  <a id="five"></a><a id="2309" href="Cubical.Experiments.HoTT-UF.html#2309" class="Function">five</a> <a id="2314" class="Symbol">:</a> <a id="2316" href="Cubical.Experiments.HoTT-UF.html#2093" class="Datatype">ℕ</a>
  <a id="2320" href="Cubical.Experiments.HoTT-UF.html#2309" class="Function">five</a> <a id="2325" class="Symbol">=</a> <a id="2327" href="Cubical.Experiments.HoTT-UF.html#2124" class="InductiveConstructor">succ</a> <a id="2332" class="Symbol">(</a><a id="2333" href="Cubical.Experiments.HoTT-UF.html#2124" class="InductiveConstructor">succ</a> <a id="2338" class="Symbol">(</a><a id="2339" href="Cubical.Experiments.HoTT-UF.html#2124" class="InductiveConstructor">succ</a> <a id="2344" class="Symbol">(</a><a id="2345" href="Cubical.Experiments.HoTT-UF.html#2124" class="InductiveConstructor">succ</a> <a id="2350" class="Symbol">(</a><a id="2351" href="Cubical.Experiments.HoTT-UF.html#2124" class="InductiveConstructor">succ</a> <a id="2356" href="Cubical.Experiments.HoTT-UF.html#2112" class="InductiveConstructor">zero</a><a id="2360" class="Symbol">))))</a>

  <a id="a"></a><a id="2368" href="Cubical.Experiments.HoTT-UF.html#2368" class="Function">a</a> <a id="2370" class="Symbol">:</a> <a id="2372" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="2374" href="Cubical.Experiments.HoTT-UF.html#2093" class="Datatype">ℕ</a> <a id="2376" class="Symbol">(λ</a> <a id="2379" href="Cubical.Experiments.HoTT-UF.html#2379" class="Bound">n</a> <a id="2381" class="Symbol">→</a> <a id="2383" href="Cubical.Experiments.HoTT-UF.html#2140" class="Function">f</a> <a id="2385" href="Cubical.Experiments.HoTT-UF.html#2379" class="Bound">n</a> <a id="2387" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2389" href="Cubical.Experiments.HoTT-UF.html#2309" class="Function">five</a><a id="2393" class="Symbol">)</a>
  <a id="2397" href="Cubical.Experiments.HoTT-UF.html#2368" class="Function">a</a> <a id="2399" class="Symbol">=</a> <a id="2401" href="Cubical.Experiments.HoTT-UF.html#2309" class="Function">five</a> <a id="2406" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2408" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

  <a id="b"></a><a id="2416" href="Cubical.Experiments.HoTT-UF.html#2416" class="Function">b</a> <a id="2418" class="Symbol">:</a> <a id="2420" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="2422" href="Cubical.Experiments.HoTT-UF.html#2093" class="Datatype">ℕ</a> <a id="2424" class="Symbol">(λ</a> <a id="2427" href="Cubical.Experiments.HoTT-UF.html#2427" class="Bound">n</a> <a id="2429" class="Symbol">→</a> <a id="2431" href="Cubical.Experiments.HoTT-UF.html#2142" class="Function">g</a> <a id="2433" href="Cubical.Experiments.HoTT-UF.html#2427" class="Bound">n</a> <a id="2435" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2437" href="Cubical.Experiments.HoTT-UF.html#2309" class="Function">five</a><a id="2441" class="Symbol">)</a>
  <a id="2445" href="Cubical.Experiments.HoTT-UF.html#2416" class="Function">b</a> <a id="2447" class="Symbol">=</a> <a id="2449" href="Cubical.Data.Equality.Base.html#955" class="Function">transport</a> <a id="2459" class="Symbol">(λ</a> <a id="2462" href="Cubical.Experiments.HoTT-UF.html#2462" class="Bound">-</a> <a id="2464" class="Symbol">→</a> <a id="2466" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a> <a id="2468" href="Cubical.Experiments.HoTT-UF.html#2093" class="Datatype">ℕ</a> <a id="2470" class="Symbol">(λ</a> <a id="2473" href="Cubical.Experiments.HoTT-UF.html#2473" class="Bound">n</a> <a id="2475" class="Symbol">→</a> <a id="2477" href="Cubical.Experiments.HoTT-UF.html#2462" class="Bound">-</a> <a id="2479" href="Cubical.Experiments.HoTT-UF.html#2473" class="Bound">n</a> <a id="2481" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2483" href="Cubical.Experiments.HoTT-UF.html#2309" class="Function">five</a><a id="2487" class="Symbol">))</a> <a id="2490" href="Cubical.Experiments.HoTT-UF.html#2281" class="Function">p</a> <a id="2492" href="Cubical.Experiments.HoTT-UF.html#2368" class="Function">a</a>

  <a id="c"></a><a id="2497" href="Cubical.Experiments.HoTT-UF.html#2497" class="Function">c</a> <a id="2499" class="Symbol">:</a> <a id="2501" href="Cubical.Data.Equality.Base.html#361" class="Field">pr₁</a> <a id="2505" href="Cubical.Experiments.HoTT-UF.html#2416" class="Function">b</a> <a id="2507" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="2509" href="Cubical.Experiments.HoTT-UF.html#2309" class="Function">five</a>
  <a id="2516" href="Cubical.Experiments.HoTT-UF.html#2497" class="Function">c</a> <a id="2518" class="Symbol">=</a> <a id="2520" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="2526" class="Comment">{-

If we had funExt as a postulate, then the definition of c would not
type check. Moreover, the term pr₁ b would not evaluate to five, as it
does with the cubical type theory implementation of funext.

TODO. A similar computational example with univalence.

-}</a>
</pre></body></html>